{"meta":{"title":"MapleStory","subtitle":null,"description":"CS:Dalian University of technology","author":"Eyc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Python测试","slug":"Python测试","date":"2018-11-10T09:49:22.000Z","updated":"2018-11-10T09:50:19.653Z","comments":true,"path":"2018/11/10/Python测试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python测试/","excerpt":"","text":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 Python中提供了单元测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950```pythonimport unittestclass TestIntSet(unittest.TestCase): def setUp(self): print(&apos;before Testing...&apos;) def test__init__(self): s = IntSet() self.assertTrue(isinstance(s.getMembers(), list)) def test_insert(self): s = IntSet() s.insert(1) self.assertEqual(s.getMembers(), [1]) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test_member(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) self.assertFalse(s.member(2)) def test_remove(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) s.remove(1) self.assertFalse(s.member(1)) def test_getMembers(self): s = IntSet() s.insert(1) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test__str__(self): s = IntSet() s.insert(5) s.insert(1) s.insert(2) self.assertEqual(s.__str__(), &apos;&#123;1,2,5&#125;&apos;) def tear_Down(self): print(&apos;after Testing...&apos;)if __name__ == &apos;__main__&apos;: unittest.main(argv=[&apos;ignored&apos;, &apos;-v&apos;], exit=False)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python面向对象","slug":"Python面向对象","date":"2018-11-10T08:48:28.000Z","updated":"2018-11-10T09:49:09.130Z","comments":true,"path":"2018/11/10/Python面向对象/","link":"","permalink":"http://yoursite.com/2018/11/10/Python面向对象/","excerpt":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。","text":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象思想的优点 可重用性 编写可重用模块，比如类 可扩展性 要求应用软件能够很方便、很容易的进行扩充和修改 可管理性 采用封装了数据和操作的类作为构建系统的部件，使项目组织更加方便合理 抽象数据类型与类抽象数据类型概念十分简单，抽象数据类型是由一个由对象及对象上操作组成的集合，对象和操作被捆绑成一个整体，可以从程序的一部分传递到另一部分。这个过程中不仅可以使用对象的数据属性，还可以使用对象上的操作。 类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现的分离编程技术。类的接口包含用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数以及定义类的各种私有函数。封装实现了类接口和实现的分离，封装后的类隐藏了实现细节，类用户只能访问接口而无法访问实现部分————-《c++ Primer》 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） Exp11234567891011121314151617181920212223242526272829class IntSet: \"\"\"实现一个整数集合\"\"\" def __init__(self): \"\"\"创建一个空的整数集合\"\"\" self.__vals = [] def insert(self, e): if e not in self.__vals: self.__vals.append(e) def member(self, e): return e in self.__vals def remove(self, e): try: self.__vals.remove(e) except: raise ValueError(str(e) + 'not found') def getMembers(self): return self.__vals[:] def __str__(self): self.__vals.sort() result = '' for e in self.__vals: result = result + str(e) + ',' return '&#123;'+ result[:-1] + '&#125;' Exp212345678910111213141516171819202122232425262728293031323334import datetimeclass Person: def __init__(self, name): self.name = name try: lastBlank = name.rindex(' ') self.lastName = name[lastBlank+1:] except: self.lastName = name self.birthday = None def getName(self): return self.name def getLastName(self): return self.lastName def setBirthday(self, birthdate): self.birthday = birthdate def getAge(self): if self.birthday == None: raise ValueError('not set birthday') return datetime.date.today().year-self.birthday.year def __lt__(self, other): if self.lastName == other.lastName: return self.name &lt; other.name return self.lastName &lt; other.lastName def __str__(self): return self.name Exp312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Student(Person): nextIdNum = 0 def __init__(self, name): Person.__init__(self, name) self.idNum = Student.nextIdNum Student.nextIdNum += 1 def getIdNum(self): return self.idNum def __lt__(self,other): return self.idNum &lt; other.idNumclass Grades: def __init__(self): self.students = [] self.grades = &#123;&#125; self.isSorted = True def addStudent(self, student): if student in self.students: raise ValueError('Duplicate student') self.students.append(student) self.grades[student.getIdNum()] = [] self.isSorted = False def addGrade(self, student, grade): try: self.grades[student.getIdNum()].append(grade) except: raise ValueError('Student not in mapping') def getGrades(self,student): try: return self.grades[student.getIdNum()][:] except: raise ValueError('Student not in mapping') def getStudents(self): if not self.isSorted: self.students.sort() self.isSorted = True return self.students[:] def gradeReport(self): report = '' for s in self.getStudents(): tot = 0.0 numGrades = 0 for g in self.getGrades(s): tot += g numGrades +=1 try: average = tot/numGrades report = report + '\\n' + str(s) + '\\'s mean grade is '+ str(average) except ZeroDivisionError: report = report + '\\n' + str(s) + 'has no grade ' return report","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python异常与断言","slug":"Python异常与断言","date":"2018-11-10T08:13:57.000Z","updated":"2018-11-10T08:29:48.665Z","comments":true,"path":"2018/11/10/Python异常与断言/","link":"","permalink":"http://yoursite.com/2018/11/10/Python异常与断言/","excerpt":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。","text":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。 下面是一个典型异常的例子 12345SuccessNum = input('Enter SuccessNum: ')totalNum = input('Enter totalNum: ')ac = int(SuccessNum)/int(totalNum)print('The AC ratio is',ac)print('Now here') 该段程序在大多数情况下是运行良好的，但是如果用户输入中出现了0，（或者干脆直接跳过）程序就会崩溃，这显然不是我们乐意看到的我们可以以下方式改写这段程序 12345678910try: SuccessNum = input('Enter SuccessNum: ') totalNum = input('Enter totalNum: ') ac = int(SuccessNum)/int(totalNum) print('The AC ratio is',ac)except ZeroDivisionError: print('Failure ! totalNum is 0')except ValueError: print('Error ! No input')print('Now here') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 异常的讨论异常看上去不太友好（毕竟如果不处理程序会崩溃），但总好于其他方式。使用异常时，程序员需要编写一些代码来处理特定异常。如果忘记处理某个异常那么这异常抛出时，程序便立刻停止。当然这也是好事，线性错误总好于隐士错误，我们来讨论BUG的问题。 显性-&gt;隐性 显性错误有明显表现，如程序崩溃或运行时间长；隐性错误没有正常表现，程序正常结束，不会出任何问题–错了给出一个错误答案。 持续-&gt;间歇 持续性错误在每次相同的运行输入时都会发生，间歇性错误仅在某些时候出现，即使是相同的输入和环境 显性错误和持续性错误是最好的，开发者不会对这种程序抱任何幻想，没有人愚蠢到使用这种程序。优秀的程序员编写程序时，会尽量使程序时显性和持续性的，这种编程方式称为防御性编程 以隐性方式出错的程序特别危险，因为他们表面没有任何问题。人们使用它并对他产生依赖。逐渐的我们的人类社会将对软件产生依赖，这些软件来执行超过人类能力的计算，我们甚至不能判断这些软件的计算是否正确。因此我们根本意识不到这个情况。这样的程序可能已经造成了严重危害。 断言Python 语言为程序员提供了一种确保程序运行状态符合预期的简单方法。 123def cal(num): assert num&gt;=0 return num**0.5","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python调试","slug":"Python调试","date":"2018-11-10T08:02:05.000Z","updated":"2018-11-10T08:29:13.077Z","comments":true,"path":"2018/11/10/Python调试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python调试/","excerpt":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() 调试过程可以看做是一个搜索过程，每次试验尽力缩减搜索空间。一个有效方法是，设计一个实验。该实验大致分为以下几步: 调查测试结果，弄清楚什么样的数据通过测试，什么样的数据未通过测试 建立一个符合现有数据的假设，假设可以很具体（403行x\\&lt;y改成x=y即可）也可以很宽泛（50-100行的循环出了问题） 设计一个推翻上述假设的实验，你应该能够明确解释出实验每种可能的结果 将你的实验记录下来 Tips for 调试 排除常见错误（这个需要经验） coding everyday 不要问自己为什么没有像你想的那样做，而是考虑程序为什么像现在这样做 错误可能不在你认为会出错的地方 试着向他人解释你的问题 不要盲目相信书上的东西（不要相信文档）大家应该首先学会读文档：） 暂停调试，先写文档 出去散散步，回头接着做 调试案例123456789101112131415161718192021222324252627282930# 调试案例# 下面程序有若干处bugdef isPal(x): \"\"\" 假设x是列表 如果列表是回文，则返回True，否则返回False \"\"\" temp = x temp.reverse() if temp == x: return True else: return Falsedef silly(n): \"\"\" 假设n是正整数 接收用户的n个输入 如果所有的输入组成一个回文列表，则返回‘Yes’ 否则返回‘No’ \"\"\" for i in range(n): result = [] elem = input('Enter element: ') result.append(elem) if(isPal(result)): return True else: return False Python的可变数据类型与不可变数据类型python中的不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化. 可变数据类型(mutable) Dictionary（字典） List（列表） 不可变数据类型(unmutable) Number（数字） String（字符串） Tuple（元组） Bool(布尔值) 1234567891011121314151617181920212223242526272829303132# 不可变数据类型a = 15b = 15print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")b = 20print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")# 可变数据类型a = [1,2,3]b = ac = [1,2,3]print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))print(\"**********友爱的分割线************\")b[0] = 4c[0] = 5print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"c的值是\"+ str(c))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"面经问题总结","slug":"面经问题总结","date":"2018-11-09T14:07:10.000Z","updated":"2018-11-10T08:29:21.916Z","comments":true,"path":"2018/11/09/面经问题总结/","link":"","permalink":"http://yoursite.com/2018/11/09/面经问题总结/","excerpt":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法","text":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法 6 GET/POST 区别与联系 7 防火墙和DNS劫持 8 http 介绍 http请求头、响应头都有哪些字段 9 netstat查看端口相关命令 10 TCP为什么是可靠的，如何进行拥塞控制 11 长连接与短连接 12 介绍一下常见的网络协议 13 http状态码有哪些 14 一个网站进入速度较慢，可以从哪些方面优化 15 web常见的安全问题有哪些、如何预防 16 http协议请求首部介绍一下 http正向代理和反向代理什么意思 17 GET\\POST 区别，form表单默认的请求方法是get、post？能用get完成的请求都能用post完成吗 18 输入一个网址后回车发生的全过程 19 TCP和UDP 区别，哪一个快一些？UDP丢包怎么处理，TCP拥塞控制机制，慢启动的缺点 20 TCP四次挥手的过程，为什么要主动关闭方等到2MSL的时间 21 http 头部字段keep-alive了解过吗？什么时候服务器知道可以断开连接呢？ 22 http 状态码有哪些？ 502、504 状态码是是么？ 23 TCP和UDP 区别、TCP流量控制和拥塞控制、慢启动 24 访问taobao.com的全过程，如何获取每一阶段的耗时 25 ARP协议 ping命令 操作系统1 虚拟内存的作用是什么？分页有什么好处？分段呢 2 同步和异步的区别 3 进程和线程的区别，谁调度的进程 4 死锁的条件，如何检测死锁 5 死锁的必要条件，银行家算法 6 内核态线程和用户态线程的区别 7 非阻塞IO 8 程调度算法有哪些 9 通俗的语言，面对一个非程序员，解释进程与线程的区别 10 多线程中如何保证线程安全，如何创建守护进程 11 死锁是什么，为什么会产生死锁，怎么解决死锁问题，预防死锁、避免死锁 12 进程的同步进制有哪些？ 进程的通信机制有哪些？ 13 进程的状态转换图及转换事件","categories":[],"tags":[{"name":"面试基础","slug":"面试基础","permalink":"http://yoursite.com/tags/面试基础/"}]},{"title":"博客的重新开始","slug":"博客的重新开始","date":"2018-11-09T13:39:42.000Z","updated":"2018-11-10T08:28:58.300Z","comments":true,"path":"2018/11/09/博客的重新开始/","link":"","permalink":"http://yoursite.com/2018/11/09/博客的重新开始/","excerpt":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。","text":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。 目前离最早的实习面试还有四个月左右，我也已经投出第一篇论文，这一段时间要专注的去复习计算机基础知识了。趁着这一段时间去丰富自己的理论知识。感觉目前工程经历和科研经历都不少了，一路走过来奖项也拿了不少了，所欠缺的主要是对于理论知识的理解，另外对于一些较为需求的方向例如爬虫、redis做一个demo项目。加油！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}