{"meta":{"title":"MapleStory","subtitle":null,"description":"CS:Dalian University of technology","author":"Eyc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"数据库系统原理","slug":"数据库系统原理","date":"2018-12-23T07:16:31.000Z","updated":"2018-12-23T07:20:37.636Z","comments":true,"path":"2018/12/23/数据库系统原理/","link":"","permalink":"http://yoursite.com/2018/12/23/数据库系统原理/","excerpt":"[TOC] 数据库系统原理事务事务指满足ACID特性的一组操作，可以通过commit 提交，也可以通过rollback回滚 事务的ACID特性 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部成功提交，要么全部失败回滚,回归可以使用回滚日志来实现，回滚事务记录着执行的修改操作，回滚时反向执行即可 一致性（Consistency） 数据在事务的执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结构都是相同的 隔离性（Isolation） 一个事务所做的修改在最终提交以前对其他事务不可见 持久性（Durability） 一旦事务提交，则其所做修改会永远保存到数据库中，即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性","text":"[TOC] 数据库系统原理事务事务指满足ACID特性的一组操作，可以通过commit 提交，也可以通过rollback回滚 事务的ACID特性 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部成功提交，要么全部失败回滚,回归可以使用回滚日志来实现，回滚事务记录着执行的修改操作，回滚时反向执行即可 一致性（Consistency） 数据在事务的执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结构都是相同的 隔离性（Isolation） 一个事务所做的修改在最终提交以前对其他事务不可见 持久性（Durability） 一旦事务提交，则其所做修改会永远保存到数据库中，即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性 事务的ACID特性比较简单，但是并不容易理解，他们并不平级 只有满足一致性，事务的执行结果才是正确的的 在无并发的情况下，事务串行执行，隔离性一定能满足。此时只要满足原子性，一致性即可满足 并发的情况下，多个事务并行执行，事务不仅满足原子性，还要满足隔离性 才能满足一致性 事务满足持久性是为了维护数据库崩溃的情况 事务的自动提交 AUTO_COMMITMySQL默认采用自动的提交模式，即，如果不显示使用START TRANSACTION来开始一个事务，每个查询都会被当做一个事务自动提交 事务的模型抽象成功完成的事务称为已提交，而非成功完成的事务被中止了，为了确保数据的原子性，中止事务对数据库状态不可以造成影响，因此这些影响必须被撤销。一旦中止事务的影响被撤销，我们称事务已回滚 ，数据库通过日志来支持回滚操作 一个简单事务抽象模型包括： 活动的：初始状态，事务执行时处于这个状态 部分提交的：最后一条语句执行后 失败的：发现正常的执行不能继续后 中止的：事务回滚并恢复到事务开始执行的前后 提交的：成功完成后 事务的隔离性事务处理系统通常允许多个事务并发的执行，并发有两条无法拒绝的理由 提高吞吐量和资源利用率 减少等待时间 数据库中并发的动机和多道程序设计的动机是相同的，而为提升效率的同时，我们必须控制事务的交互，来保证数据库的一致性，这被称为系统的并发控制 在并发执行时，通过保证所执行的任何调度效果都与没有并发效果一样，我们可以保持数据库的一致性。调度在某种意义上等价于一个串行调度，这种调度被称为可串行化调度 事务的并发可串行化串行化顺序可以通过拓扑排序得到。 对于优先图来说，读写、写读、写写被称为一条边，考察这个有向图中是否有环，无环的优先图被称为可串行化调度 并发一致性问题在并发环境下，事务的隔离性很难保证，因此可能出现并发一致性问题 问题 原因 图例 丢失修改 T1和T2 两个事务都对一个事务进行修改，T1先修改T2随后修改，T2的修改覆盖了T1的修改 读脏数据 T1修改了一个数据，T2最后读取了这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据 不可重复读 T2读取了一个数据，T1对其进行了修改，如果T2再次读取这个数据，此时读取结果和第一次不同 幻影读 T1读取某个范围内的数据，T2 在这个范围内插入新的数据，T1再次读取这个范围内的数据，此时读取的结果和第一次读取的不同 事务的隔离级别 隔离级别 简介 可串行化 即可串行化调度 可重复读 只允许读取已提交数据，事务两次读取的间隙其他事务不得更新 已提交读 只允许读取已提交的数据，允许同一事务读数据的前后不一致 未提交读 允许读取未提交数据 事务的隔离级别与对应的并发问题 隔离级别/并发问题 脏读 不可重复读 幻影读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行化 × × × √ 隔离级别的实现锁通过封锁来实保证事务的可串行化。通过共享、排他锁及两阶段封锁协议来保证串行化下的并发读 时间戳另一类用来实现隔离性的技术为为每一个事务分配一个时间戳，系统维护两个时间戳来保证冲突情况下按照顺序访问数据项 多版本和快照隔离快照隔离中，我们可以想象每个事务开始时尤其自身的数据库版本或快照，它从这个私有的版本中读取数据，因此它和其他事务的更新隔开。事务的更新只在私有数据库中进行，只有提交时才将信息保存，写入数据库。 并发控制读写锁锁一般被分为两种 共享锁：简称为S锁，又称为读锁 排他锁：简称为X锁，又称为写锁 这两种锁有以下规定 一个事务数据对象加了X锁，就可以对数据A进行读取和更新，加锁期间其他事务不能获得A的锁 一个事务数据对象加了S锁，可以对A进行读取操作，加锁期间其他事务可以对其加S锁，但是不能加X锁 意向锁使用意向锁来支持多粒度的封锁 在行级锁、表级锁的情况下，事务想要对表A加X锁，就要检测其他事务是否对表A和表A的任意一行加了锁，那么就需要对A的每一行都检测，这非常耗时 在X/S锁之外引入了IX、IS，IX和IS都是表锁，用来表示一个事务想在某个表上加X或S锁，有以下规定： 一个事务在获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁 一个数据在获得某个数据航的X锁之前，必须获得表的IX锁 通过引入意向锁，输入想要对某个表A加锁，只需检测事务是否对表A加了x/Ix/S/IS锁 - X IX S IS X × × × × IX × √ × √ S × × √ √ IS × √ √ √ 任意IX/IS 之间都是相容的，因为它只表示要加锁，并没有真正的加锁 S锁只与S和IS兼容 两阶段封锁协议保证事务可串行化的一个协议是两阶段封锁协议，该协议分两个阶段 增长阶段：事务可以获得锁，但是不能释放锁 缩减阶段：事务可以释放锁，但是不能获得新锁","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"操作系统之文件","slug":"操作系统之文件","date":"2018-12-07T13:25:21.000Z","updated":"2018-12-07T13:28:35.964Z","comments":true,"path":"2018/12/07/操作系统之文件/","link":"","permalink":"http://yoursite.com/2018/12/07/操作系统之文件/","excerpt":"[TOC] 内存部分虚拟内存虚拟内存的概念内存管理中进程有如下特征： 一次性：作业必须一次性全部装入内存后才能开始运行 驻留性：作业被装入内存后驻留在内存中，任何部分都不会被唤出直至作业结束 局部性原理 高速缓存是计算机科学中唯一重要的思想。事实上告诉缓存技术极大的影响了计算机系统的设计 -- Bill Joy「SUN 公司 CEO」 时间局部性： 如果程序某条指令一旦执行，不久之后可能会再次被执行；如果某个数据被访问过，不久以后它可能再次被访问 空间局部性：一旦程序访问某个储存单元，不久之后其附近的单元也将被访问。","text":"[TOC] 内存部分虚拟内存虚拟内存的概念内存管理中进程有如下特征： 一次性：作业必须一次性全部装入内存后才能开始运行 驻留性：作业被装入内存后驻留在内存中，任何部分都不会被唤出直至作业结束 局部性原理 高速缓存是计算机科学中唯一重要的思想。事实上告诉缓存技术极大的影响了计算机系统的设计 -- Bill Joy「SUN 公司 CEO」 时间局部性： 如果程序某条指令一旦执行，不久之后可能会再次被执行；如果某个数据被访问过，不久以后它可能再次被访问 空间局部性：一旦程序访问某个储存单元，不久之后其附近的单元也将被访问。 基于局部性原理，程序装入内存时，可以先装入一部分内存，其余部分留在外存。在程序运行过程中，当访问信息不存在时，操作系统将需要信息调入内存；另一方面操作系统将暂时不适用的内容放到外存之中。这样系统好像为用户提供了一个大的多的储存器，称为虚拟储存器 之所以称为虚拟储存器，是因为这种储存器并不存在，只是由于系统提供了部分装入请求和置换功能后，给用户感觉是一个比实际物理内存大的多的存储器。 页面置换算法最佳置换算法「OPT」最佳置换算法选择被淘汰页面是以后用不使用的，或者在最长时间未被访问的页面，这样可以保证最低的缺页率。 该算法是理想算法 ，「无法实现」 先进先出算法「FIFO」优先淘汰最早进入内存的页面，亦即在内存中驻留最久的页面。 算法实现较简单，但是可能出现页故障数随物理块数增大不降反增的状况「Belady」异常 最近最久未使用算法「LRU」选择最近最长时间未访问过的页面予以淘汰，他认为最近一段时间未访问的页面在将来一段时间也不会被访问。 时钟置换算法「CLOCK」「NRU」某次装入内存时，其使用位被置位 1 ，当再次被访问到时，其再被置为 1 当需要替换页时，从缓冲区头部开始扫描，遇到 1 置 0 ；遇到 0 就选择该页置换；依次循环 改进 CLOCK 算法 将使用位再细分为 访问与修改两种状态，修改优先级大于访问 文件部分磁盘的结构磁盘由表面涂有磁性物质的金属或塑料构成圆形盘片，通过一个名为磁头的导线圈从磁盘中读取数据。在读写操作期间， 磁头固定，磁片高速旋转。 磁盘调度算法先来先服务 「FCFS」FCFS根据请求磁盘的先后顺序调度，该算法较为简单 最短寻道时间优先「SSTF」优先调度当前磁头所在磁道最近的磁道 平均寻道时间较低，但是较为不公平。如果新的磁道总是比一个等待的磁道近，等待的磁道会一直等待下去出现饥饿现象 电梯算法当前移动方向上选择当前磁头最近请求作为下一次服务方向。即总是面向一个方向运行，直到该方向没有请求位置，改变运行方向。 程序编译与链接编译系统以下是一个 hello.c 程序 123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello, world\\n\"); return 0;&#125; 在 unix 上, 编译器把源文件转换为目标文件 gcc -o hello hello.c 预处理阶段：预处理以 # 开头的预处理命令 编译阶段：翻译成汇编文件 汇编阶段：将汇编文件翻译成可重定向的目标文件 连接阶段：将可重定向目标文件和 printf.o 等单独编译好的文件进行合并，得到可执行的目标文件 静态链接静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件为输出，链接器主要完成以下任务： 符号解析：每个符号对应一个函数，一个全局变量或静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来 重定位：链接器通过吧每个符号定义与一个内存位置关联起来，修改对这些符号的引用，使他们指向这个内存位置 目标文件 可执行目标文件：直接在内存中执行 可重定向目标文件：可以其他重定向文件在链接阶段合并，传建一个可执行目标文件 共享目标文件：特殊的可重定向文件，在运行时被动态加载进内存并链接 动态链接静态库有以下两个问题： 当静态库更新时，整个程序重新链接 对于 printf 这种标准库函数，每个程序都要都代码，极大浪费资源 共享库是为了解决静态库的问题而设计的，在linux中用.so文件来表示，windows 中被称为dll 它们具有以下特点 在给定的文件系统中一个库只有一个文件，所有引用库的可执行目标都共享这个文件，他不会被复制到他的可执行文件中 内存中共享的副本可以被不同正在运行的进程共享","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"数据库之SQL","slug":"数据库之SQL","date":"2018-12-07T13:14:07.000Z","updated":"2018-12-07T13:22:21.186Z","comments":true,"path":"2018/12/07/数据库之SQL/","link":"","permalink":"http://yoursite.com/2018/12/07/数据库之SQL/","excerpt":"[TOC] SQL初级SQL概览SQL最早版本是由IBM开发的，最初被叫做Sequel。其发展至今被称为SQL（结构化查询语言），最新的SQL标准是SQL：2008 SQL语言有以下部分： 数据定义语言（DDL） 数据操纵语言（DML） 完整性 保存在数据库中的数据必须满足完整性约束 视图定义 事务控制 嵌入SQL和动态SQL 授权","text":"[TOC] SQL初级SQL概览SQL最早版本是由IBM开发的，最初被叫做Sequel。其发展至今被称为SQL（结构化查询语言），最新的SQL标准是SQL：2008 SQL语言有以下部分： 数据定义语言（DDL） 数据操纵语言（DML） 完整性 保存在数据库中的数据必须满足完整性约束 视图定义 事务控制 嵌入SQL和动态SQL 授权 SQL数据定义基本类型 char(n) 固定长度字符串，用户指定长度。如果字符长度不到n，在字符串后面补空格使其至n个字符串长度 varchar(n) 变长字符串 int 整数类型 smallint 小整数类型 numeric(p,d) 定点数，精度有用户指定 float(n) 精度至少为n的浮点数 基本模式12345create table department(dept_name varchar(20),building varchar(15),budget numeric(12,2),primary key(dept_name)); 这里简单讨论几个完整性约束 primary key (A1,A2…Am) primary key 声明属性构成关系主码，主码必须非空且唯一。 foreign key(A1,A2…Am) reference : × foreign key 表示声明关系中的任意元组必须在对应的外键属性上取值 not null 非空 SQL禁止破坏完整性约束的任何数据库更新，例如主码上的空值和重复将会被SQL标记错误并阻止更新 插入、删除和修改 的基本模式： 12345678910111213# 删除模式,（保留关系，只删满足条件的数据）delete from student# 删除模式，（表结构整体删除）drop table r# 修改表结构# 表增加一列alter table r add A D# 表删除一列alter table r drop A# 修改某一列属性（不改名）alter table r modify A D &lt;Y&gt;# 修改某一列属性 （改名）alter table r change A1 A2 D &lt;Y&gt; SQL查询基本结构SQL的基本查询结构由三个基本的子句组成：select from where 我们对其进行一个总结 select 子句用于列出查询结果中需要的属性 from 子句是一个查询求值中需要访问的关系列表 where 子句一个作用在from关系中的谓词 其基本的查询有如下形式 123select A1,A2,...,Anfrom r1,r2,...,rmwhere P 为了较好的理解这个关系的顺序是 from –&gt; where –&gt; select 首先通过from子句定义了一个在子句中列出关系的笛卡尔积，一般来说这个结果可能是一个相当大的关系，这样的笛卡尔积一般是没有意义的。而where子句谓词用来限制from子句所建立的集合，只留下对答案有意义的集合，最后我们可以用select限制结果中需要的子集 自然连接组合信息是一种通用的过程，SQL支持一种被称为自然连接的运算。自然连接运算作用于两个关系，并产生一个关系作为结果。不同于两个关系上的笛卡尔积将第一个关系的每个元组与第二个关系的所有元组都进行连接；自然连接只考虑两个关系模式中都出现且属性相同的元素对。 123select A1,A2,...An from r1 join r2, ... join rnwhere P; 附加基本运算更名运算字符串运算字符串可以使用like来实现模式匹配 % 匹配任意子串 _ 匹配任意一个字符 排序运算where子句谓词集合运算SQL在关系上的union、intersect 、except 分别对应了∪、∩ 及 - 聚集函数基本聚集分组聚集有时候我们不仅希望聚集函数作用力在单个元组集上，也希望作用到一组元组集合上，可以采用group by子句 并利用 having子句限定元组的条件 嵌套查询数据库修改删除12delete from rwhere P; 插入 12insert into rvalues (A1,A2,...) 更新12update instructor set salary = salary * 1.05; 小节SQL 语言分为数据定义语言（DDL）和数据操纵语言（DML） DDL： 定义关系模式、删除、修改关系模式 create alter drop DML: 包括查询语言、插入、修改、删除元组的命令 select insert delete update 连接表达式参与连接的任何一个或两个关系中的某些元组可能会以某种方式丢失，外链接以创建包含空值元组的方式保留了在连接中丢失的元组。 一般的，外链接有三种类型： 左外连接： 只保留出现在左外连接运算之前（左边）关系中的元组 右外连接：只保留出现在右外连接之后（后边）关系中的元组 全外连接：保留出现在两个关系中的元组 事务事务 由查询和更新语句的序列组成，SQL标准规定当一条SQL语句被执行，就隐式的开始了一个事务，下列SQL之一会结束一个事务 Commit work: 提交当前事务，将该事务所做功能新在数据库中持久保存。事务被提交后，一个新的事务自动刚开始 Rollback work：回滚当前事务，即撤销事务中所有的SQL语句对数据库的更新。这样数据库就恢复到执行事务第一条语句前的状态 当系统检测到错误时，事务回滚是有用的。而事务提交就像存盘，一旦commit他的影响就不能用rollback来撤销。数据库保证在发生SQL语句错误、断电、系统崩溃这样的故障情况下，如果事务没有完成commit，其影响将被回滚。如果断电和系统崩溃，回滚会在重启后进行。 一个事务在完成所有步骤后的提交行为，或者在不完成所有动作情况下回滚其动作，这种方式数据库提供了了对事务的 原子性 抽象，原子性也就是不可分割性，事务的影响被反映到数据库中，或是任何影响都没有。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"操作系统之进程","slug":"操作系统之进程","date":"2018-12-07T13:11:54.000Z","updated":"2018-12-07T13:22:35.897Z","comments":true,"path":"2018/12/07/操作系统之进程/","link":"","permalink":"http://yoursite.com/2018/12/07/操作系统之进程/","excerpt":"[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。 进程具有动态性（有着创建、活动、暂停、终止等过程，具有生命周期）、并发性（多个进程在一段时间内同时运行）、独立性（进程是一个独立运行、获得资源和接收调度的基本单位）、异步性（进程按照独自的、不可预知的速度前进）、结构性（每个进程都有一个PCB对其描述）","text":"[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。 进程具有动态性（有着创建、活动、暂停、终止等过程，具有生命周期）、并发性（多个进程在一段时间内同时运行）、独立性（进程是一个独立运行、获得资源和接收调度的基本单位）、异步性（进程按照独自的、不可预知的速度前进）、结构性（每个进程都有一个PCB对其描述） 进程的状态 运行状态：进程在处理机上运行 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机以外的一切所需资源，只需得到处理机即可执行 阻塞状态（等待/封锁状态）：进程正在等待某一事件而暂停运行。特点是即使处理机空闲也不能运行 创建状态：进程正在创建尚未转到就绪状态。创建进程通常需要经过几个步骤：申请空白PCB、向PCB写入控制和管理进程的信息，然后为该进程分配运行时所必须的资源，最后将其转入就绪状态 结束状态：进程从系统中消失，这可能是因为正常结束或其他原因中断退出。当进程结束运行时，系统首先置该进程为结束状态，进一步处理资源释放和回收等工作。 进程控制 进程控制是指对系统中的进程实施有效管理。一般把控制进程的程序段称为原语，原语的特点是执行期间不允许中断，它是不可分割的单位。 进程的创建引起进程创建的事件1. 用户登录：分时系统中，每一个用户登录都可以被看做是一个新的进程。系统为该终端建立一个进程并插入就绪队列 2. 作业调度：批处理系统中，当系统按照一定算法调度到某作业时，便将该作业调入内存并为其分配资源，创建进程，插入就绪队列 3. 提供服务：运行中的用户提出某种请求后，系统为其创建一个进程来提供用户需要服务 4. 应用请求；前三种是系统创建进程，而用户基于自己的需求可以创建新进程，以便用户并发的完成特定任务。 进程的创建过程 进程创建原语create 1. 为进程申请一个唯一的进程识别号与一个空白的PCB 2. 为进程分配资源，为新进程的程序和数据、用户栈分配内存空间 3. 初始化PCB，主要包括初始化标志信息，状态信息及处理机控制信息 4. 如果就绪队列能够接纳新进程，插入就绪队列等待被调度运行 进程的终止引起进程终止的事件1. 正常结束 2. 异常结束：出现某种错误或故障导致程序无法进行，如：越界错误、非法指令、运行超时、等待超时、IO故障 3. 外界干预：进程应外界请求而终止 进程的终止过程 进程终止原语destroy 1. 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，并读取进程状态 2. 若进程处于执行状态，立即终止该进程，并置调度标志为真 3. 若进程还有子孙进程，将其所有子孙进程终止，以防其不可控 4. 将终止进程的所有资源释放给系统或父进程 5. 将被终止进程移出所在队列 进程的阻塞与唤醒进程的阻塞 阻塞原语block 正在执行的进程，由于期待某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达，系统自动执行阻塞原语(block)，是自己由运动态转为阻塞态，可见阻塞是一种主动现象 阻塞过程 1. 找到要阻塞的标识号对应的PCB 2. 若进程为运行态，则保护现场，将其运行状态转为阻塞，停止运行 3. 将PCB插入相应的时间等待队列中去 进程的唤醒 唤醒原语wakeup 当被阻塞的进程所期待的出现时，如它启动的I/O操作所期待的数据已到达，则有关进程调用唤醒原语（wakeup）将该进程唤醒 唤醒过程 1. 在事件的等待队列中找到进程的PCB 2. 将其从等待序列中移除，并置为就绪状态 3. PCB插入就绪队列，等待进程调度 进程的挂起与激活进程的挂起挂起原语：suspend() 当出现了进程挂起事件时，比如用户请求挂起自己的进程，或父进程挂起子进程。 进程的激活激活原语：active() 当激活的事件发生时，例如父进程或用户进程请求激活子进程，若进程驻留在外存而内存有足够的空间时，将外存的进程换入内存 进程通信进程间通信主要包括三种：共享储存、消息传递、管道通信 共享储存在通信的进程之间存在一块可以直接访问的共享空间（内存），这块内存由一个进程创建但是多个进程都可以访问。共享内存是最快的IPC方式，它是专门针对其他通信方式的低效而设计的。与其他通信机制配合（如信号量）来实现进程的同步和通信 消息传递消息以格式化的形式为单位，通过一个缓冲队列发送至另一个进程。该缓冲队列可能由操作系统提供。 管道通信管道是进程通信的一种特殊方式，指连接一个读进程和一个写进程实现他们通信的共享文件。为了协调双方通信，管道机制必须提供以下协调能力：互斥、同步、确定对方存在。 linux中管道是一种频繁使用的机制，本质上管道是一种文件，克服通信上的两个问题： 当写进程较快，限制管道大小，linux中该管道大小为4KB，这样缓存大小不会无限制增长。当管道满时，管道对write的调用被阻塞 当读进程较快，管道空后，read操作被阻塞 管道是半双工的，同一时刻只能单向传输。管道可以作为一共享储存的一个优化，利用缓冲区实现了读写的同步。 线程线程的概念与特征引入线程的目的是为了更好的使多道程序并发执行，以提高资源利用率与吞吐量，减小程序并发执行付出的时空开销，提高操作系统的并发性能。 线程是“轻量级进程”，是一个基本的CPU执行单元。由线程ID、程序计数器、寄存器和堆栈组成。线程是进程中的一个实体，是被系统调度和分派的独立单位。线程不拥有系统资源，线程只有就绪、阻塞、运行三种状态 引入线程后，进程只作为除CPU外系统资源的分配单元，线程则作为CPU的分配单元。这样同一进程内线程的切换开销很小。 线程的属性多线程的操作系统中，线程作为独立运行的基本单位，进程的执行实际上是进程的某个线程在执行 线程是一个轻型实体，不拥有系统资源，每个线程有唯一的标识符和线程控制块。 不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统建成不同的线程 同一进程各个线程共享进程拥有的资源 线程是处理机调度的独立单位，多个线程可以并发执行。在单CPU计算机中线程交替的占用CPU，多CPU中线程可以同时的占有不同的CPU 线程的实现线程分为两类：用户级线程 和 内核级线程 用户级线程中，线程的管理工作由应用程序完成，内核意识不到线程的存在。 内核级线程中，线程的管理工作由内核完成，引用程序没有进行线程管理的代码，只有一个内核级线程的编程接口，线程的调度也是在内核线程的基础上完成的。 还有组合式的方式 进程与线程的比较调度引入线程的操作系统中，线程是调度和分派的基本单位。在同一个进程的中，线程的切换不会引起进程的切换。 拥有资源进程是拥有除CPU外其他资源的基本单位，程序运行所需要的必要资源（程序、PCB、堆栈）都由进程所有。一般而言线程不占有系统资源（除了一些必不可少的资源），其访问隶属于进程的资源 并发性进程之间可以并行运行，同一进程的线程间也可以并发运行 创建和开销进程的创建和撤销，系统都要为之创建、回收PCB，分配和回收资源。操作系统付出的代价比较大。而线程的创建和撤销比较简单。 进程调度调度层次作业调度高级调度，主要任务是按一定原则从外存中将处于后备状态的作业挑选1个或几个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度） 中级调度进程的挂起与就绪 进程调度低级调度，某种方法和策略从就绪队列中选取一个进程，为其分配处理机。进程调度是最基本的调度，频率很高，一般几十毫秒一次 调度算法先来先服务（FCFS）算法FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度 FCFS是不可剥夺算法，长作业会使后到的短作业长期等待。 特点：算法简单，效率低，对长作业有利，有利于CPU繁忙性作业 短作业优先（SJF）算法从后背队列中选择一个或若干个估计运行时间最短的作业调入内存运行 特点：对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态。 优先级调度算法优先级调度算法每次从后背队列中选取优先级最高的一个或几个作业 特点：优先级调度可以剥夺式占有，也可以非剥夺式占有 高响应比优先高响应比有限主要用于作业调度，该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比。 响应比的计算为（等待时间+要求服务时间）/ 要求服务时间 时间片轮转调度算法时间片轮转算法适用于分时系统，系统将所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms。 特点：受系统响应时间影响、队列进程数目、进程长短影响较大 多级反馈队列调度算法多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展 1） 设置多个就绪队列，为各个队列赋予优先级，1、2、3等等 2） 赋予各个队列中时间片大小不同，优先级高时间片越小 3） 一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行 4） 仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推。 进程同步临界区虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源。 // entry // critical section // exit section 同步与互斥同步：进程之间具有直接制约关系，进程之间需要按照一定的次序进行 互斥：进程之间的间接制约关系，不能同时访问临界区 信号量信号量是一个整形变量，可以被定义为两个标准的原语wait(S) signal(S) 即P、V操作 P操作 如果信号量大于0，执行 -1操作，如果等于0，执行等待信号量大于0 V操作 对信号量完成加1操作，唤醒睡眠的进程 123456789101112typedef int semaphoresemaphore mutex = 1 void P1()&#123; P(&amp;mutex); //临界区 V(&amp;mutex);&#125;void P2()&#123; P(&amp;mutex); //临界区 V(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品 由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问 为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区 12345678910111213141516171819202122232425262728# define N 100typedef int semahporesemaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer()&#123; while(True)&#123; int item = produceItem(); P(&amp;empty); P(&amp;mutex); Item.push(item); V(&amp;mutex); V(&amp;full); &#125;&#125;void consumer()&#123; while(True)&#123; P(&amp;full); P(&amp;mutex); int item = Item.top(); Item.pop(); consume(item); V(mutex); V(&amp;empty()) &#125;&#125; 管程使用信号量机制生产消费问题客户端代码需要很多控制，管程作用是把控制的代码独立出来。 管程有一个重要作用：一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用 管程的生产者消费者实现 12345678910111213141516171819202122232425262728293031323334353637383940monitor ProducerConsumer condition full, empty; integer cout :=0; function insert(item:integer); begin if count = N then wait(full) insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remote(item:integer); begin if count = 0 then wait(empty); item = remove_item(item); count := conut-1; if count = N-1 then signal(full); return item; end;end monitor;//生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item) endend;procedure consumerbegin while true do begin item = ProducerConsumer.remove() consume(item); endend; 读者-写者问题问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行 用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁 12345678910111213141516171819202122typedef int semaphoresemaphore count = 0;semaphore read_mutex = 1;semaphore write_mutex = 1;void read()&#123; P(&amp;read_mutex); count++; if(count==1) P(&amp;write_mutex); V(&amp;read_mutex); read(); p(&amp;read_mutex); count--; if(count==0) V(&amp;write_mutex); V(&amp;read_mutex);&#125;void write()&#123; P(&amp;write); write(); V(&amp;write);&#125; 哲学家进餐问题问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根 如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待 1234567891011121314151617181920212223242526typedef int semaphoresemaphore chop[5] = &#123;1,1,1,1,1&#125;;semaphore mutex = 1;void process()&#123; while(true)&#123; P(&amp;mutex); /* if(chop[i]&amp;&amp;chop[(i+1)%5]) &#123; P(chop[i]); P(chop[(i+1)%5]); &#125; else&#123; V(&amp;mutex); break; &#125; */ P(chop[i]); P(chop[(i+1)%5]); V(&amp;mutex); eat(); V(chop[i]); V(chop[(i+1)%5]); &#125;&#125; 死锁死锁的定义：多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。 死锁四个必要条件： 互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。 不剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放 请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。 循环等待条件：存在某一进程的循环等待链，链中每个进程已获得资源下个进程的请求。 死锁的处理策略死锁的处理便是破坏四个必要条件，使得死锁无法发生 鸵鸟策略把头埋在沙子里，假装问题没有发生 由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能。 大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略 死锁预防 破坏互斥条件 对于可共享的资源竞争，不会发生死锁 破坏不剥夺状态 当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要是再重新申请 破坏请求 和 保持条件 预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归期所有。 破坏循环等待 资源顺序分配法，例如为资源编号，每个进程申请分配某个资源以后，再之后只能申请该编号以后的资源 死锁避免系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1、P2,,)称为安全序列。如果无法找到安全序列，则系统处于不安全状态。 允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则，进程等待 银行家算法 银行家算法是最著名的死锁避免算法。它的思想是，把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款。 进程申请资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源 死锁检测和接触死锁检测死锁解除 资源剥夺法 挂起死锁进程，抢占其资源分配给其他进程 撤销进程法 强制撤销一些死锁进程 进程回退法 借助历史信息使一个或多个进程回退到系统不再死锁的地步","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"欢迎来到Eyc的博客！","slug":"欢迎来到Eyc的博客!","date":"2018-11-11T12:06:38.000Z","updated":"2018-12-07T02:04:45.894Z","comments":true,"path":"2018/11/11/欢迎来到Eyc的博客!/","link":"","permalink":"http://yoursite.com/2018/11/11/欢迎来到Eyc的博客!/","excerpt":"","text":"欢迎来到我的博客！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"HTTP","slug":"HTTP","date":"2018-11-11T11:54:23.000Z","updated":"2018-12-07T13:08:58.983Z","comments":true,"path":"2018/11/11/HTTP/","link":"","permalink":"http://yoursite.com/2018/11/11/HTTP/","excerpt":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击）","text":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击） GET与POST的区别作用GET用于获取资源，POST用于传输实体主体 参数GET和POST都能使用额外的参数，但是GET参数以查询字符串的形式出现在URL中，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin 这个过程用户可见。而POST的参数存储在实体主体中。通过HTTP的POST机制。POST参数可以通过一些抓包工具（Fiddler）查看 因为URL只支持ASCLL码，因此GET参数中文会被编码，空格被编码为%20 安全安全的HTTP方法不会改变服务器状态，可以说他是只读的 GET方法安全的，POST不是，POST方法传输主体内容，这个内容可能是某个表单数据，服务器可能把其存入数据库中，这样状态就发生了改变 幂等性幂等性的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。 所有安全的方法是幂等的，GET、HEAD、PUT、DELETE方法都是幂等的 而POST方法不是幂等的 XMLHTTPRequestXMLHTTP Request是一个API，它为客户端和服务器之间传输数据的功能。他提供了一个URL来获取数据的简单方式，而且不会使整个页面刷新。这使得网页只更新一部分不会打扰到用户，在AJAX中被大量使用 在xmlhttprequest中POST会先发送header再发送data（当然也和浏览器的做法相关） 而get方法会一起发送 其他Get传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递 Get方式只支持ASCII字符，向服务器传输的中文字符可能会乱码。POST支持标准字符集，可以正确的传递中文字符 HTTP 首部 Request Header 解释 某度首页示例 Accept 客户端能够接受的内容类型 text/html Accept-Encoding 浏览器可以支持的web服务器返回内容压缩编码类型 gzip Accept-Language 浏览器可以接受的语言 zh-CN Cache-Control 指定请求和相应遵循的缓存机制 max-age=0 Connection 表示是否需要持久连接 keep-alive Cookie HTTP请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器 键值对 Host 请求服务器的域名和端口号 www.baidu.com Upgrade-Insecure-Requests 浏览器可以处理HTTPS协议 1 User-Agent 发出请求的用户信息 Mozilla/5.0 HTTP 首部 Response Header 解释 某度首页示例 Cache-Control 告诉所有的缓存机制是否可以缓存及缓存哪种类型 private Connection 是否保持持久连接 keep-alive Content-Encoding 返回内容压缩编码类型 gzip Content-type 返回内容的MIME类型 text/html charset=utf-8 Date 原始服务器消息发出时间 Wed 03 Oct2018 12:04:45 GMT Expires 响应过期的时间 Wed 03 Oct2018 12:04:45 GMT Server Web服务器软件名称 BWS1.1 Set-Cookie 设置浏览器缓存 BDSVRTM=114; path=/ Transfer-Encoding 文件传输编码 chunked HTTP状态码HTTP中状态码大致分为五大类： 100-199 信息性状态码 100 continue： 收到了请求的初始部分，请客户端继续 200-299 成功状态码 200 OK：请求被正常处理 204 No Content: 请求被接受，但是响应报文只有首部和状态行，没有实体部分 206 Partial Content: 客户端只请求了一部分的资源，服务器只针对请求的部分资源进行返回 300-399 重定向状态码 301 Moved Permanently: 永久重定向 302 Found: 临时重定向，资源被临时移动了 303 See Other: 表示用户请求的资源代表着另一个URI，应该使用GET去获取资源 304 Not Modified: 当客户端发送的请求附带条件时，服务器找到资源但未符合请求 307 Temporary Redirect: 同302，临时重定向 400-499 客户端错误状态码 400 Bad Request: 告知客户端它发送了一个错误的请求 401 Unauthorized: 请求需进行认证 403 Forbidden: 请求被服务器拒绝了 404 Not Found：服务器无法找到对应资源 405 Method Not Allowed：请求中带有不支持的方法 500-599 服务器错误状态码 500 Internet Server Error: 服务器内部错误 502 Bad GateWay： 代理或网关服务器从下一条链路收到了伪响应 503 Server Unavailable: 服务器正忙 504 GateWay Timeout: 一个代理网关等待另一服务器时超时了 持续性连接和非持续性连接1. 定义非持续连接：每个请求、相应都经一个而单独的TCP连接发送 持续连接：所有的请求相应通过相同的TCP连接发送 2. 区别如果采用非持续连接，打开包含一个HTML文件和10个内联对象网页，HTTP需要建立11次TCP连接才能把文件从服务器传到客户机。而如果采用持续连接，HTTP建立一次TCP就把文件从服务器传到客户机 每次TCP连接必需建立和断开（通过三次握手建立、四次挥手断开），这都需要占用CPU资源，这样占用客户机和服务器的CPU时间大大减少 每次连接，客户端和服务器都必须分配发送和接收缓存，这意味着影响服务器和客户机的资源，着同样要占用CPU时间 对于大量对象组成的文件，TCP低速启动算法会限制服务机向客户机传送对象的速度。使用HTTP/1.1后，大多数对象以最大速率传输 3. HTTP/1.0 + keep-aliveHTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live connection:keep-live 是HTTP1.0 浏览器和服务器的实验性扩展 Cookie 与 Session由于HTTP是无状态协议，为了保持客户端与服务器的一些关系，便有了cookie和session 1.cookiecookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。网络服务器用HTTP头想客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。 内容 过期时间会话cookie：若不设置过期时间，则表示这个cookie的生命周期为浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie 持久cookie：若设置了过期时间，浏览器会把cookie存储到硬盘上（当然用户可以选择拒绝），关闭后再打开这些cookie仍然有效 2.sessionsession机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息 当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。 session_id的储存 保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session 由于cookie可以被认为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符 另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id 3. cookie与session的区别存取方式不同cookie只能保存ASCII字符，Unicode及二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较为艰难。而session中能够存取任何类型的数据，包括不限于string、integer、list、map，而且可以直接存取java的类对象，十分方便 隐私策略不同cookie存储在客户端阅读器中，对客户端可见，客户端可以窥探甚至是修改cookie内容。而session存储在服务器上对用户透明，不存在泄露风险。cookie可以像google及baidu一样将敏感信息加密后保存，在服务器上进行解密。 有效时间不同由于session依赖于session_id的cookie，而session_id过期时间默许为-1，关闭浏览器即消失。而cookie可以设置长期的保存 服务器压力不同由于不同的储存方式，储存在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大 浏览器支持不同cookie是需要客户端浏览器支持的，假如客户端禁用了cookie或者不支持cookie，则会话跟踪会失效。 假如客户端不支持cookie，就需要运用session及url地址重写。需要注意的是一切用到session的程序url都需要进行重写，否则session会话还是会失效 跨域支持不同cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用 session仅在当前域名有效 其他一个web页面的请求过程1.DHCP配置主机信息（找本机IP） 主机生成一个DHCP请求报文，并将这个报文放入目的端口67和源端口68的UDP报文段中 该报文段放在一个广播IP地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中 该数据报被放在MAC帧中，目的地址FF:FF:FF:FF:FF:FF，广播到交换机连接的所有设备 交换机的DHCP服务器收到广播帧后，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括 IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码，再经过层层封装到MAC帧中 该帧的目的地址是主机的mac地址，主机收到该帧后分解得DHCP报文，之后配置IP地址，子网掩码、DNS服务器IP地址，安装默认网关 2.ARP解析网关MAC地址（找网关MAC地址） 主机通过浏览器生成一个TCP套接字，为了发送HTTP请求，需要知道网站对应的IP地址 生成一个DNS查询报文，端口53（DNS服务器） DNS查询报文放入目的地址为DNS服务器IP地址的IP数据报中 IP数据报放入一个以太网帧中，发送至网关路由器 DHCP过程只知道网关的IP地址，为了获取网关的MAC地址，需要用ARP协议 主机生成一个目的地址为网关路由器IP的ARP查询报文，放入一个广播帧中，并发送这个以太网帧，交换机将其发送给所有的连接设备 网关接收到该帧后，分解得到ARP报文，发现IP地址与自己想匹配，发送一个ACK报文回应自己的MAC地址 3.DNS解析域名（找服务器IP） 知道了DNS的MAC地址后就可以继续DNS解析过程 网关接收到DNS查询报文后，抽出IP数据报，并根据该表选择该转发的路由器 路由器根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项 之前的DNS报文到DNS服务器后，照常依次抽出报文，在DNS库中查找解析域名 找到DNS记录后发送DNS回答报文，然后将其放入UDP报文段、IP数据报，通过路由器反转发回网关路由器，经过交换机到主机 4. HTTP请求页面 有了HTTP服务器的IP地址后，主机便可以生成TCP套接字，向web服务器发送HTTP get报文 建立HTTP连接前需要进行TCP连接，进行三次握手，过程略 建立连接后发送HTTP的GET报文，交付给HTTP服务器 HTTP服务器从TCP中读出报文，生成HTTP相应报文，将web页面放入HTTP报文主体中发挥主机 浏览器收到HTTP相应报文后抽取WEB页面内容进行渲染，显示web页面","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"TCP与UDP","slug":"TCP与UDP","date":"2018-11-11T11:49:28.000Z","updated":"2018-12-07T13:09:24.376Z","comments":true,"path":"2018/11/11/TCP与UDP/","link":"","permalink":"http://yoursite.com/2018/11/11/TCP与UDP/","excerpt":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制","text":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制 TCP三次握手 第一步：客户机的TCP首先向服务器的TCP发送一个请求连接报文段。这个特殊的报文段不包含应用层数据，其中首部的SYN标志位被置位1.另外客户机会随机选择一个起始序号seq=x 第二步：服务器的TCP收到请求的报文后，如同意建立连接，就向客户机发回确认，并为该TCP分配TCP缓存和变量。在确认报文段中，SYN和ACK被置为1，确认号的字段值为x+1 第三步：客户机收到确认报文段后向服务器给出确认，并且给该连接分配内存和变量，ACK置1，确认号为y+1 为什么TCP进行三次握手？本质上TCP协议的三次握手需要解决这样一个问题：在不可靠的信道上（IP数据报尽最大努力交付）完成可靠的数据传输。而全双工的连接建立需要双方的连接请求和确认，这样最少需要使用三次握手才能建立连接 至于为什么三次是最少，客户端服务器二者最少都需要向对方发送一个同步报文（SYN），但是如果只有这两次握手，服务器就只能接受连接，无法确认连接；设想如果服务器接受一个SYN报文就建立连接，那客户端因为阻塞原因重发了N个SYN同步报文 ，服务器每接受到一个就需要建立一次连接，这是不堪设想的。所以只有当服务器接收到客户端第二次的ack确认报文后才会建立连接 TCP四次挥手断开连接 客户端请求断开FIN1（客户端无更多数据） 服务器ACK确认（收到，但是仍有数据传输） 服务器请求断开FIN2（服务器无更多数据） 客户端ACK确认 四次挥手中的状态 FINWAIT1 : 当客户端在established状态想要断开连接，主动向服务器器发送FIN报文，此时该socket便进入FINWAIT1状态 FINWAIT2: 这时客户端已经收到对方的确认ack,但是服务器可能还有数据未发送完成，还需要接受对方的数据，处于半连接（半关闭）状态 TIME_WAIT: 客户端接受到了对方的确认报文、也接收到了对方的fin报文，现在发出了最后的确认报文，进入一个2MSL的等待状态，如果等待状态没有重发便进入结束状态 CLOSE_WAIT : 服务器确认了客户端的终止请求，还有数据待发送 LAST_CHECK: 服务器方发送FIN后，最后等待对方的ACK报文 CLOSED : 连接中断 为什么需要四次握手TCP是全双工的协议，通信中双方都需要知道对方的存在，而在结束时，双方也同时需要发送断开与确认对方的断开信息。当主机1发送FIN希望断开连接时，主机1已经没有要发送的数据了，但是其还是有可能接受主机2发送的数据，此时单方面的连接断开了，这时处于半连接状态。而只有主机2也向主机1发送断开请求并确认，双方才完全的断开。 TCP的半打开状态如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常。 半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理 同时打开与同时关闭两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2 发送SYN同步信息的同时，B:port2 也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。 而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段 TCP可靠传输TCP的任务是在IP层不可靠的、尽力而为的服务基础上建立的一种可靠的传输服务。TCP使用了校验、序号、确认和重传来达到这个目的，这里主要说一下重传，重传分两种 超时重传TCP 每发送一个报文段，就对这个报文段进行一次计时，只要计时器到期而没有收到确认的的报文，就会重传这一报文。一个报文发出到确认的时间成为RTT(Round-Trip Time)，TCP使用一了一种动态适应算法来调整RTT，而时间阈值与该RTT相关 冗余ACK（快速重传）超时重传存在一个问题就是超时周期往往太长。幸运的是存在另一种方法，在超时前通过冗余ACK来较好的检测丢包情况。 TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一接期待的序号.例如发送方发送了1、2、3、4、5的TCP报文段，其中2号报文段在传输中丢失，这样3、4、5号报文段对于B来说称为了失序报文段。在本例中，3、4、5都会发送一个针对1号报文段的冗余ACK表示自己想要接收2号报文段。TCP规定发送方收到同一个报文段的3个冗余ACK时，就可以认为跟在这个报文段之后的报文已经丢失，这种技术被称为快速重传 TCP流量控制TCP流量控制服务消除接受方缓存区溢出的可能，可以说是一个速度匹配服务。 流量控制基于滑动窗口。发送方维护一个接受窗口，在TCP首部的窗口字段中声明，表示接收方可以接受的窗口大小，防止接受方报文队列溢出。 TCP流量控制与链路层流量控制的区别是，TCP是端到端的流量控制，由发送方与接收方商议。而链路层的流量控制是相邻中间节点的流量控制。而且TCP滑动窗口可变，后者不可变 TCP拥塞控制慢开始和拥塞避免 慢开始算法 TCP连接建立时，先令cwnd窗口=1,即一个最大的报文段长度。每次收到一个确认报文段，将cwnd+1。使用慢开始算法，会使得每一个传输轮次后cwnd加倍，这样它会一种指数增长到一个限定值 拥塞避免算法 拥塞避免算法的做法是每经过一个往返时延RTT就增加一个MSS的大小，这样cwnd按线性规律增长 网络拥塞的处理 使用慢开始算法，cwnd从1开始指数增大 当cwnd达到ssthresh时，启用拥塞避免算法，cwnd线性增大 当网络发生拥塞时，将cwnd置1从头慢开始算法；将ssthresh设置为拥塞值的一半 快重传和快恢复 快重传 当发送方收到3个冗余ACK的报文时，直接重传对方尚未收到的报文段而不必等待 快恢复 当发送端连续接收到3个冗余ACK后，执行乘法减小算法。将慢开始的额门限ssthresh设置成拥塞cwnd的一半，将cwnd值设置为拥塞cwnd的一半，并执行拥塞避免算法 UDPUDP简介UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测 UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和 UDP无需建立连接 UDP不维护连接状态 UDP分组首部开销小 UDP没有拥塞控制，适合容许一些数据丢失但是不允许有较大时延的应用 TCP和UDP的区别TCP和UDP协议特性的区别，主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲 TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接 TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会 TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达 TCP必须进行数据验校，UDP的校验可选 TCP有流量控制（滑动窗口）和拥塞控制，UDP没有 TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制 TCP包头较大（20字节）UDP较小（8字节） 基于TCP协议：HTTP/HTTPS、Telnet、FTP、SMTP 基于UDP的协议 DHCP、DNS、SNMP、TFTP、BOOTP","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Python测试","slug":"Python测试","date":"2018-11-10T09:49:22.000Z","updated":"2018-11-10T09:53:30.766Z","comments":true,"path":"2018/11/10/Python测试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python测试/","excerpt":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() Python中提供了单元测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950```pythonimport unittestclass TestIntSet(unittest.TestCase): def setUp(self): print(&apos;before Testing...&apos;) def test__init__(self): s = IntSet() self.assertTrue(isinstance(s.getMembers(), list)) def test_insert(self): s = IntSet() s.insert(1) self.assertEqual(s.getMembers(), [1]) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test_member(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) self.assertFalse(s.member(2)) def test_remove(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) s.remove(1) self.assertFalse(s.member(1)) def test_getMembers(self): s = IntSet() s.insert(1) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test__str__(self): s = IntSet() s.insert(5) s.insert(1) s.insert(2) self.assertEqual(s.__str__(), &apos;&#123;1,2,5&#125;&apos;) def tear_Down(self): print(&apos;after Testing...&apos;)if __name__ == &apos;__main__&apos;: unittest.main(argv=[&apos;ignored&apos;, &apos;-v&apos;], exit=False)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python面向对象","slug":"Python面向对象","date":"2018-11-10T08:48:28.000Z","updated":"2018-11-10T09:49:09.130Z","comments":true,"path":"2018/11/10/Python面向对象/","link":"","permalink":"http://yoursite.com/2018/11/10/Python面向对象/","excerpt":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。","text":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象思想的优点 可重用性 编写可重用模块，比如类 可扩展性 要求应用软件能够很方便、很容易的进行扩充和修改 可管理性 采用封装了数据和操作的类作为构建系统的部件，使项目组织更加方便合理 抽象数据类型与类抽象数据类型概念十分简单，抽象数据类型是由一个由对象及对象上操作组成的集合，对象和操作被捆绑成一个整体，可以从程序的一部分传递到另一部分。这个过程中不仅可以使用对象的数据属性，还可以使用对象上的操作。 类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现的分离编程技术。类的接口包含用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数以及定义类的各种私有函数。封装实现了类接口和实现的分离，封装后的类隐藏了实现细节，类用户只能访问接口而无法访问实现部分————-《c++ Primer》 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） Exp11234567891011121314151617181920212223242526272829class IntSet: \"\"\"实现一个整数集合\"\"\" def __init__(self): \"\"\"创建一个空的整数集合\"\"\" self.__vals = [] def insert(self, e): if e not in self.__vals: self.__vals.append(e) def member(self, e): return e in self.__vals def remove(self, e): try: self.__vals.remove(e) except: raise ValueError(str(e) + 'not found') def getMembers(self): return self.__vals[:] def __str__(self): self.__vals.sort() result = '' for e in self.__vals: result = result + str(e) + ',' return '&#123;'+ result[:-1] + '&#125;' Exp212345678910111213141516171819202122232425262728293031323334import datetimeclass Person: def __init__(self, name): self.name = name try: lastBlank = name.rindex(' ') self.lastName = name[lastBlank+1:] except: self.lastName = name self.birthday = None def getName(self): return self.name def getLastName(self): return self.lastName def setBirthday(self, birthdate): self.birthday = birthdate def getAge(self): if self.birthday == None: raise ValueError('not set birthday') return datetime.date.today().year-self.birthday.year def __lt__(self, other): if self.lastName == other.lastName: return self.name &lt; other.name return self.lastName &lt; other.lastName def __str__(self): return self.name Exp312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Student(Person): nextIdNum = 0 def __init__(self, name): Person.__init__(self, name) self.idNum = Student.nextIdNum Student.nextIdNum += 1 def getIdNum(self): return self.idNum def __lt__(self,other): return self.idNum &lt; other.idNumclass Grades: def __init__(self): self.students = [] self.grades = &#123;&#125; self.isSorted = True def addStudent(self, student): if student in self.students: raise ValueError('Duplicate student') self.students.append(student) self.grades[student.getIdNum()] = [] self.isSorted = False def addGrade(self, student, grade): try: self.grades[student.getIdNum()].append(grade) except: raise ValueError('Student not in mapping') def getGrades(self,student): try: return self.grades[student.getIdNum()][:] except: raise ValueError('Student not in mapping') def getStudents(self): if not self.isSorted: self.students.sort() self.isSorted = True return self.students[:] def gradeReport(self): report = '' for s in self.getStudents(): tot = 0.0 numGrades = 0 for g in self.getGrades(s): tot += g numGrades +=1 try: average = tot/numGrades report = report + '\\n' + str(s) + '\\'s mean grade is '+ str(average) except ZeroDivisionError: report = report + '\\n' + str(s) + 'has no grade ' return report","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python异常与断言","slug":"Python异常与断言","date":"2018-11-10T08:13:57.000Z","updated":"2018-11-10T08:29:48.665Z","comments":true,"path":"2018/11/10/Python异常与断言/","link":"","permalink":"http://yoursite.com/2018/11/10/Python异常与断言/","excerpt":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。","text":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。 下面是一个典型异常的例子 12345SuccessNum = input('Enter SuccessNum: ')totalNum = input('Enter totalNum: ')ac = int(SuccessNum)/int(totalNum)print('The AC ratio is',ac)print('Now here') 该段程序在大多数情况下是运行良好的，但是如果用户输入中出现了0，（或者干脆直接跳过）程序就会崩溃，这显然不是我们乐意看到的我们可以以下方式改写这段程序 12345678910try: SuccessNum = input('Enter SuccessNum: ') totalNum = input('Enter totalNum: ') ac = int(SuccessNum)/int(totalNum) print('The AC ratio is',ac)except ZeroDivisionError: print('Failure ! totalNum is 0')except ValueError: print('Error ! No input')print('Now here') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 异常的讨论异常看上去不太友好（毕竟如果不处理程序会崩溃），但总好于其他方式。使用异常时，程序员需要编写一些代码来处理特定异常。如果忘记处理某个异常那么这异常抛出时，程序便立刻停止。当然这也是好事，线性错误总好于隐士错误，我们来讨论BUG的问题。 显性-&gt;隐性 显性错误有明显表现，如程序崩溃或运行时间长；隐性错误没有正常表现，程序正常结束，不会出任何问题–错了给出一个错误答案。 持续-&gt;间歇 持续性错误在每次相同的运行输入时都会发生，间歇性错误仅在某些时候出现，即使是相同的输入和环境 显性错误和持续性错误是最好的，开发者不会对这种程序抱任何幻想，没有人愚蠢到使用这种程序。优秀的程序员编写程序时，会尽量使程序时显性和持续性的，这种编程方式称为防御性编程 以隐性方式出错的程序特别危险，因为他们表面没有任何问题。人们使用它并对他产生依赖。逐渐的我们的人类社会将对软件产生依赖，这些软件来执行超过人类能力的计算，我们甚至不能判断这些软件的计算是否正确。因此我们根本意识不到这个情况。这样的程序可能已经造成了严重危害。 断言Python 语言为程序员提供了一种确保程序运行状态符合预期的简单方法。 123def cal(num): assert num&gt;=0 return num**0.5","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python调试","slug":"Python调试","date":"2018-11-10T08:02:05.000Z","updated":"2018-11-10T08:29:13.077Z","comments":true,"path":"2018/11/10/Python调试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python调试/","excerpt":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() 调试过程可以看做是一个搜索过程，每次试验尽力缩减搜索空间。一个有效方法是，设计一个实验。该实验大致分为以下几步: 调查测试结果，弄清楚什么样的数据通过测试，什么样的数据未通过测试 建立一个符合现有数据的假设，假设可以很具体（403行x\\&lt;y改成x=y即可）也可以很宽泛（50-100行的循环出了问题） 设计一个推翻上述假设的实验，你应该能够明确解释出实验每种可能的结果 将你的实验记录下来 Tips for 调试 排除常见错误（这个需要经验） coding everyday 不要问自己为什么没有像你想的那样做，而是考虑程序为什么像现在这样做 错误可能不在你认为会出错的地方 试着向他人解释你的问题 不要盲目相信书上的东西（不要相信文档）大家应该首先学会读文档：） 暂停调试，先写文档 出去散散步，回头接着做 调试案例123456789101112131415161718192021222324252627282930# 调试案例# 下面程序有若干处bugdef isPal(x): \"\"\" 假设x是列表 如果列表是回文，则返回True，否则返回False \"\"\" temp = x temp.reverse() if temp == x: return True else: return Falsedef silly(n): \"\"\" 假设n是正整数 接收用户的n个输入 如果所有的输入组成一个回文列表，则返回‘Yes’ 否则返回‘No’ \"\"\" for i in range(n): result = [] elem = input('Enter element: ') result.append(elem) if(isPal(result)): return True else: return False Python的可变数据类型与不可变数据类型python中的不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化. 可变数据类型(mutable) Dictionary（字典） List（列表） 不可变数据类型(unmutable) Number（数字） String（字符串） Tuple（元组） Bool(布尔值) 1234567891011121314151617181920212223242526272829303132# 不可变数据类型a = 15b = 15print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")b = 20print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")# 可变数据类型a = [1,2,3]b = ac = [1,2,3]print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))print(\"**********友爱的分割线************\")b[0] = 4c[0] = 5print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"c的值是\"+ str(c))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"面经问题总结","slug":"面经问题总结","date":"2018-11-09T14:07:10.000Z","updated":"2018-12-07T13:10:22.433Z","comments":true,"path":"2018/11/09/面经问题总结/","link":"","permalink":"http://yoursite.com/2018/11/09/面经问题总结/","excerpt":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法","text":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法 6 GET/POST 区别与联系 7 防火墙和DNS劫持 8 http 介绍 http请求头、响应头都有哪些字段 9 netstat查看端口相关命令 10 TCP为什么是可靠的，如何进行拥塞控制 11 长连接与短连接 12 介绍一下常见的网络协议 13 http状态码有哪些 14 一个网站进入速度较慢，可以从哪些方面优化 15 web常见的安全问题有哪些、如何预防 16 http协议请求首部介绍一下 http正向代理和反向代理什么意思 17 GET\\POST 区别，form表单默认的请求方法是get、post？能用get完成的请求都能用post完成吗 18 输入一个网址后回车发生的全过程 19 TCP和UDP 区别，哪一个快一些？UDP丢包怎么处理，TCP拥塞控制机制，慢启动的缺点 20 TCP四次挥手的过程，为什么要主动关闭方等到2MSL的时间 21 http 头部字段keep-alive了解过吗？什么时候服务器知道可以断开连接呢？ 22 http 状态码有哪些？ 502、504 状态码是是么？ 23 TCP和UDP 区别、TCP流量控制和拥塞控制、慢启动 24 访问taobao.com的全过程，如何获取每一阶段的耗时 25 ARP协议 ping命令 操作系统1 虚拟内存的作用是什么？分页有什么好处？分段呢 2 同步和异步的区别 3 进程和线程的区别，谁调度的进程 4 死锁的条件，如何检测死锁 5 死锁的必要条件，银行家算法 6 内核态线程和用户态线程的区别 7 非阻塞IO 8 程调度算法有哪些 9 通俗的语言，面对一个非程序员，解释进程与线程的区别 10 多线程中如何保证线程安全，如何创建守护进程 11 死锁是什么，为什么会产生死锁，怎么解决死锁问题，预防死锁、避免死锁 12 进程的同步进制有哪些？ 进程的通信机制有哪些？ 13 进程的状态转换图及转换事件 数据库1 数据库建立索引的原则有哪些 2 B+树与数据库索引 3 4 聚簇索引和非聚簇索引，一个连环索引对 a 升序排列，对 b 降序排雷，这个时候可以使用索引吗？ 5 数据库加行锁怎么加？ DML语句？ 6 group by, having, order by limit 执行顺序 7 left join 和 inner join 的区别 8 mysql 的非运算如何去掉 not in 和 ！= 这样的过滤条件 9 聚簇索引和非聚簇索引，能不能对 like 出的东西加索引，能不能函数加索引 10 数据库事务的隔离级别，如何对数据库加锁，内连接和外连接 11 mysql 的索引 12 数据库如果有一张表特别大怎么办？（索引优化、加缓存、读写分离、业务拆分） 13 哪些字段可以建索引 14 mysql 储存引擎 15 数据库死锁的概念 16 数据库引擎有哪些，有什么区别，索引分别是怎么实现的？ 17 介绍下数据库的索引 18 乐观锁和悲观锁 19 数据库索引，不同引擎的内部实现，B+树的具体性质 20 数据库索引，底层实现、mysql 两种引擎的区别，数据库查询特别慢怎么优化 21 主要使用的数据类型、数据库引擎了解吗，有什么区别 22 数据库事务、事务的隔离级别 SQL1 (1)写sql，Table T Sid：学号 Cid：课程编号 score：成绩，q1：查询平均成绩大于60分的同学的学号和平均成绩 q2：查询所有课程成绩小于60的同学的学号 2 给一张表，找出成绩在10-15名学生 分布式数据库1 redis 是线程安全的吗？ 为什么是单线程 2 介绍 redis 3 redis 和 mysql 的不同，应用场景 4 用户什么格式的数据格式和用 redis 储存 5 redis mybatis 二级缓存","categories":[],"tags":[{"name":"面试基础","slug":"面试基础","permalink":"http://yoursite.com/tags/面试基础/"}]},{"title":"博客的重新开始","slug":"博客的重新开始","date":"2018-11-09T13:39:42.000Z","updated":"2018-12-07T13:04:34.052Z","comments":true,"path":"2018/11/09/博客的重新开始/","link":"","permalink":"http://yoursite.com/2018/11/09/博客的重新开始/","excerpt":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。","text":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。 目前离最早的实习面试还有四个月左右，我也已经投出第一篇论文，这一段时间要专注的去复习计算机基础知识了。趁着这一段时间去丰富自己的理论知识。感觉目前工程经历和科研经历都不少了，一路走过来奖项也拿了不少了，所欠缺的主要是对于理论知识的理解，另外对于一些较为需求的方向例如爬虫、redis做一个demo项目。加油！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}