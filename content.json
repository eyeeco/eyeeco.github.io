{"meta":{"title":"MapleStory","subtitle":null,"description":"CS:Dalian University of technology","author":"Eyc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"欢迎来到Eyc的博客！","slug":"欢迎来到Eyc的博客!","date":"2018-11-11T12:06:38.000Z","updated":"2018-11-11T12:12:07.422Z","comments":true,"path":"2018/11/11/欢迎来到Eyc的博客!/","link":"","permalink":"http://yoursite.com/2018/11/11/欢迎来到Eyc的博客!/","excerpt":"","text":"欢迎来到我的博客！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"HTTP","slug":"HTTP","date":"2018-11-11T11:54:23.000Z","updated":"2018-11-11T12:09:36.586Z","comments":true,"path":"2018/11/11/HTTP/","link":"","permalink":"http://yoursite.com/2018/11/11/HTTP/","excerpt":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击）","text":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击） GET与POST的区别作用GET用于获取资源，POST用于传输实体主体 参数GET和POST都能使用额外的参数，但是GET参数以查询字符串的形式出现在URL中，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin 这个过程用户可见。而POST的参数存储在实体主体中。通过HTTP的POST机制。POST参数可以通过一些抓包工具（Fiddler）查看 因为URL只支持ASCLL码，因此GET参数中文会被编码，空格被编码为%20 安全安全的HTTP方法不会改变服务器状态，可以说他是只读的 GET方法安全的，POST不是，POST方法传输主体内容，这个内容可能是某个表单数据，服务器可能把其存入数据库中，这样状态就发生了改变 幂等性幂等性的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。 所有安全的方法是幂等的，GET、HEAD、PUT、DELETE方法都是幂等的 而POST方法不是幂等的 XMLHTTPRequestXMLHTTP Request是一个API，它为客户端和服务器之间传输数据的功能。他提供了一个URL来获取数据的简单方式，而且不会使整个页面刷新。这使得网页只更新一部分不会打扰到用户，在AJAX中被大量使用 在xmlhttprequest中POST会先发送header再发送data（当然也和浏览器的做法相关） 而get方法会一起发送 其他Get传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递 Get方式只支持ASCII字符，向服务器传输的中文字符可能会乱码。POST支持标准字符集，可以正确的传递中文字符 HTTP 首部 Request Header 解释 某度首页示例 Accept 客户端能够接受的内容类型 text/html Accept-Encoding 浏览器可以支持的web服务器返回内容压缩编码类型 gzip Accept-Language 浏览器可以接受的语言 zh-CN Cache-Control 指定请求和相应遵循的缓存机制 max-age=0 Connection 表示是否需要持久连接 keep-alive Cookie HTTP请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器 键值对 Host 请求服务器的域名和端口号 www.baidu.com Upgrade-Insecure-Requests 浏览器可以处理HTTPS协议 1 User-Agent 发出请求的用户信息 Mozilla/5.0 HTTP 首部 Response Header 解释 某度首页示例 Cache-Control 告诉所有的缓存机制是否可以缓存及缓存哪种类型 private Connection 是否保持持久连接 keep-alive Content-Encoding 返回内容压缩编码类型 gzip Content-type 返回内容的MIME类型 text/html charset=utf-8 Date 原始服务器消息发出时间 Wed 03 Oct2018 12:04:45 GMT Expires 响应过期的时间 Wed 03 Oct2018 12:04:45 GMT Server Web服务器软件名称 BWS1.1 Set-Cookie 设置浏览器缓存 BDSVRTM=114; path=/ Transfer-Encoding 文件传输编码 chunked HTTP状态码HTTP中状态码大致分为五大类： 100-199 信息性状态码 100 continue： 收到了请求的初始部分，请客户端继续 200-299 成功状态码 200 OK：请求被正常处理 204 No Content: 请求被接受，但是响应报文只有首部和状态行，没有实体部分 206 Partial Content: 客户端只请求了一部分的资源，服务器只针对请求的部分资源进行返回 300-399 重定向状态码 301 Moved Permanently: 永久重定向 302 Found: 临时重定向，资源被临时移动了 303 See Other: 表示用户请求的资源代表着另一个URI，应该使用GET去获取资源 304 Not Modified: 当客户端发送的请求附带条件时，服务器找到资源但未符合请求 307 Temporary Redirect: 同302，临时重定向 400-499 客户端错误状态码 400 Bad Request: 告知客户端它发送了一个错误的请求 401 Unauthorized: 请求需进行认证 403 Forbidden: 请求被服务器拒绝了 404 Not Found：服务器无法找到对应资源 405 Method Not Allowed：请求中带有不支持的方法 500-599 服务器错误状态码 500 Internet Server Error: 服务器内部错误 502 Bad GateWay： 代理或网关服务器从下一条链路收到了伪响应 503 Server Unavailable: 服务器正忙 504 GateWay Timeout: 一个代理网关等待另一服务器时超时了 持续性连接和非持续性连接1. 定义非持续连接：每个请求、相应都经一个而单独的TCP连接发送 持续连接：所有的请求相应通过相同的TCP连接发送 2. 区别如果采用非持续连接，打开包含一个HTML文件和10个内联对象网页，HTTP需要建立11次TCP连接才能把文件从服务器传到客户机。而如果采用持续连接，HTTP建立一次TCP就把文件从服务器传到客户机 每次TCP连接必需建立和断开（通过三次握手建立、四次挥手断开），这都需要占用CPU资源，这样占用客户机和服务器的CPU时间大大减少 每次连接，客户端和服务器都必须分配发送和接收缓存，这意味着影响服务器和客户机的资源，着同样要占用CPU时间 对于大量对象组成的文件，TCP低速启动算法会限制服务机向客户机传送对象的速度。使用HTTP/1.1后，大多数对象以最大速率传输 3. HTTP/1.0 + keep-aliveHTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live connection:keep-live 是HTTP1.0 浏览器和服务器的实验性扩展 Cookie 与 Session由于HTTP是无状态协议，为了保持客户端与服务器的一些关系，便有了cookie和session 1.cookiecookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。网络服务器用HTTP头想客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。 内容 过期时间会话cookie：若不设置过期时间，则表示这个cookie的生命周期为浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie 持久cookie：若设置了过期时间，浏览器会把cookie存储到硬盘上（当然用户可以选择拒绝），关闭后再打开这些cookie仍然有效 2.sessionsession机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息 当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。 session_id的储存 保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session 由于cookie可以被认为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符 另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id 3. cookie与session的区别存取方式不同cookie只能保存ASCII字符，Unicode及二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较为艰难。而session中能够存取任何类型的数据，包括不限于string、integer、list、map，而且可以直接存取java的类对象，十分方便 隐私策略不同cookie存储在客户端阅读器中，对客户端可见，客户端可以窥探甚至是修改cookie内容。而session存储在服务器上对用户透明，不存在泄露风险。cookie可以像google及baidu一样将敏感信息加密后保存，在服务器上进行解密。 有效时间不同由于session依赖于session_id的cookie，而session_id过期时间默许为-1，关闭浏览器即消失。而cookie可以设置长期的保存 服务器压力不同由于不同的储存方式，储存在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大 浏览器支持不同cookie是需要客户端浏览器支持的，假如客户端禁用了cookie或者不支持cookie，则会话跟踪会失效。 假如客户端不支持cookie，就需要运用session及url地址重写。需要注意的是一切用到session的程序url都需要进行重写，否则session会话还是会失效 跨域支持不同cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用 session仅在当前域名有效 其他一个web页面的请求过程1.DHCP配置主机信息（找本机IP） 主机生成一个DHCP请求报文，并将这个报文放入目的端口67和源端口68的UDP报文段中 该报文段放在一个广播IP地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中 该数据报被放在MAC帧中，目的地址FF:FF:FF:FF:FF:FF，广播到交换机连接的所有设备 交换机的DHCP服务器收到广播帧后，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括 IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码，再经过层层封装到MAC帧中 该帧的目的地址是主机的mac地址，主机收到该帧后分解得DHCP报文，之后配置IP地址，子网掩码、DNS服务器IP地址，安装默认网关 2.ARP解析网关MAC地址（找网关MAC地址） 主机通过浏览器生成一个TCP套接字，为了发送HTTP请求，需要知道网站对应的IP地址 生成一个DNS查询报文，端口53（DNS服务器） DNS查询报文放入目的地址为DNS服务器IP地址的IP数据报中 IP数据报放入一个以太网帧中，发送至网关路由器 DHCP过程只知道网关的IP地址，为了获取网关的MAC地址，需要用ARP协议 主机生成一个目的地址为网关路由器IP的ARP查询报文，放入一个广播帧中，并发送这个以太网帧，交换机将其发送给所有的连接设备 网关接收到该帧后，分解得到ARP报文，发现IP地址与自己想匹配，发送一个ACK报文回应自己的MAC地址 3.DNS解析域名（找服务器IP） 知道了DNS的MAC地址后就可以继续DNS解析过程 网关接收到DNS查询报文后，抽出IP数据报，并根据该表选择该转发的路由器 路由器根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项 之前的DNS报文到DNS服务器后，照常依次抽出报文，在DNS库中查找解析域名 找到DNS记录后发送DNS回答报文，然后将其放入UDP报文段、IP数据报，通过路由器反转发回网关路由器，经过交换机到主机 4. HTTP请求页面 有了HTTP服务器的IP地址后，主机便可以生成TCP套接字，向web服务器发送HTTP get报文 建立HTTP连接前需要进行TCP连接，进行三次握手，过程略 建立连接后发送HTTP的GET报文，交付给HTTP服务器 HTTP服务器从TCP中读出报文，生成HTTP相应报文，将web页面放入HTTP报文主体中发挥主机 浏览器收到HTTP相应报文后抽取WEB页面内容进行渲染，显示web页面","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"TCP与UDP","slug":"TCP与UDP","date":"2018-11-11T11:49:28.000Z","updated":"2018-11-11T11:53:44.610Z","comments":true,"path":"2018/11/11/TCP与UDP/","link":"","permalink":"http://yoursite.com/2018/11/11/TCP与UDP/","excerpt":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制","text":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制 TCP三次握手 第一步：客户机的TCP首先向服务器的TCP发送一个请求连接报文段。这个特殊的报文段不包含应用层数据，其中首部的SYN标志位被置位1.另外客户机会随机选择一个起始序号seq=x 第二步：服务器的TCP收到请求的报文后，如同意建立连接，就向客户机发回确认，并为该TCP分配TCP缓存和变量。在确认报文段中，SYN和ACK被置为1，确认号的字段值为x+1 第三步：客户机收到确认报文段后向服务器给出确认，并且给该连接分配内存和变量，ACK置1，确认号为y+1 为什么TCP进行三次握手？本质上TCP协议的三次握手需要解决这样一个问题：在不可靠的信道上（IP数据报尽最大努力交付）完成可靠的数据传输。而全双工的连接建立需要双方的连接请求和确认，这样最少需要使用三次握手才能建立连接 至于为什么三次是最少，客户端服务器二者最少都需要向对方发送一个同步报文（SYN），但是如果只有这两次握手，服务器就只能接受连接，无法确认连接；设想如果服务器接受一个SYN报文就建立连接，那客户端因为阻塞原因重发了N个SYN同步报文 ，服务器每接受到一个就需要建立一次连接，这是不堪设想的。所以只有当服务器接收到客户端第二次的ack确认报文后才会建立连接 TCP四次挥手断开连接 客户端请求断开FIN1（客户端无更多数据） 服务器ACK确认（收到，但是仍有数据传输） 服务器请求断开FIN2（服务器无更多数据） 客户端ACK确认 四次挥手中的状态 FINWAIT1 : 当客户端在established状态想要断开连接，主动向服务器器发送FIN报文，此时该socket便进入FINWAIT1状态 FINWAIT2: 这时客户端已经收到对方的确认ack,但是服务器可能还有数据未发送完成，还需要接受对方的数据，处于半连接（半关闭）状态 TIME_WAIT: 客户端接受到了对方的确认报文、也接收到了对方的fin报文，现在发出了最后的确认报文，进入一个2MSL的等待状态，如果等待状态没有重发便进入结束状态 CLOSE_WAIT : 服务器确认了客户端的终止请求，还有数据待发送 LAST_CHECK: 服务器方发送FIN后，最后等待对方的ACK报文 CLOSED : 连接中断 为什么需要四次握手TCP是全双工的协议，通信中双方都需要知道对方的存在，而在结束时，双方也同时需要发送断开与确认对方的断开信息。当主机1发送FIN希望断开连接时，主机1已经没有要发送的数据了，但是其还是有可能接受主机2发送的数据，此时单方面的连接断开了，这时处于半连接状态。而只有主机2也向主机1发送断开请求并确认，双方才完全的断开。 TCP的半打开状态如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常。 半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理 同时打开与同时关闭两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2 发送SYN同步信息的同时，B:port2 也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。 而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段 TCP可靠传输TCP的任务是在IP层不可靠的、尽力而为的服务基础上建立的一种可靠的传输服务。TCP使用了校验、序号、确认和重传来达到这个目的，这里主要说一下重传，重传分两种 超时重传TCP 每发送一个报文段，就对这个报文段进行一次计时，只要计时器到期而没有收到确认的的报文，就会重传这一报文。一个报文发出到确认的时间成为RTT(Round-Trip Time)，TCP使用一了一种动态适应算法来调整RTT，而时间阈值与该RTT相关 冗余ACK（快速重传）超时重传存在一个问题就是超时周期往往太长。幸运的是存在另一种方法，在超时前通过冗余ACK来较好的检测丢包情况。 TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一接期待的序号.例如发送方发送了1、2、3、4、5的TCP报文段，其中2号报文段在传输中丢失，这样3、4、5号报文段对于B来说称为了失序报文段。在本例中，3、4、5都会发送一个针对1号报文段的冗余ACK表示自己想要接收2号报文段。TCP规定发送方收到同一个报文段的3个冗余ACK时，就可以认为跟在这个报文段之后的报文已经丢失，这种技术被称为快速重传 TCP流量控制TCP流量控制服务消除接受方缓存区溢出的可能，可以说是一个速度匹配服务。 流量控制基于滑动窗口。发送方维护一个接受窗口，在TCP首部的窗口字段中声明，表示接收方可以接受的窗口大小，防止接受方报文队列溢出。 TCP流量控制与链路层流量控制的区别是，TCP是端到端的流量控制，由发送方与接收方商议。而链路层的流量控制是相邻中间节点的流量控制。而且TCP滑动窗口可变，后者不可变 TCP拥塞控制慢开始和拥塞避免 慢开始算法 TCP连接建立时，先令cwnd窗口=1,即一个最大的报文段长度。每次收到一个确认报文段，将cwnd+1。使用慢开始算法，会使得每一个传输轮次后cwnd加倍，这样它会一种指数增长到一个限定值 拥塞避免算法 拥塞避免算法的做法是每经过一个往返时延RTT就增加一个MSS的大小，这样cwnd按线性规律增长 网络拥塞的处理 使用慢开始算法，cwnd从1开始指数增大 当cwnd达到ssthresh时，启用拥塞避免算法，cwnd线性增大 当网络发生拥塞时，将cwnd置1从头慢开始算法；将ssthresh设置为拥塞值的一半 快重传和快恢复 快重传 当发送方收到3个冗余ACK的报文时，直接重传对方尚未收到的报文段而不必等待 快恢复 当发送端连续接收到3个冗余ACK后，执行乘法减小算法。将慢开始的额门限ssthresh设置成拥塞cwnd的一半，将cwnd值设置为拥塞cwnd的一半，并执行拥塞避免算法 UDPUDP简介UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测 UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和 UDP无需建立连接 UDP不维护连接状态 UDP分组首部开销小 UDP没有拥塞控制，适合容许一些数据丢失但是不允许有较大时延的应用 TCP和UDP的区别TCP和UDP协议特性的区别，主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲 TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接 TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会 TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达 TCP必须进行数据验校，UDP的校验可选 TCP有流量控制（滑动窗口）和拥塞控制，UDP没有 TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制 TCP包头较大（20字节）UDP较小（8字节） 基于TCP协议：HTTP/HTTPS、Telnet、FTP、SMTP 基于UDP的协议 DHCP、DNS、SNMP、TFTP、BOOTP","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Python测试","slug":"Python测试","date":"2018-11-10T09:49:22.000Z","updated":"2018-11-10T09:53:30.766Z","comments":true,"path":"2018/11/10/Python测试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python测试/","excerpt":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() Python中提供了单元测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950```pythonimport unittestclass TestIntSet(unittest.TestCase): def setUp(self): print(&apos;before Testing...&apos;) def test__init__(self): s = IntSet() self.assertTrue(isinstance(s.getMembers(), list)) def test_insert(self): s = IntSet() s.insert(1) self.assertEqual(s.getMembers(), [1]) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test_member(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) self.assertFalse(s.member(2)) def test_remove(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) s.remove(1) self.assertFalse(s.member(1)) def test_getMembers(self): s = IntSet() s.insert(1) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test__str__(self): s = IntSet() s.insert(5) s.insert(1) s.insert(2) self.assertEqual(s.__str__(), &apos;&#123;1,2,5&#125;&apos;) def tear_Down(self): print(&apos;after Testing...&apos;)if __name__ == &apos;__main__&apos;: unittest.main(argv=[&apos;ignored&apos;, &apos;-v&apos;], exit=False)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python面向对象","slug":"Python面向对象","date":"2018-11-10T08:48:28.000Z","updated":"2018-11-10T09:49:09.130Z","comments":true,"path":"2018/11/10/Python面向对象/","link":"","permalink":"http://yoursite.com/2018/11/10/Python面向对象/","excerpt":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。","text":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象思想的优点 可重用性 编写可重用模块，比如类 可扩展性 要求应用软件能够很方便、很容易的进行扩充和修改 可管理性 采用封装了数据和操作的类作为构建系统的部件，使项目组织更加方便合理 抽象数据类型与类抽象数据类型概念十分简单，抽象数据类型是由一个由对象及对象上操作组成的集合，对象和操作被捆绑成一个整体，可以从程序的一部分传递到另一部分。这个过程中不仅可以使用对象的数据属性，还可以使用对象上的操作。 类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现的分离编程技术。类的接口包含用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数以及定义类的各种私有函数。封装实现了类接口和实现的分离，封装后的类隐藏了实现细节，类用户只能访问接口而无法访问实现部分————-《c++ Primer》 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） Exp11234567891011121314151617181920212223242526272829class IntSet: \"\"\"实现一个整数集合\"\"\" def __init__(self): \"\"\"创建一个空的整数集合\"\"\" self.__vals = [] def insert(self, e): if e not in self.__vals: self.__vals.append(e) def member(self, e): return e in self.__vals def remove(self, e): try: self.__vals.remove(e) except: raise ValueError(str(e) + 'not found') def getMembers(self): return self.__vals[:] def __str__(self): self.__vals.sort() result = '' for e in self.__vals: result = result + str(e) + ',' return '&#123;'+ result[:-1] + '&#125;' Exp212345678910111213141516171819202122232425262728293031323334import datetimeclass Person: def __init__(self, name): self.name = name try: lastBlank = name.rindex(' ') self.lastName = name[lastBlank+1:] except: self.lastName = name self.birthday = None def getName(self): return self.name def getLastName(self): return self.lastName def setBirthday(self, birthdate): self.birthday = birthdate def getAge(self): if self.birthday == None: raise ValueError('not set birthday') return datetime.date.today().year-self.birthday.year def __lt__(self, other): if self.lastName == other.lastName: return self.name &lt; other.name return self.lastName &lt; other.lastName def __str__(self): return self.name Exp312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Student(Person): nextIdNum = 0 def __init__(self, name): Person.__init__(self, name) self.idNum = Student.nextIdNum Student.nextIdNum += 1 def getIdNum(self): return self.idNum def __lt__(self,other): return self.idNum &lt; other.idNumclass Grades: def __init__(self): self.students = [] self.grades = &#123;&#125; self.isSorted = True def addStudent(self, student): if student in self.students: raise ValueError('Duplicate student') self.students.append(student) self.grades[student.getIdNum()] = [] self.isSorted = False def addGrade(self, student, grade): try: self.grades[student.getIdNum()].append(grade) except: raise ValueError('Student not in mapping') def getGrades(self,student): try: return self.grades[student.getIdNum()][:] except: raise ValueError('Student not in mapping') def getStudents(self): if not self.isSorted: self.students.sort() self.isSorted = True return self.students[:] def gradeReport(self): report = '' for s in self.getStudents(): tot = 0.0 numGrades = 0 for g in self.getGrades(s): tot += g numGrades +=1 try: average = tot/numGrades report = report + '\\n' + str(s) + '\\'s mean grade is '+ str(average) except ZeroDivisionError: report = report + '\\n' + str(s) + 'has no grade ' return report","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python异常与断言","slug":"Python异常与断言","date":"2018-11-10T08:13:57.000Z","updated":"2018-11-10T08:29:48.665Z","comments":true,"path":"2018/11/10/Python异常与断言/","link":"","permalink":"http://yoursite.com/2018/11/10/Python异常与断言/","excerpt":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。","text":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。 下面是一个典型异常的例子 12345SuccessNum = input('Enter SuccessNum: ')totalNum = input('Enter totalNum: ')ac = int(SuccessNum)/int(totalNum)print('The AC ratio is',ac)print('Now here') 该段程序在大多数情况下是运行良好的，但是如果用户输入中出现了0，（或者干脆直接跳过）程序就会崩溃，这显然不是我们乐意看到的我们可以以下方式改写这段程序 12345678910try: SuccessNum = input('Enter SuccessNum: ') totalNum = input('Enter totalNum: ') ac = int(SuccessNum)/int(totalNum) print('The AC ratio is',ac)except ZeroDivisionError: print('Failure ! totalNum is 0')except ValueError: print('Error ! No input')print('Now here') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 异常的讨论异常看上去不太友好（毕竟如果不处理程序会崩溃），但总好于其他方式。使用异常时，程序员需要编写一些代码来处理特定异常。如果忘记处理某个异常那么这异常抛出时，程序便立刻停止。当然这也是好事，线性错误总好于隐士错误，我们来讨论BUG的问题。 显性-&gt;隐性 显性错误有明显表现，如程序崩溃或运行时间长；隐性错误没有正常表现，程序正常结束，不会出任何问题–错了给出一个错误答案。 持续-&gt;间歇 持续性错误在每次相同的运行输入时都会发生，间歇性错误仅在某些时候出现，即使是相同的输入和环境 显性错误和持续性错误是最好的，开发者不会对这种程序抱任何幻想，没有人愚蠢到使用这种程序。优秀的程序员编写程序时，会尽量使程序时显性和持续性的，这种编程方式称为防御性编程 以隐性方式出错的程序特别危险，因为他们表面没有任何问题。人们使用它并对他产生依赖。逐渐的我们的人类社会将对软件产生依赖，这些软件来执行超过人类能力的计算，我们甚至不能判断这些软件的计算是否正确。因此我们根本意识不到这个情况。这样的程序可能已经造成了严重危害。 断言Python 语言为程序员提供了一种确保程序运行状态符合预期的简单方法。 123def cal(num): assert num&gt;=0 return num**0.5","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python调试","slug":"Python调试","date":"2018-11-10T08:02:05.000Z","updated":"2018-11-10T08:29:13.077Z","comments":true,"path":"2018/11/10/Python调试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python调试/","excerpt":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() 调试过程可以看做是一个搜索过程，每次试验尽力缩减搜索空间。一个有效方法是，设计一个实验。该实验大致分为以下几步: 调查测试结果，弄清楚什么样的数据通过测试，什么样的数据未通过测试 建立一个符合现有数据的假设，假设可以很具体（403行x\\&lt;y改成x=y即可）也可以很宽泛（50-100行的循环出了问题） 设计一个推翻上述假设的实验，你应该能够明确解释出实验每种可能的结果 将你的实验记录下来 Tips for 调试 排除常见错误（这个需要经验） coding everyday 不要问自己为什么没有像你想的那样做，而是考虑程序为什么像现在这样做 错误可能不在你认为会出错的地方 试着向他人解释你的问题 不要盲目相信书上的东西（不要相信文档）大家应该首先学会读文档：） 暂停调试，先写文档 出去散散步，回头接着做 调试案例123456789101112131415161718192021222324252627282930# 调试案例# 下面程序有若干处bugdef isPal(x): \"\"\" 假设x是列表 如果列表是回文，则返回True，否则返回False \"\"\" temp = x temp.reverse() if temp == x: return True else: return Falsedef silly(n): \"\"\" 假设n是正整数 接收用户的n个输入 如果所有的输入组成一个回文列表，则返回‘Yes’ 否则返回‘No’ \"\"\" for i in range(n): result = [] elem = input('Enter element: ') result.append(elem) if(isPal(result)): return True else: return False Python的可变数据类型与不可变数据类型python中的不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化. 可变数据类型(mutable) Dictionary（字典） List（列表） 不可变数据类型(unmutable) Number（数字） String（字符串） Tuple（元组） Bool(布尔值) 1234567891011121314151617181920212223242526272829303132# 不可变数据类型a = 15b = 15print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")b = 20print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")# 可变数据类型a = [1,2,3]b = ac = [1,2,3]print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))print(\"**********友爱的分割线************\")b[0] = 4c[0] = 5print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"c的值是\"+ str(c))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"面经问题总结","slug":"面经问题总结","date":"2018-11-09T14:07:10.000Z","updated":"2018-11-10T08:29:21.916Z","comments":true,"path":"2018/11/09/面经问题总结/","link":"","permalink":"http://yoursite.com/2018/11/09/面经问题总结/","excerpt":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法","text":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法 6 GET/POST 区别与联系 7 防火墙和DNS劫持 8 http 介绍 http请求头、响应头都有哪些字段 9 netstat查看端口相关命令 10 TCP为什么是可靠的，如何进行拥塞控制 11 长连接与短连接 12 介绍一下常见的网络协议 13 http状态码有哪些 14 一个网站进入速度较慢，可以从哪些方面优化 15 web常见的安全问题有哪些、如何预防 16 http协议请求首部介绍一下 http正向代理和反向代理什么意思 17 GET\\POST 区别，form表单默认的请求方法是get、post？能用get完成的请求都能用post完成吗 18 输入一个网址后回车发生的全过程 19 TCP和UDP 区别，哪一个快一些？UDP丢包怎么处理，TCP拥塞控制机制，慢启动的缺点 20 TCP四次挥手的过程，为什么要主动关闭方等到2MSL的时间 21 http 头部字段keep-alive了解过吗？什么时候服务器知道可以断开连接呢？ 22 http 状态码有哪些？ 502、504 状态码是是么？ 23 TCP和UDP 区别、TCP流量控制和拥塞控制、慢启动 24 访问taobao.com的全过程，如何获取每一阶段的耗时 25 ARP协议 ping命令 操作系统1 虚拟内存的作用是什么？分页有什么好处？分段呢 2 同步和异步的区别 3 进程和线程的区别，谁调度的进程 4 死锁的条件，如何检测死锁 5 死锁的必要条件，银行家算法 6 内核态线程和用户态线程的区别 7 非阻塞IO 8 程调度算法有哪些 9 通俗的语言，面对一个非程序员，解释进程与线程的区别 10 多线程中如何保证线程安全，如何创建守护进程 11 死锁是什么，为什么会产生死锁，怎么解决死锁问题，预防死锁、避免死锁 12 进程的同步进制有哪些？ 进程的通信机制有哪些？ 13 进程的状态转换图及转换事件","categories":[],"tags":[{"name":"面试基础","slug":"面试基础","permalink":"http://yoursite.com/tags/面试基础/"}]},{"title":"博客的重新开始","slug":"博客的重新开始","date":"2018-11-09T13:39:42.000Z","updated":"2018-11-10T08:28:58.300Z","comments":true,"path":"2018/11/09/博客的重新开始/","link":"","permalink":"http://yoursite.com/2018/11/09/博客的重新开始/","excerpt":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。","text":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。 目前离最早的实习面试还有四个月左右，我也已经投出第一篇论文，这一段时间要专注的去复习计算机基础知识了。趁着这一段时间去丰富自己的理论知识。感觉目前工程经历和科研经历都不少了，一路走过来奖项也拿了不少了，所欠缺的主要是对于理论知识的理解，另外对于一些较为需求的方向例如爬虫、redis做一个demo项目。加油！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}