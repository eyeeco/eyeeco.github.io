{"meta":{"title":"MapleStory","subtitle":null,"description":"CS:Dalian University of technology","author":"Eyc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"HTTP复习","slug":"HTTP复习","date":"2019-02-17T11:59:06.000Z","updated":"2019-02-17T12:02:51.746Z","comments":true,"path":"2019/02/17/HTTP复习/","link":"","permalink":"http://yoursite.com/2019/02/17/HTTP复习/","excerpt":"HTTP 复习协议是计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。HTTP协议是一种详细规定了浏览器和万维网服务器之间相互通信的规则，通过因特网传送万维网文档和数据的协议。HTTP协议可以使浏览器更加高效的运行，使网络的传输效率更高。它不仅保证计算机快速正确的传输超文本文档，还确定哪一部分先显示。 HTTP由于其灵活简单快速的特点，应用非常广泛。浏览器网页是HTTP主要的应用，但其不只是用于网页浏览。只要通信的双方都使用他就可以通信。比如QQ软件就用到了HTTP协议。","text":"HTTP 复习协议是计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。HTTP协议是一种详细规定了浏览器和万维网服务器之间相互通信的规则，通过因特网传送万维网文档和数据的协议。HTTP协议可以使浏览器更加高效的运行，使网络的传输效率更高。它不仅保证计算机快速正确的传输超文本文档，还确定哪一部分先显示。 HTTP由于其灵活简单快速的特点，应用非常广泛。浏览器网页是HTTP主要的应用，但其不只是用于网页浏览。只要通信的双方都使用他就可以通信。比如QQ软件就用到了HTTP协议。 HTTP工作流程在网路的七层模型中，HTTP在应用层也就是传输层以上，其基于TCP协议。 HTTP的默认端口号为80， 而HTTPS的默认端口号是443 HTTP是基于传输层的TCP协议，而TCP是一个端到端面向连接的协议。所谓的端到端可以理解为进程到进程的通信，所以HTTP在开始传输之前，首先要建立TCP连接，而TCP连接的过程需要三次握手。在TCP的三次握手后，建立了TCP连接。此时HTTP就可以进行传输了。一个HTTP操作称为一个事务，可以分为以下几步： 首先客户机与服务器需要建立连接。只要单机某个超级链接，HTTP工作即开始 建立连接后，客户机发送一个请求给服务器，请求的格式为：同一资源标识符（URL），协议版本号，后面是MIME信息，包括（请求修饰符、客户机信息和可能的内容） 服务器接到请求后，给与一个相应的响应信息，其格式为一个状态行、包括信息的协议版本号、一个成功或错误的状态码、后面是MIME信息（服务器信息、实体信息、可能的内容） 客户端接受服务器返回的信息通过浏览器返回在用户显示屏上，然后客户机与服务器断开连接。 如果上述几步中某一步出现错误，那么产生的错误信息返回客户端，由显示屏输出。HTTP协议永远都是客户端发起请求，服务器响应。 HTTP 协议结构HTTP 协议无论是请求报文还是回应报文，都包含以下四个部分。 报文头： GET http://www.baidu.com HTTP/1.1 0个或多个请求头 Accept-Language: en 空行 可选的消息体 HTTP协议是基于行的协议，每一行以\\r\\n 为分隔符。报文头通常表明报文的类型，且报文头只占一行；请求头附带一些特殊信息，每一个请求头占一行 name:value HTTP请求方法HTTP/1.1 协议中定了 9 种方法来表明Request-URL 指定资源的不同的操作方式 OPTIONS 返回服务器针对特定资源的HTTP请求方法 HEAD 向服务器索要与GET请求一致的相应，而响应体不会被返回 GET 向特定资源发出请求（GET可能会被爬虫随意访问） POST 向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改 PUT 向指定资源上传最新内容 DELETE 请求服务器删除 REQUEST_URL 所标识的资源 TRACE 回显服务器收到的请求 CONNECT 预留给连接方式改为管道的代理服务器 PATCH 局部修改某一资源 当请求的资源不支持请求方法时， 服务器返回405（Method Not Allowed）服务器不认识或不支持方法时， 返回501（Not Implemented） 常见的请求头Host：（发送请求，请求头是必须的）主要用于执行被请求资源的Internet主机和端口号，它从HTTP的URL中提取出来， Connection: 它的值通常有两个，keep-alive 和close。 HTTP 是一个请求响应模式的典型范例，即客户端向服务器发送一个请求信息，服务器来响应这个信息。在之前的HTTP版本中，每个请求被创建一个新的到服务器端的连接，在这个连接上发送请求，然后接受请求。keep-alive被用来解决效率了低的问题。keep-alive 使客户端到服务端的连接持续有效，当出现了后续请求时， keep-alive避免了建立或者重新建立。对于市面上大部分服务器keep-alive都被支持，但是对于负担较重的网站，保留的客户端会影响性能。 Accept：浏览器可以接受的MIME类型。 Accept：text/html, 如果不能接受将返回406错误 Cache-control: 指定请求和响应遵循缓存机制。缓存指令是单向的，且独立。 Accept-Encoding：浏览器生命可接受的编码方法，通常说明是否支持压缩。 Accept-Language：浏览器声明接受语言 Accept-Charset：浏览器可以接受的字符集，默认任何字符集都可以接收 User-agent：用于告诉HTTP服务器，客户端使用操作系统浏览器的名称和版本。 HTTP回应报文第一行是报头，第一个字段表明HTTP协议版本们可以直接以请求报文为准；第二个字段是status code， 也就是返回码，相当于请求结果 HTTPS在网络上，两个实体间的通信容易被窃听。 当你学习网络安全后、你发现网络再也不安全了 初级的防御手段，是双方都约定一个加密的算法，把加密后的数据进行传输，收到数据方再进行解密。这里涉及一个概念，对称加密和非对称加密 对称加密：对称加密是指加密秘钥和解密秘钥是一样的，通常有AES和TEA加密算法，它的特点是计算量小，有又一定的破解门槛。 非对称加密：加密的秘钥和解密的秘钥不一样，秘钥成对出现。加密解密使用不同的秘钥（公钥加密需要私钥解密，私钥加密需要公钥加密）它的特点是计算量大，常用的有RSA、ECC等算法。基于性能考虑，一般使用非对称加密得到秘钥， 再用对称秘钥进行加密。 HTTP协议可以轻松抓包并获取协议，是不安全的协议。而HTTPS是安全为目标的HTTP通道，简单来说是HTTP的安全版。 TLSTLS协议可用于保护运行于TCP之上的任何协议通信，如HTTP、FTP 等更高级的协议。最常见的是通过TLS来保护HTTP通信。 主要过程如下所述 客户端浏览器向服务器传送TLS协议的版本号、加密算法种类、产生的随机数以及其他信息 服务器向客户端传送TLS版本号、加密算法的种类、随机数及其他信息 客户端利用服务器传送的信息验证服务器的合法性，服务器的合法性包括：整数过期、CA是否可靠、发型整数是否能解开数字签名，如果验证不能通过，服务将断开；否则继续下一步 用户随机产生一个对称密码，然后用公钥进行加密，并传给服务器 【A】如果服务器要求客户端验证身份，用户生成一个随机数并签名一起传送 【A】如果服务器要求验证客户端身份，服务器检验客户整数和签名随机数的合法性。 服务器和客户端使用相同的主密码，即“通话密码”。 客户端向服务器发送信息，指明后续的通话使用7中的密码为对称秘钥 服务器相客户端发送信息，指明7中的密码为对称秘钥，握手结束 这样TLS的握手就结束了，TLS的安全通道数据通信开始，客户和服务器开始使用相同的秘钥进行通信。 这样基于TLS的HTTPS也有了这样的特点1。 客户端产生的秘钥只有客户端和服务器能得到 2 加密的数据只有客户端和服务器能得到明文 3 客户端到服务器的通信是安全的。 HTTP和HTTPS有以下区别 HTTPS协议需要CA申请证书，需要交费 HTTP是超文本传输协议，明文传输， HTTPS是ssl加密传输 80 和443 HTTP连接很简单，无状态， HTTPS经过SSL+HTTP协议构建的，加密传输、身份认证。 HTTPS耗性能，安全性要求低用HTTP CGICGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。 服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"进程","slug":"进程","date":"2019-02-15T13:48:56.000Z","updated":"2019-02-15T13:50:41.383Z","comments":true,"path":"2019/02/15/进程/","link":"","permalink":"http://yoursite.com/2019/02/15/进程/","excerpt":"进程程序与进程进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。 程序如何转换为进程？ 一般情况下linux下C++的生成分为四个阶段：预编译、编译、汇编、连接。编译器g++经过预编译、编译、汇编3个步骤将源程序将文件转换为目标文件。最后形成可执行程序。当程序执行时，操作系统将可执行程序复制到内存中 1 内核将程序将程序读入内存、为程序分配内存空间 2 内核为进程分配进程标识符（PID）及其他资源 3 内很为进程保存 PID 及其他信息，把进程放入运行队列中等待执行，程序转化为进城后就可以被调度执行。","text":"进程程序与进程进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。 程序如何转换为进程？ 一般情况下linux下C++的生成分为四个阶段：预编译、编译、汇编、连接。编译器g++经过预编译、编译、汇编3个步骤将源程序将文件转换为目标文件。最后形成可执行程序。当程序执行时，操作系统将可执行程序复制到内存中 1 内核将程序将程序读入内存、为程序分配内存空间 2 内核为进程分配进程标识符（PID）及其他资源 3 内很为进程保存 PID 及其他信息，把进程放入运行队列中等待执行，程序转化为进城后就可以被调度执行。 进程的创建与结束进程创建有两种方式：一种由操作系统创建，一种由父进程创建 系统启动时， 操作系统会创建一些进程，他们承担管理和分配系统资源的任务，这些进程被称为系统进程。系统允许一个进程创建新进程（子进程），子进程还可以创建新的进程，形成树型结构。整个linux的所有进程也是一个树形结构。树根由系统自动构造，即内核态下的0号进程，它是所有进程的祖先。0号进程创建1号进程，负责执行内核部分的初始化及系统配置，并创建告诉缓存和虚拟储存管理的内核线程。随后1号进程调用 execve() 运行可执行程序 init , 并演化成用户态的1号进程 它按照init/initab 的要求完成启动工作，创建若干终端注册进程getty() 用于用户的登录。 进程的创建 – forklinux系统允许任何一个用户创建子进程，创建成功后，子进程在系统中并独立于父进程。该子进程接受系统调度，与父进程有相同的权利。 12@include &lt;unistd.h&gt;pid_t fork(void); 父进程和子进程：除了0号进程，linux系统中其他任何一个进程都是其他进程创建的。而相对的 ，fork 函数的调用方是父进程， 而创建的新进程是子进程。 fork 函数不需要参数，返回值是一个进程标识符 1 对于父进程，fork函数返回创建子进程ID 2 子进程 fork 函数返回0 3 创建出错的话 fork 函数返回 -1 fork函数创建一个新的进程，并从内核中为其分配一个可用的进程标识符PID，之后为其分配进程空间，并将父进程空间的内容中复制到子进程空间， 包括数据段和堆栈段，和父进程共享代码段。这时候系统中多了一个进程父进程和子进程都接受系统的调度，fork函数返回两次（分别在父进程和子进程中返回）。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; pid_t pid; pid = fork(); if(pid&lt;0)&#123; perror(\"fail to fork\"); exit(-1); &#125;else if(pid ==0)&#123; printf(\"Subprocess, PID: %u\", getpid()); &#125;else&#123; printf(\"Parentprocess, PID: %u\", getpid()); &#125; return 0;&#125; 子进程和父进程共享数据段和堆栈段中的内容。例子略 事实上，子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是，子进程并未复制代码段，而是公用代码段。 进程的结束 – exit僵尸进程在linux中 正常情况下子进程是通过父进程创建的， 子进程和父进程的运行是一个异步的过程。父进程无法预料子进程在何时结束，于是就产生了孤儿进程和僵尸进程。 孤儿进程，是指一个父进程退出后，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1） 到进程所收养，并由init进程完成状态收集工作。 僵尸进程，是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被称为僵尸进程。 简单理解为，孤儿是父进程已退出而子进程未退出；而僵尸进程是父进程未退出而子进程先退出。 为了避免僵尸进程，需要父进程通过wait函数来回收子进程 守护进程linux系统中在系统引导时会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择开启的模式，这些模式叫做运行级别。守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。 守护进程是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。说话进程常常在系统引导装入时启动，linux系统有很多的守护进程，大多数服务都是通过守护进程实现的。如作业规划进程、打印进程。 在 linux 中每一个与用户交流的界面称为终端，每一个终端开始的进程都会依附于该终端，这个终端就被称为 进程的控制终端，当控制终端被关闭时，相应的进程都会被自动关闭。但是守护进程可以突破这种限制，它从被执行时开始运转，整个系统关闭时才推出。如果想让某个进程不因为用户或终端等变化受到影响，那么就需把一个进程变成一个守护进程。 创建一个守护进程的步骤如下所示： 1 创建子进程，父进程退出。 这是编写守护进程的第一步。由于守护进程脱离终端控制，因此在第一步完成后就会在终端里造成程序已经运行完毕的假象。之后所有的工作都在子进程完成，而与用户终端脱钩。 2 子进程中创建会话 这个步骤是创建守护进程最重要的一步，虽然他的实现十分简单，但是他的意义重大。这里使用的系统函数setid， 这里有两个概念：进程组和会话期 1) 进程组： 一个或多个进程的集合。进程组由进程组ID来唯一标识，除了进程号以外，进程组ID也是一个进程的必备属性，每个进程组都有一个组长进程，组长进程号等于进程组ID，而且进程组ID不会因为组成进程的退出而受到影响。 2) 会话周期： 会话期是一个或多个进程组的集合。通常一个会话开始于用户登录，终止于用户退出，再次期间运行的所有进程都输入这个会话期。 setid 函数用于创建一个新的会话，并担任该会话组的组长，调用 setid 有三个作用： 1 让进程摆脱原会话的控制 2 让进程摆脱原进程组的控制 3 让进程摆脱原控制终端的控制。 那么 创建守护进程为什么需要setid函数？ 这是由于创建守护进程的第一步掉用了fork函数来创建子进程，再将父进程退出。由于调用fork函数时子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但是会话期、进程组、控制终端等还没有改变，所以还不是真正意义上的独立。 3) 改变当前目录为根目录 这一步骤也是必要的步骤，使用 fork 创建的子进程集成了父进程的工作目录，由于进程的运行过程中当前的目录是不能卸载的，这对于以后的使用造成诸多麻烦。通常的做法是将 “/” 变为守护进程的当前工作目录，这样就可以避免上述问题。 4) 重设文件权限掩码 文件权限掩码是指屏蔽掉文件权限中的对应位。 5) 关闭文件描述符 同文件权限码一样， 用fork函数创建的子进程会从父进程哪里继承一些已经打开的文件，这些文件节能永远不会被守护进程读写，但是他们一样消耗系统资源。所以需要关闭来自继承的文件描述符。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define MAXFILE 65535int main()&#123; pid_t pc; int i, fd, len; char* buf = \"this is a Dameon\\n\"; len = strlen(buf); pc = fork(); if(pc&lt;0)&#123; printf(\"error fock\\n\"); exit(1); &#125;else if(pc&gt;0)&#123; exit(0); &#125; setsid(); chdir(\"/\"); umask(0); for(int i=0; i&lt;MAXFILE; i++)&#123; close(i); &#125; while(1)&#123; if(fd = open('/temp/demeon.log',O_CREAT|O_WRONLY|O_APPEND,0600))&lt;0)&#123; perror(\"open\"); exit(1); &#125; write(fd, buf, len+1); close(fd); sleep(10); &#125; return 0;&#125;","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"多线程编程(C++)","slug":"多线程编程-C","date":"2019-01-31T03:54:56.000Z","updated":"2019-01-31T03:56:40.868Z","comments":true,"path":"2019/01/31/多线程编程-C/","link":"","permalink":"http://yoursite.com/2019/01/31/多线程编程-C/","excerpt":"多线程早期计算机只允许一个程序独占资源，一次只能执行一个程序。计算力是一种宝贵的资源。 这种背景下，多程序并发执行的需求十分迫切，由此产生了进程的概念。进程在多数早期操作系统中是执行工作的基本单元。进程是包含程序和资源的集合，每个程序与其他程序一起参与调度，竞争CPU、内存等系统资源。每次进程切换都存在资源的保存和恢复，这被称为上下文切换。进程的引入解决了多用户支持的问题，但是产生了新的问题：进程频繁切换引起的额外开销严重影响系统性能。进程通信要求复杂的系统级实现。 例如一个简单的GUI任务，通常一个任务支持界面交互、一个任务支持后台运算。如果每个任务都由一个进程来实现会相当的低效。对每一个进程来说，系统资源看上去都是独占的，比如内存空间。这样演化利用分配给统一个进程实现多个任务的方法。同一个进程内部的线程共享进程的所有资源。共享这些内存空间，比如定义个全局变量，A将其赋值为1，B看到这个变量也是1。线程很方便的支持了进程内部的并发，避免了频繁切换的开销。","text":"多线程早期计算机只允许一个程序独占资源，一次只能执行一个程序。计算力是一种宝贵的资源。 这种背景下，多程序并发执行的需求十分迫切，由此产生了进程的概念。进程在多数早期操作系统中是执行工作的基本单元。进程是包含程序和资源的集合，每个程序与其他程序一起参与调度，竞争CPU、内存等系统资源。每次进程切换都存在资源的保存和恢复，这被称为上下文切换。进程的引入解决了多用户支持的问题，但是产生了新的问题：进程频繁切换引起的额外开销严重影响系统性能。进程通信要求复杂的系统级实现。 例如一个简单的GUI任务，通常一个任务支持界面交互、一个任务支持后台运算。如果每个任务都由一个进程来实现会相当的低效。对每一个进程来说，系统资源看上去都是独占的，比如内存空间。这样演化利用分配给统一个进程实现多个任务的方法。同一个进程内部的线程共享进程的所有资源。共享这些内存空间，比如定义个全局变量，A将其赋值为1，B看到这个变量也是1。线程很方便的支持了进程内部的并发，避免了频繁切换的开销。 多线程一个程序的运行中，只有一个控制权存在。但函数被调用时，该函数获得控制权成为激活函数，各个函数像是连在一条线上，计算机流水线执行操作，这样叫做单线程序。 多线程就是允许一个进程存在多个控制权，同时有多一个函数处于激活状态。单线程中函数会被压栈，只有栈顶函数被调用，而多线程则会在内存中存在多个栈。 多线程的创建与结束线程的创建与结束 123#include &lt;pthread&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_t 实际上就是 unsigned long int . 第一个参数指向线程标识符，第二个参数设置线程属性，第三个参数是线程运行函数的起始地址， 最后一个参数是运行函数的参数。 若创建成功则返回0， 否则返回错误号。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;struct arg_type&#123; int a; char b[100];&#125;;void* say_hello(void* args)&#123; arg_type arg_temp = *(arg_type*)args; printf(\"hello from thread, info: %d, %s\\n pthread=%lu\\n\",arg_temp.a, arg_temp.b, pthread_self()); pthread_exit((void*)1);&#125;int main()&#123; pthread_t tid; arg_type arg_temp; arg_temp.a = 10; char temp[100] = \"To be number one\"; strncpy(arg_temp.b, temp, sizeof(temp)); int iRet = pthread_create(&amp;tid, NULL, say_hello, &amp;arg_temp); if(iRet)&#123; printf(\"pthread_create error\"); return iRet; &#125; printf(\"Thread id in process: %lu\\n\", tid); void *retval; iRet = pthread_join(tid, &amp;retval); if(iRet)&#123; printf(\"pthread_join error\"); return iRet; &#125; printf(\"retavl\\n\"); return 0;&#125; 线程的属性线程有一组属性可以在线程被创建时指定，该属性封装在一个对象中，对象的类型为pthread_attr_t 属性值不能直接设置，必须使用相关的函数操作，这个函数必须在 pthread_create 之前调用并通过pthread_attr_destory释放，主要属性包括：作用域、栈尺寸、栈地址、优先级、分离状态、调度策略和参数。 POSIX.1 之定义一系列属性，主要如下表 分离状态：若线程终止，线程处于分离状态，系统不保留线程的终止状态；当不需要线程的终止状态时，可以分类线程。 栈地址：设置和获取线程的栈地址 栈大小：系统中有很多线程时，可能需要减少每个线程栈的默认大小，防止进程的地址空间不够用。 栈保护区大小：在线程顶留出一段空间，防止栈溢出。 线程优先级，新线程的默认优先级是0 继承父进程的优先级：新线程不继承父进程的优先级 调度策略 争用范围 线程并行级别，POSIX 标准定义了3中调度策略：先入先出策略（FIFO）、循环策略（RR）和自定义策略（OTHER）。FIFO是基于队列的调度程序，对于每个优先级使用不同的队列。 FIFO ：如果继承具有有效的用户ID为0，则争用范围为系统的先入先出属于实时调度类，如果这些线程未被更高级的线程抢占，则会继续处理该线程，直到线程放弃或阻塞为止。 多线程同步多线程相当于一个并发系统，一般通知执行多个任务，如果多个任务可以共享资源，就需要解决同步问题。 线程火车票 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;int total_ticket_num = 20;void *sell_ticket(void *arg)&#123; int id = *(int*)arg; for(int i=0; i&lt;20; i++)&#123; if(total_ticket_num &gt; 0)&#123; sleep(1); printf(\"from id: %d, sell the tikect %dth ticket\\n\", id, 20-total_ticket_num+1); total_ticket_num--; &#125; &#125; return 0;&#125;int main()&#123; int iRet; pthread_t tids[4]; int i = 0; for(int i=0; i&lt;4; i++)&#123; sleep(1); int iRet = pthread_create(&amp;tids[i], NULL, &amp;sell_ticket, &amp;i); if(iRet)&#123; printf(\"pthread_create error, iRet=%d\\n\",iRet); return iRet; &#125; &#125; sleep(1); void *retval; for(int i=0;i&lt;4;i++)&#123; iRet = pthread_join(tids[i], &amp;retval); if(iRet)&#123; printf(\"pthread_join error, iRet=%d\\n\",iRet); return iRet; &#125; printf(\"retval=%ld\\n\", (long)retval); &#125; return 0;&#125; 事实上，如果只有一个线程执行上面的程序，没有问题。但是如果多个线程都执行就会出现问题。其根本原因在于各个线程都可以对 total_ticket_num 进行写入。 这里if会判断是否有剩余票，如果有则卖。但是不同的线程之间会存在时间窗口，其他线程可能在这个窗口进行卖票操作，导致卖票的条件不成立，但是线程已经进行了判断，所以无法知道 total_ticket_num 发生了变化。 在并发的情况下，指令的先后顺序由内核决定。同一个线程内部指令按照先后顺序执行，但不同的线程很难说哪一个先执行。如果运行的结果依赖于不同线程执行的先后顺序，就会造成竞争条件。这样条件下计算机的计算结果未知。所以应该避免竞争条件的形成。 对于多线程程序来说，同步是指在某一定时间内只允许一个线程访问资源。可以通过互斥锁、条件变量、读写锁和信号量来同步资源。 同步锁互斥锁 是一个特殊的变量，他有lock和unlock两个状态。互斥锁一般被设置为全局变量。打开的互斥锁可以由某个线程获得，一旦获得互斥锁会被锁上，只有该线程有权打开。 火车票系统的互斥系统可以被这样表示 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;pthread_mutex_t mutex_x = PTHREAD_MUTEX_INITIALZER;int total_ticket_num = 20;void *sell_ticket(void *arg)&#123; int id = *(int*)arg; for(int i=0; i&lt;20; i++)&#123; pthread_mutex_lock(&amp;mutex_x); if(total_ticket_num &gt; 0)&#123; sleep(1); printf(\"from id: %d, sell the tikect %dth ticket\\n\", id, 20-total_ticket_num+1); total_ticket_num--; &#125; pthread_mutex_unlock(&amp;mutex_x); &#125; return 0;&#125;int main()&#123; int iRet; pthread_t tids[4]; int i = 0; for(int i=0; i&lt;4; i++)&#123; sleep(1); int iRet = pthread_create(&amp;tids[i], NULL, &amp;sell_ticket, &amp;i); if(iRet)&#123; printf(\"pthread_create error, iRet=%d\\n\",iRet); return iRet; &#125; &#125; sleep(1); void *retval; for(int i=0;i&lt;4;i++)&#123; iRet = pthread_join(tids[i], &amp;retval); if(iRet)&#123; printf(\"pthread_join error, iRet=%d\\n\",iRet); return iRet; &#125; printf(\"retval=%ld\\n\", (long)retval); &#125; return 0;&#125; 第一个执行pthread_mutex_lock()的线程会首先获得mutex_x ，其他线程必须等待，直到第一个线程释放后，其他线程才可以获得锁并继续执行。 条件变量互斥是线程程序必备的工具，但是并非万能。例如，如果线程等待共享数据某个条件出现，它可能重复对互斥对象锁定和解锁，每次都会检查共享数据结构，这样查询效率很低。 每次检查之间，可以使线程短暂的进入睡眠，但是这样无法立即响应。真正需要的一种方法是：当线程满足某些条件时使得线程进入睡眠状态，一旦条件满足就唤醒睡眠的线程。这正是条件变量的任务。 条件变量通过允许线程阻塞和等待另一个线程信号方法弥补互斥锁的不足，他常常和互斥锁一起使用。使用时条件变量被用于阻塞一个线程，一旦某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个阻塞的线程，这些线程会重新测试是否满足条件。 条件变量例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;using namespace std;pthread_cond_t qready = PTHREAD_COND_INITIALIZER;pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;int x = 10;int y = 20;void *func1(void* args)&#123; cout&lt;&lt;\"func1 start\"&lt;&lt;endl; pthread_mutex_lock(&amp;qlock); while(x&lt;y)&#123; pthread_cond_wait(&amp;qready, &amp;qlock); &#125; pthread_mutex_unlock(&amp;qlock); sleep(3); cout&lt;&lt;\"func1 end\"&lt;&lt;endl;&#125;void *func2(void* args)&#123; cout&lt;&lt;\"func2 start\"&lt;&lt;endl; pthread_mutex_lock(&amp;qlock); x = 20; y = 10; cout&lt;&lt;\"has change x and y\"&lt;&lt;endl; pthread_mutex_unlock(&amp;qlock); if(x&gt;y)&#123; pthread_cond_signal(&amp;qready); &#125; cout&lt;&lt;\"func2 end\"&lt;&lt;endl;&#125;int main()&#123; pthread_t tid1, tid2; int iRet; iRet = pthread_create(&amp;tid1, NULL, func1, NULL); if(iRet)&#123; cout&lt;&lt;\"pthread 1 create error\"&lt;&lt;endl; return iRet; &#125; sleep(2); iRet = pthread_create(&amp;tid2, NULL, func2, NULL); if(iRet)&#123; cout&lt;&lt;\"pthread 1 create error\"&lt;&lt;endl; return iRet; &#125; sleep(10); return 0;&#125; 读写锁某些程序存在读者写者问题，对某些资源的访问可能有两种情况，一种是排他性的，必须独占，这被称为写操作；一种是可以共享的，被称为读操作。 读写锁比互斥锁具有更高的适应性与并行性，可以有多个线程同时占用读写锁，但是只有一个线程占用写模式的读写锁。 当读写锁是 写加锁 状态时，其他试图加锁的程序都会被阻塞 当读写锁在 读加锁状态是，所有读模式加速线程可以被授权，但是写模式加锁会被阻塞 读写锁在 读加锁 模式时，如果有试图写加锁的请求，后续的读模式会被阻塞， 以避免长期的读模式占用，而 等待写模式的请求则长期阻塞。 读写锁最适用于对数据 读操作多于写操作的场合，应为读模式可以共享，而写模式只能由某个线程独占，因而读写锁也叫 共享-独占锁。 处理读者、写者问题两种常见的步骤是强读者同步和强写者同步。强读者同步给于读更高的优先权，强写着同步给与写更高的优先权。航班订票–强写者同步 图书馆查询–强读者同步 读写者例子 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define THREADNUM 5pthread_rwlock_t rwlock;void *readers(void *args)&#123; pthread_rwlock_rdlock(&amp;rwlock); printf(\"reader %ld got the lock\\n\", (long)args); pthread_rwlock_unlock(&amp;rwlock); pthread_exit((void*)0);&#125;void *writers(void *args)&#123; pthread_rwlock_wrlock(&amp;rwlock); printf(\"reader %ld got the lock\\n\", (long)args); pthread_rwlock_unlock(&amp;rwlock); pthread_exit((void*)0);&#125;int main()&#123; int iRet, i; pthread_t writer_id, reader_id; pthread_attr_t attr; int nreadercount = 1, nwritercount = 1; iRet = pthread_rwlock_init(&amp;rwlock, NULL); if(iRet)&#123; printf(\"ERROR\"); return iRet; &#125; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); for(int i=0; i&lt;THREADNUM; i++)&#123; if(i%3)&#123; pthread_create(&amp;reader_id, &amp;attr, readers, (void*)nreadercount); printf(\"create reader %d\\n\", nreadercount++); &#125;else&#123; pthread_create(&amp;reader_id, &amp;attr, writers, (void*)nwritercount); printf(\"create writer %d\\n\", nwritercount++); &#125; &#125; sleep(5); return 0;&#125; 信号量线程还可以通过信号量通信，信号量和互斥锁的区别: 互斥锁只允许 一个线程进入临界区，而信号量允许多个线程进入临界区，原理同互斥锁 多线程重入前面介绍的各种同步方式，其实就是为了解决“函数不可重入”问题。所谓“可重入”函数是指多于一个任务并发使用而不必担心错误的函数。而不可重入函数只能由一个函数独占，除非确保函数互斥。 可重入函数有以下特点 不为连续调用持有静态数据 不返回指向静态的指针 所有的户数都由函数的调用者提供 使用本地数据，或者通过制作全局数据的本地副本来保护全局数据 如果必须访问全局变量，利用互斥锁、信号量来保护全局变量 绝不调用任何不可重用函数 不可重用函数有以下特点 函数中存在静态变量，无论是全局还是局部静态变量 函数返回静态变量、 函数中掉用了不可重用函数 函数体使用了静态数据结构 函数体掉用了malloc或free函数 函数体内掉用了其他标准的IO函数","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"网络IO模型","slug":"网络IO模型","date":"2019-01-17T13:25:57.000Z","updated":"2019-01-17T13:28:02.439Z","comments":true,"path":"2019/01/17/网络IO模型/","link":"","permalink":"http://yoursite.com/2019/01/17/网络IO模型/","excerpt":"网络IO模型IO是计算机体系中重要的一部分。IO有两种操作，同步IO和异步IO。同步IO是指必须等待IO操作完成后控制权才能返回给用户进程。异步IO指的是，无需等待IO操作完成，就将控制权返回给用户进程。 网络中的IO常见如下情况： 输入操作：等待数据到达套接字接受缓冲区 输出操作：等待套接字发送缓存区有足够的空间容纳将要发送的数据 服务器接受连接请求：等待新的用户请求到来 客户端发送连接请求：等待服务器送回客户SYN对应的ACK","text":"网络IO模型IO是计算机体系中重要的一部分。IO有两种操作，同步IO和异步IO。同步IO是指必须等待IO操作完成后控制权才能返回给用户进程。异步IO指的是，无需等待IO操作完成，就将控制权返回给用户进程。 网络中的IO常见如下情况： 输入操作：等待数据到达套接字接受缓冲区 输出操作：等待套接字发送缓存区有足够的空间容纳将要发送的数据 服务器接受连接请求：等待新的用户请求到来 客户端发送连接请求：等待服务器送回客户SYN对应的ACK 4种IO模型1. 阻塞IO模型在Linux中，默认所有的socket都是阻塞的。 阻塞和非阻塞的概念描述的是用户线程调用内核IO的操作方式：阻塞是指IO操作彻底完成后才返回到用户空间，非阻塞是指IO调用后立即返回给用户一个状态值。 当进程调用了recvform这个系统调用后，系统内核开始了IO的第一阶段，准备数据。对于网络IO来说，很多数据在一开始没到达时(还没收到一个完整的TCP包) 系统内核等待数据的到来。而用户进程整个会被阻塞。阻塞IO模型的特点就是在 IO执行的两个阶段（等待数据、拷贝数据）被阻塞。 大部分socket接口都是阻塞型的。所谓阻塞型是指系统调用不返回结果，让当前线程一直阻塞。这给网络编程带来了一个重要的问题，如果调用send()时，线程处于阻塞状态，无法响应任何网络请求。 一个简单的改进方案是在服务器端使用多线程。多线程目的是让每个链接都拥有独立的线程。这样一个阻塞的连接不会影响其他连接。传统意义上进程开销远大于线程，所以客户端较多时多线程，单个服务占用资源较多选择安全的多进程。pthread_create()创建新线程，fork() 创建新进程 在socket设计之初，一个句柄就可以被accept()多次。 1int accept(int fd, struct sockaddr *addr, socklen_t *addrlen) 调用accept正是从 请求队里中抽出第一个连接信息，创建一个与fd同类的新socket返回句柄。如果当前没有请求，accept便会阻塞至有新的请求进入。 上述多线程的服务器模型似乎完美解决了多个客户机应答的需求，但是并不是这样。这主要是因为相应成千上百路的需求对于多进程、多线程都会严重占用系统资源。即使是考虑到线程池和连接池。 线程池旨在降低创建和销毁线程的频率，维护一定数量的线程，并让空闲的线程重新承担新的执行任务。 连接池位置连接的缓存池，尽量重用已有的连接，降低创建和关闭连接 的频率。 这样两种方法广泛应用于大型系统，然而池终有上限，当请求大大超过上限时，池效果并不好。现实中面临上千、上万次的用户请求，多次按成模型会遇到瓶颈。 2. 非阻塞IO模型Linux下可以设置socket使其为非阻塞状态。 如图所示，当用户发出read操作时，如果内核数据还没准备好，它不会block用户进程而是返回一个错误。从用户进程角度讲，read后不需要等待而是得到一个结果。当用户进程判断其为错误时，就知道它还没准备好，这样便可以再次read操作。 所以非阻塞IO中，用户需要不断询问kernel是否准备好数据。 1fcnt1(fd, F_SETFL, O_NONBLOCK); 在非阻塞状态下recv()被调用后立即返回。 recv()大于0表示数据接收完毕，返回接收字节数。0表示断开；-1表示没完成或系统错误。 实际操作系统提供了更高效的接口，例如 select() 多路复用 3. 多路IO复用模型多路IO复用有时也被称为事件驱动IO，它的基本原理是有一个函数（select）不断的轮询所有的（socket），当某个socket数据到达了，就通知用户进程。 当用户调用了select，那么整个进程会被阻塞，而同时内核会监视所有的socket，当某一个socket数据准备好了，select就会返回。这个时候用户进程再进行read操作将数据从内核拷贝到用户进程。 这个模型其实和阻塞IO没有太大的区别，事实上还更冗余，因为需要调用两个系统调用（select、recvfrom）而阻塞IO只需要调用一个 recvfrom 即可。但是select优势在于它可以处理多个连接。多以如果连接数并不高的情况下，select、epoll 不一定比阻塞IO的性能更好。 多路IO复用中，每一个socket一般都设置为非阻塞，而整个用户进程其实是被阻塞的，只不过进程是被select这个进程阻塞，而不是被socket IO阻塞。 这种模型的特征在于每个周期探测一次或一组事件，一个特定的时间会出发某个特定的响应，也被称为“事件驱动模型”。相比其他模型，select() 事件只用单线程执行、占用资源少，不消耗太多CPU资源，同时能为多客户端提供服务。 但是这个模型有很多问题，首先select() 接口本身需要消耗时间去轮询句柄，很多操作系统提供了更方便的接口 Linux 是 epoll BSD提供了 kqueue 4. . 异步IO模型 当用户发起read操作后，立刻就去其他工作；另一个方面，内核收到一个请求后会立刻返回。然后内核等待数据准备完成，然后拷贝到用户内存中，再向用户进程发送一个信号。 调用阻塞IO会一直阻塞IO直到操作完成，而非阻塞IO在内核准备数据的情况下就会立刻返回。二者的区别在于同步IO进行IO时会阻塞进程。按照这个定义，阻塞IO、非阻塞IO、多路IO复用都属于同步IO。 selectselect函数是socket编程中一个重要的函数，可以完成非阻塞工作程序，可以监视文件描述符的变化情况。 1int select(int maxfdp, fdp_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval* timeout); 这里涉及到两个结构体 fd_set 和 timeval 这个里fd_set理解为一个集合，存放文件描述符，及文件句柄。当然UNINX下任何设备、管道、FIFO都是文件形式，所以socket 就是一个文件。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"TCP API","slug":"TCP-API","date":"2019-01-17T13:22:03.000Z","updated":"2019-01-17T13:25:26.173Z","comments":true,"path":"2019/01/17/TCP-API/","link":"","permalink":"http://yoursite.com/2019/01/17/TCP-API/","excerpt":"TCP 网络编程API网络通信概要网络进程如何通信？首要解决如何标识一个进程，本地可以用PID来解决，而网络中用IP+端口号来唯一标识一个进程。这样利用(IP、端口号、PID)可以唯一标识一个网络中的进程。 socket起源于UNINX，UNINX哲学之一就是一切皆文件，有一个打开、读写、关闭的模式来操作。socket就是该模式的一个实现，socket就是一种特殊的文件。 使用TCP/IP的协议应用程序采用应用编程接口 UNINX BSD关键字来实现网络进程通信，目前几乎所有的应用程序都是使用socket，网络通信无处不在。其基本模式包括：","text":"TCP 网络编程API网络通信概要网络进程如何通信？首要解决如何标识一个进程，本地可以用PID来解决，而网络中用IP+端口号来唯一标识一个进程。这样利用(IP、端口号、PID)可以唯一标识一个网络中的进程。 socket起源于UNINX，UNINX哲学之一就是一切皆文件，有一个打开、读写、关闭的模式来操作。socket就是该模式的一个实现，socket就是一种特殊的文件。 使用TCP/IP的协议应用程序采用应用编程接口 UNINX BSD关键字来实现网络进程通信，目前几乎所有的应用程序都是使用socket，网络通信无处不在。其基本模式包括： 服务器根据地址类型（IPV4、IPV6）创建socket 服务器为socket绑定IP地址和端口号 服务器socket监听端口号请求，随时准备接受客户端的连接，这时候服务器socket并未打开 客户端创建socket 客户端打开socket，根据服务器IP和端口号试图连接服务器socket 服务器socket接收到客户端socket请求，被动打开开始接受客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态 客户端连接成功，向服务器发送连接状态信息 服务器accept方法返回，连接成功。 服务器向socket写入信息 服务器读取信息 客户端关闭 服务器关闭 仔细研究会发现，服务器和客户端连接的部分就是三次握手。 网络编程API1. socket函数1int socket(int domain, int type, int protocol) socket 函数对应于普通文件的打开操作，普通文件返回一个描述字，而socket创建一个socket描述符，它唯一标识一个socket。 当调用socket时, 返回的描述他存在与协议族空间中，但是没有具体地址，如果想要赋予地址需要使用bind()函数。如果不绑定，系统会在使用时随机生成一个。 2. bind函数bind() 函数把一个地址族中特定的地址赋给socket 1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) 3. listen 和 connect 函数这两个函数相对应，服务器调用listen函数来监听端口，而客户端调用connect函数去发出连接请求 12int listen(int sockfd, int backlog)int connect(int sockfd, const struct sockaddr *addr, docklen_t addrlen) 4. accept 函数TCP 服务器依次调用socket()、bind()、listen()之后，就会监指定的socket地址了。而TCP客户端调用socket()、connect()之后就会向TCP服务器发送一个连接请求。TCP连接接收到这个请求之后，就会调用accept()函数接受请求，这样连接就建立了。 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) 注意：accept第一个参数为socket描述字，服务器调用socket生成的，称为监听socket关键字；而accept返回的是已连接socket关键字。一个服务器通常只创建一个监听socket描述字，这个描述子在服务器生命周期一直存在。内核为每个服务器接受的客户创建一个已连接socket关键字，当完成服务后就会关闭。 5. read 和 write 函数read()函数从fd中读取内容，write写入内容。成功时返回字节数 6. close函数1int close(int fd); TCP 协议选项1. SO_REUSEADDR一般来说一个端口释放后，大约两分钟才能再次使用（处于TIME_WAIT状态），而使用该选项可以使端口被释放后立即被使用（处于TIME_WAIT状态的端口）。 2. TCP_NODELAY/TCP_CHORK网络拥塞领域，有一个非常著名的算法叫做Nagle算法， 这是以其发明人的名字命名的。John Nagle 首次用该算法解决福特公司的网络拥塞问题。该问题具体描述是：如果应用程序每次产生1Byte的数据，而这个1Byte的数据又以数据报的形式发送给网络服务器，那么很容易使得网络过载。所以传送1Byte的包却要花费40Byte的包头（IP20字节、TCP20字节）这种有效载荷利用低下的情况被称为愚蠢窗后症候群。 针对这问题，Nagle算法改进：如果发送少量字符包（小于MSS的包被称为小包，大于MSS的包被称为大包）发送端只会发送第一个小包，将后面的小包缓存起来。直到接收到前一个数据报的ACK为止，或当前字符较紧急，积攒了较多的数据。 TCP中Nagle算法默认启用，但是不使用任何情况。而TCP_NODELAY/TCP_CHORK字段控制了包的Nagle化。例如TCP_NODELAY便是直接把包发出去，这样用户体验会更好。 3. SO_LINGERlinger是延缓的意思，这里的延缓指close操作。默认close立即返回，但是当缓冲区还有部分数据时，系统会尝试将数据发送给对方。 4. TCP_DEAFER_ACCPET实际上是接收到第一个数据包后，才会创建连接 5.SO_KEEPALIVESO_KEEPALIVE用来检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入 设置该选项后，如果2h内任何一方没有数据交换，TCP就会自动向对方发送一个保持存活探测， 对方接受正常，以ACK回应 对方已崩溃且重新启动，以RST响应，套接口错误置为restart，套接口本身被关闭 对方无响应，再次发送8个探测分节，11min15s 后无响应就放弃。 网络字节序与主机序关于字节序再次讨论。不同的CPU有不同的字节序类型，这些字节序是整数在内存中的保存顺序，称为主机序。最常见的两种 1 小端， 低序的字节存在起始位置 2 大端 ， 高字节的存在起始位置 小端法 地址低位存在值的低位，高位存值的高位。这种方式符合人的思维方式。 大端法 地址低位存高位的值。它很直观不需要考虑对应关系，只需要内存地址写出去即可 为什么要注意字节问题呢？C++编译平台的储存是由编译平台的CPU确定的，而JAVA编写的程序唯一采用大端法。所有网络协议都是大端法。其也被称为网络字节序。 封包和解包TCP是一个流协议，所谓流就行没有界限的一串数据。但是通信程序是需要独立的数据包发送。 设想这样几种情况 先接收到data1 后接到 data2 先接收到data1 的部分数据，后接到data1的余下部分与 data2全部 先接收到了data1全部数据和部分data2数据，后接受到data余下数据 一次接受data1和data2全部数据 1是理想情况 而2、3、4即使粘包的情况，这时就需要拆包将受到的数据拆成独立的数据包。这种情况可能有这么几种原因。 1 由Nagle算法造成的粘包 2 接收端不及时接受造成的粘包 具体的解决办法便是封包和拆包。封包是给一段数据加上包头，这样数据就分为包头、包体两部分。包头包含了一个结构体成员变量表示了包体的长度，这样另一方便可以通过这个长度进行拆包；","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"编译与调试（C++）","slug":"编译与调试（C-）","date":"2019-01-03T14:07:57.000Z","updated":"2019-01-03T14:15:34.969Z","comments":true,"path":"2019/01/03/编译与调试（C-）/","link":"","permalink":"http://yoursite.com/2019/01/03/编译与调试（C-）/","excerpt":"[TOC] 编译g++ helloworld.cpp 命令被分为四个步骤，预处理、编译、汇编、链接 编译与链接 预处理首先是源码相关和头文件，如iostream被预处理其处理成一个.i 文件，第一步相当于该命令 1g++ -E helloworld.cpp -o hellword.i 其中-E表示只进行预编译，直接输出预编译结果 预处理命令主要处理以#开头的预编译命令，如#include #define 将所有的#define删除， 展开所有的宏定义 处理所有的条件编译指令 #if、#elif、#else、endif 处理#include预编译指令，将文件插入指定位置 过滤注释内容 添加行号标识，一遍编译器调试时产生行号信息 保留所有的#progama指令","text":"[TOC] 编译g++ helloworld.cpp 命令被分为四个步骤，预处理、编译、汇编、链接 编译与链接 预处理首先是源码相关和头文件，如iostream被预处理其处理成一个.i 文件，第一步相当于该命令 1g++ -E helloworld.cpp -o hellword.i 其中-E表示只进行预编译，直接输出预编译结果 预处理命令主要处理以#开头的预编译命令，如#include #define 将所有的#define删除， 展开所有的宏定义 处理所有的条件编译指令 #if、#elif、#else、endif 处理#include预编译指令，将文件插入指定位置 过滤注释内容 添加行号标识，一遍编译器调试时产生行号信息 保留所有的#progama指令 编译编译过程就是将文件进行一列的词法分析、语法分析、语义分析及优化产生汇编代码文件，这往往是程序最复杂的部分 1g++ -S helloworld.i -o helloworld.s 编译器将高级语言翻译成机器语言的一个工具，编译过程大致有以下几部分 链接每个源代码模块独立的编译，然后按要求组装起来，这个过程就是链接。链接的主要部分就是把各个模块之间的部分处理好，使得各个模块可以正确的衔接。 最基本的链接过程如图所示，每个模块的源代码文件经过编译器编译成目标文件，目标文件和库一起链接成可执行文件。 库其实就是一组文件的包，一些代码编译成目标文件后打包存放。 每个目标文件除了自己的数据和二进制代码外，还提供三个表，未解决符号表、导出符号表、地址重定向表 未解决符号表 编译单元里引用但是定义不在本编译单元定义 导出符号表 对本单元定义，愿意给其他单元使用的符号和地址 地址重定向表 本编译单元对自身地址的引用 extern 声明置入未解决符号表，不置入导出符号表 static 属于内部链接 静态链接链接分为静态链接和动态链接。对函数库的链接放在编译使其完成的 是静态链接。所有相关的目标文件与涉及到的函数被链接合成一个可执行文件。程序运行时与函数库毫无关系。因为所有需要的函数已经被复制到相应位置，这些函数被称为静态库，通常命名为libxxx.a 动态链接除了静态链接、也可以把一些库函数链接载入推迟到运行使其，这就是动态链接库。动态库文件名规范和静态库类似，动态库的扩展名为so， 静态链接和动态链接的区别 动态链接库利于进程资源共享 当某个程序在运行中调用某个动态链接库函数时，操作系统会在内存中寻找库函数的拷贝。这样虽然带来一些动态链接的开销，却大大节省了内存资源。C语言标准库就是动态链接库，所有程序共享一个C语言标准库的代码段，而静态链接库则不同，系统中每个静态链接库都需要拷贝到自己的代码段，这样更耗费内存。 程序的升级更简单 如果库发生变化，使用库需要重新编译。使用动态库，只要动态库的接口没变，只需要更换动态库 链接载入程序员控制 由于静态库是编译时，库函数装到程序中，静态库会快一些 调试strace系统调用 为了创建文件、进程、复制文件、应用程序必须和操作系统交互。但是应用程序不能直接访问linux内核。它不能访问内核的内存、也不能调用内核函数。这样就需要操作系统上的内建函数，被称为系统调用 strace通过跟踪系统调用让开发知道程序在后台做的事 strace查看系统调用 gdbgdb 是 gcc 的调试工具 1自定义随心所欲的运行程序 2 可以让被调试的程序在断点停住 3 程序停住时可以检查程序的运行状态 4 动态改变程序环境 TOP PSLinux中 ps列出当前的进程快照, kill 用于杀死进程 linux上进程有5种状态 运行 R（正在运行或队列中等待） 中断 S（休眠、受阻、在等待某个条件的形成或接受信号） 不可中断 D（收到信号不唤醒、不可运行） 僵死 Z（进程已终止，但是进程描述符仍存在，知道父进程调用wait4（）释放） 停止 T（进程收到信号后停止运行） valgrindvalgrind 是一套linux下开放源代码的仿真调试工具，它模拟了一个CPU环境，并给其他服务提供插件 Memcheck 这是运用最广泛的工具，一个重量级的内存检查器，发现大多数的内存错误使用情况。 callgrind 收集程序的运行数据，建立函数调用关系图 cachegrind 检查程序中缓存出现的问题，模拟CPU的一级、二级缓存 Helgind 检查多线程的竞争问题 寻找多个线程访问而没有一贯加锁的区域。 Massif堆栈分析器，测量堆、栈的大小 Extension 。。。 Linux 程序内存空间布局下图是一个典型的内存空间布局 代码段 通常指存放程序执行代码的一块内存区域。这部分大小在程序运行前已经确定，并且内存区域只读，某些架构也允许可写 初始化数据段，存放程序中已初始化的全局变量 未初始化数据段， 未初始化全局变量的一块区域 堆 堆用于储存程序运行时动态分配的内存段，它的大小不确定，可以动态的扩张或缩减，程序调用malloc及free来动态分配内存，当进程调用malloc、free时，新配的内存被动态添加到堆上或删去 栈 存放程序的局部变量，并且用户函数调用的传参和返回 堆栈的区别1 申请方式不同 栈： 系统自动分配，声明在函数中一个局部变量；系统自动在栈中为其分配空间 堆： 需要程序员自己申请。并指明大小 2 申请后系统的相应不同 栈： 只要栈的剩余空间大于申请空间，系统便提供内存，否则报异常 堆： 操作系统有一个记录空闲内存的链表，系统受到申请会遍历链表去找一块内存，从空间链表中删去，并将剩下的空间再放回去。 3 申请大小的限制不同 栈： 栈向低地址扩展，是一块连续的区域，栈顶的地址和栈的最大容量是系统规定好的 堆： 堆是低地址向高地址扩展，不连续的内存区域 4 申请效率不同 栈由系统自动分配，速度较快，程序员无法控制 堆是由new分配、速度慢，容易产生碎片，但是方便 5 堆栈存储内容不同 栈： 函数调用时，第一个进栈的是主函数中的下一条指令，然后是各个参数。 堆： 一般在堆的头部用一个字节存放大小，堆中的内容程序员安排","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"TCP(二轮复习)","slug":"TCP-二轮复习","date":"2019-01-03T13:48:07.000Z","updated":"2019-01-03T14:07:18.514Z","comments":true,"path":"2019/01/03/TCP-二轮复习/","link":"","permalink":"http://yoursite.com/2019/01/03/TCP-二轮复习/","excerpt":"网络模型1 七层网络模型国际标注化组织ISO于1981年 正式推荐了一个网络体系结构–七层参考模型，也被叫做开放系统互连模型 这七层网络模型在传输过程中还会对数据进行封装，过程如图所示 在ISO七层网络模型中，当一台主机需要传送用户数据时，数据先进入应用层。在应用层中，数据被加上应用层报头（AH），形成应用层协议数据单元（PDU），然后被递交到表示层。表示层不关心上层应用数据格式而是把整个数据包看成一个整体（应用层数据）进行封装，及加上表示层报头（PH）。下层分别加上自己的报头，其中数据链路层还会封装一个链尾，形成一帧数据。 当一帧数据通过物理层传输到目标主机物理层时，主机递交到数据链路层，同样经历上述相反的过程一层一层解包拿到数据。","text":"网络模型1 七层网络模型国际标注化组织ISO于1981年 正式推荐了一个网络体系结构–七层参考模型，也被叫做开放系统互连模型 这七层网络模型在传输过程中还会对数据进行封装，过程如图所示 在ISO七层网络模型中，当一台主机需要传送用户数据时，数据先进入应用层。在应用层中，数据被加上应用层报头（AH），形成应用层协议数据单元（PDU），然后被递交到表示层。表示层不关心上层应用数据格式而是把整个数据包看成一个整体（应用层数据）进行封装，及加上表示层报头（PH）。下层分别加上自己的报头，其中数据链路层还会封装一个链尾，形成一帧数据。 当一帧数据通过物理层传输到目标主机物理层时，主机递交到数据链路层，同样经历上述相反的过程一层一层解包拿到数据。 2 五层网络模型大学教科书一般采用了一个五层的网络模型 1 应用层 : 确定进程之间的通信性质以满足用户需求。 2 运输层：负责主机间不同进程的通信。即TCP与UDP 3 网络层：负责分组交换不同主机间的通信 IP数据报 4 数据链路层：负责将网络层的IP数据报组装成帧 5 物理层：透明的传输比特流 3 四层网络模型不论是七层还是五层，都是学术上的概念，实际应用的网络模型是一个四层的TCP/IP模型。 TCP|IP 被组织成四个概念层，其中三个与ISO中模型对应。TCP、IP协议簇不包含链路层和物理层，其需要与其他协议协同工作。 网络接口层 网络接口层包括用于IP数据在已有网络介质上的传输协议。实际上TCP、IP并不定义与ISO链路物理层相对应的功能，相反它定义了ARP这样的协议，提供TCP、IP与硬件间的接口 网间层 网间层对应网络层，本层包含IP、RIP协议，负责数据包装、寻址、路由 传输层 网间层对应OSI参考模型的传输层，它提供两种端到端的通信服务。其中TCP提供可靠的数据流传输服务，UDP提供不可靠的数据报服务。 应用层 应用层对应应用层和表示层。 TCP头部 TCP头部里每一个字段都为管理TCP连接和控制起了重要作用 16位端口号：告知报文段来自哪里，传到哪里。进行TCP通信时，客户端通常使用临时端口号，服务器则使用知名端口号 32位序号：一次TCP通信（TCP连接建立到断开）过程中传输字节流中字节的标号，序号值被初始化为某随机值，之后该传输方向上TCP报文的序号值加上该随机值的偏移 32位确认号：用作对一方发来TCP报文段的相应。其值是TCP报文段值加1 4位头部长度 标识TCP头部有多少（4字节），这样TCP首部最大是60字节 6位标志位包含如下几项 1）URG 紧急指针是否有效 2）ACK 确认号是否有效 3）PSH 提示接收端立即从缓冲区读走数据 4）RST 表示要求重新建立连接 5） SYN 标识请求开始一个连接 （同步报文段） 6）FIN标志 表示通知对方要关闭连接了 （结束报文段） 16位窗口大小 TCP控制流量的手段，接受窗口（告诉对方TCP缓冲区还能容纳的字节数） 16位验校和 检验TCP报文段在传输过程中是否损坏 16位紧急指针 正偏移量 有几点需要注意 TCP包没有IP地址，这属于网络层、一个TCP连接需要4个元组（略）来保证是同一连接。 SequenceNubmer是包序号，来解决网络包乱序问题ACK用于确认不丢包 Window是滑动窗口用来解决流控问题 TCP状态流转首先了解注明的三次握手与四次挥手 TCP建立连接 1） 第一次握手：建立连接时，客户端发送SYN包（SYN=J）到服务器，并且进入SYN_SEND状态等待服务器确认 2） 第二次握手：服务器收到SYN包，确认客户端的SYN（ACK=J+1）同时也发送一个自己的SYN包（SYN=K）即SYN+ACK包，服务器进入SYN_RECV状态 3） 第三次握手：客户端收到SYN+ACK包，向服务器发送确认包ACK（ACK=K+1）发送完毕客户端和服务器进入ESTABLISHED状态 TCP断开连接 TCP有个特殊的概念叫半关闭，这个概念是说TCP连接是全双工连接，因此关闭连接必须关闭两个方向上的连接。客户机给服务器发送一个FIN的TCP报文，然后服务器回一个ACK报文，并且发送一个FIN报文，之后客户端再回ACK就结束了。 在建立连接的时候，通信双方要确认最大报文长度，一般这个SYN是MTU减去IP和TCP的首部长度，对于以太网一般可以达到1460字节，当然非本地IP只有536字节，中间传输的MSS更小的话这个值更小 2MSL 等待状态 （TIMEWAIT）发送了最后一个ACK后，防止最后一次的数据报没有达到对方那里。这个状态保证了双方都可以正常结束，由于socket（IP和端口对）使得应用程序在这个时间（2MSL）无法使用同一个服务。这对于客户端无所谓，但是服务程序（httpd）总要用一个端口来服务。而这个时间，启动httpd会出现错误（插口被使用）。为了避免这个错误，服务器给出了平静时间的概念，虽然可以重新启动服务器，但是要平静的等待2MSL才能进行下一次连接 FIN_WAIT_2 状态 这是注明的半关闭状态，这个状态应用程序还可可以接受数据但是不能发送数据。还有一种可能是 客户端一直 FIN_WAIT_2 ，服务器一直 CLOSE_WAIT 状态 直到应用层来关闭这个状态 RST 同时打开和同时关闭，概率很小 TCP超时重传本节讨论异常网络状况下，TCP如何控制数据保证其承诺的可靠服务 数据顺利到对端，对端顺利响应ACK 数据包中途丢失 数据包顺利达到，但是ACK报文丢失 数据报数据达到，但是对异常未响应 出现这些异常情况时，TCP就会超时重传。TCP每发一个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段，这被称为超时重传 利用tcpdump调试出以下信息 可以看出重传时间为2、4、8、6（可能是被终止了） 客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO。RTO指发送数据后，传送数据等待ACK的时间。RTO非常重要。 设长了，重发慢，没有效率 设短了，重发快，网络拥塞 如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，因此TCP必须适应时延差异。 RFC973规定了经典的自适应算法 12SRTT = α * SRTT + (1 - α) * RTTRTO = min(UBOUND, max(LBOUND，β * SRTT)) 但是这个算法有个问题，主要是由于ACK传输导致的RTT多义性问题 1987年出现了一种carn算法, 忽略重传，不采样重传的RTT。 该算法规定，一但发生重传，就对现有的RTO翻倍。 当不发生重传时，才根据上式计算平均往返时间RTT和重传时间 TCP滑动窗口TCP滑动窗口主要有两个作用 1. 提供TCP的可靠性 2. 提供TCP的流控特性 同时滑动窗口还体现了TCP面向字节流的设计 对于TCP会话的发送方，任何时候其缓存数据可以分为四类： 已经发送并受到对方的ACK 已经发送但未收到ACK 未发送但是对方允许发送 不允许发送 其中，已经发送还未收到ACK和未发送但是对方允许发送的部分称为发送窗口 当对方接收到ACK后续的确认字节时，便会滑动 对于TCP的接收方，某一时刻其有三种状态 1 已接收 2 未接受准备接受 3 未准备接受 TCP是双工的协议，会话的双方可以同时接受、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源于确认重传。发送窗口只有收到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接受的情况下，窗口不会移动。 TCP拥塞控制计算机中带宽、交换节点中的缓存、处理机都是网络资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：慢开始、拥塞避免、快速重传和快速恢复 慢开始和拥塞避免发送方维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口 慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小至大的增加拥塞窗口 当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞 可以试探一下，由小至大增大拥塞窗口的数量 （这里用报文段说明，实际上拥塞窗口以字节为单位） 慢开始从1开始指数增长，为了防止其增长过大， 设置一个门限，当其达到门限时，变为拥塞避免算法 拥塞避免算法是使得拥塞窗口缓慢增长，每经过一个RTT就将 拥塞窗口加一 TCP连接初始化，拥塞窗口设为1 执行慢开始算法，cwind指数增长，直到cwind=ssthress时，开始拥塞避免算法 当网络拥塞时， 将ssthress设为当前的一半，cwind重新设为1 开始 快重传和快恢复快重传要求接收方收到一个失序的报文段后立即发出重复确认（为使发送方尽早知道报文段未传到对方）快重传规定只有一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。 快重传还配合有快恢复，主要思想包括 一旦收到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始 将cwind设为ssthresh， 然后执行拥塞避免算法 整体上，TCP拥塞窗口的原则是加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"STL剖析(vector,string)","slug":"STL剖析（vector-string）","date":"2019-01-03T13:28:39.000Z","updated":"2019-01-03T13:37:05.846Z","comments":true,"path":"2019/01/03/STL剖析（vector-string）/","link":"","permalink":"http://yoursite.com/2019/01/03/STL剖析（vector-string）/","excerpt":"STL概论 长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。 子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 … 都是为了 复用性的提升 复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。 为了建立数据结构算法的标准，降低耦关系，提升独立性、弹性，交互操作性，诞生了STL","text":"STL概论 长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。 子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 … 都是为了 复用性的提升 复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。 为了建立数据结构算法的标准，降低耦关系，提升独立性、弹性，交互操作性，诞生了STL stringstring类的实现是基础的题目,首先给出string的原型 123456789101112class String&#123;public: String(const char* str = NULL）; //普通构造函数 String(const String &amp;other); //拷贝构造函数 ~String(); //析构函数 String &amp; operator = (const String &amp;other); //重载运算符 String &amp; operator + (const String &amp;other); //重载运算符 bool operator == (const String &amp;other); //重载运算符 int getLength(); //得到长度private: char *m_data;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748String::String(const char* str)&#123; if (str == NULL) &#123; m_data = new char[1]; *m_data = '\\0'; &#125; else &#123; int length = strlen(str); m_data = new char[length+1]; strcpy(m_data, str); &#125;&#125;String::~String()&#123; if (m_data) &#123; delete[] m_data; m_data = 0; &#125;&#125;String::String(const String &amp;other)&#123; if (!other.m_data)&#123; m_data = 0; &#125; m_data = new char[strlen(other.m_data)+1]; strcpy(m_data, other.m_data);&#125;String&amp; String::operator = (const String &amp;other)&#123; if(this != &amp;other)&#123; delete[] m_data; if(!other.m_data)&#123; m_data = 0; &#125; else &#123; m_data = new char[strlen(other.m_data)+1]; strcpy(m_data, other.m_data); &#125; &#125;&#125;String &amp; String::opreator+(const String &amp;other)&#123; String newString; if(!other.m_data)&#123; newString = *this; &#125;else if(m_data)&#123; newString=other; &#125;else&#123; newString.m_data = new char[strlen(m_data)+strlen(other.data)+1]; strcpy(newString.m_data,m_data); strcat(newString.m_data,other.m_data); &#125; return newString;&#125; vectorvector 是线性容器，它的元素线性排列，和动态数组类似。它的元素储存在一块连续的空间中，这意味着他不仅可以用迭代器访问、还可以通过指针偏移访问，vector能自动储存元素 下标访问个别元素 不同的方式遍历元素 容器末尾增加、删除元素 12345// 迭代器vector&lt;int&gt;::iterator iter;for(it = con.begin(); it!=con.end(); it++)&#123; cout&lt;&lt;*it&lt;&lt;endl;&#125; 关于STl容器，只要不超过最大值，其可以自动增长到足以容纳用户放进去的数据大小。（这个容量值，可以同过调用maxsize()来获得） 对于vector和string，如果需要更多的空间，类似realloc思想增长，vector支持随机访问，因此提高了效率，内部通过动态数组实现。 123456789101112131415161718//vector 查找vector&lt;int&gt;::iterator iter;iter = find(vec.begin(),vec.end(),3);//vector 删除vector&lt;int&gt;::iterator iter;while(iter!=vec.end())&#123; if(*iter==target)&#123; iter = erase(iter); &#125;else&#123; iter++; &#125;&#125;//vector 增加iterator insert(iterator loc, const TYPE &amp;val);void insert(itrator loc, size_type num, const TYPE &amp;val);void insert(itrator loc, itrator start, itrator end); vector 的内存管理1，使用reverse() 提前设定容量大小 STL最令人称赞的特性之一就是只要不超过最大值，其可以自动增长。如果需要更多空间就会类似realloc的思想来增长大小。vector容器支持随机访问，因此效率较高。 如果有大量的元素需要push_back，应提前使用reverse函数提前设定，避免多次的扩容操作，介绍一下只有vector与string提供的几个函数 函数名 介绍 size() 获得容器中的元素个数，但不能获得容器为他分配的容器大小 capacity() 获得容器已经分配的内存容纳多少元素。 resize() 用来强制把容器改为容纳n个元素。如果n小于当前大小，尾部元素会被销毁；如果n大于当前大小，默认构造元素添加到元素尾；如果大于当前容量，触发重新分配 reverse() 强制把容量改为不小于n，n不小于当前大小 交换技巧来修整内存 swap强行释放内存 12345template&lt;class T&gt; void VlearVector(vector&lt;T&gt;&amp; v)&#123; vector&lt;T&gt; vTemp; vTemp.swap(v);&#125; vector类简单实现第一版是这本书的，感觉实现的不好，没有体现出空间配置器的作用，只写了构造函数 1234567891011121314151617181920212223242526template&lt;typename T&gt;class myVector&#123;private: #define WALK_LENGTH 64;public: // 构造函数 myVector():array(0),theSize(0),theCapcity(0)&#123;&#125; myVector(unsigned int n, const T&amp; t):array(0),theSize(0),theCapacity(0)&#123; while(n--)&#123; push_back(t); &#125; &#125; // 拷贝构造函数 myVector(const myVector&lt;T&gt;&amp; other):array(0),theSize(0),theCapcity(0)&#123; *this = other; &#125; // 重载赋值运算符 myVector&lt;T&gt;&amp; opreator = (myVector&lt;T&gt;&amp; other)&#123; if(this == &amp;ohter) return *this; clear(); theSize &#125;&#125; 第二版参考《stl源码》 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103template&lt;class T, class Alloc=alloc&gt;class vector&#123;public: typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator; iterator start; iterator finish; iterator end_of_storage; void insert_aux(iterator posotion, const T&amp; x); void deallocate()&#123; if(start) data_allocator::deallocate(start,end_of_storage-start); &#125; void fill_initialize(size_type n, const T&amp; vlaue)&#123; start = allocate_and_fill(n, value); finish = start + n; end_of_storage = finish; &#125;public: iterator begin()&#123;return start;&#125; iterator end()&#123;return finish;&#125; size_type size() const &#123;return size_type(end()-begin());&#125; size_type capacity() const&#123;return size_type(end_of_storage-begin());&#125; bool empty() const &#123;return engin()==end()&#125; reference operator[](size_type n)&#123;return *(begin()+n);&#125; vector():start(0),finish(0),end_of_storage(0)&#123;&#125; vector(size_type n,const T&amp; value)&#123;fill_initialize(n,value);&#125; vector(int n,const T&amp; value)&#123;fill_initialize(n,value);&#125; vector(long n,const T&amp; value)&#123;fill_initialize(n,value);&#125; explicit vector(size_type n) &#123;fill_initlialize(n,T());&#125; ~vector()&#123; destroy(start,finish); deallocate(); &#125; reference front()&#123; return *begin();&#125; reference back() &#123; return *(end()-1);&#125; void push_back(const T&amp; x)&#123; if(finish!=end_of_storage)&#123; construct(finish, x); ++finish; &#125;else insert_aux(end(),x); &#125; void pop_back()&#123; --finish; destory(finish); &#125; iterator erase(iterator position)&#123; if(position+1 != end()) copy(position+1,finish,position); --finish; destory(finish); return position; &#125; void resize(size_type new_size, const T&amp; x)&#123; if(new_size&lt;size()) erase(begin()+new_size(),end()); else insert(end(),newsize()-size(),x); &#125; void resize(size_type new_size)&#123;resize(new_size,T());&#125; void clear()&#123;erase(begin(),end());&#125;protected:iterator allocate_and_fill(size_type n, const T&amp; x)&#123; iterator result = data_allocatpr:: &#125;&#125;template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x)&#123; if(finish != end_of_storage)&#123; construct(finish,*（finish-1)); ++finish; T x_copy = x; copy_backword(position, finish-2,finish-1); *position = x_copy; &#125;else&#123; const size_type old_size = size(); const size_type len = old_size != 0?2*oldsize:1; iterator new_start = data_allocator::allocate(len); iterator new_finish = new_start; try &#123; new_finish = uninitialized_copy(start,posotion,new_start); construct(new_finish, x); ++new_finish; new_finish = uninitialized_copy(positon,finish,new_finish); &#125; catch(...)&#123; destroy(new_start,new_finish); data_allocator::deallocate(new_start,len); thow; &#125; destroy(begin(),end()); deallocate(); start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125;&#125; map、set map的本质 map本质是一类关联式容器，属于模板类关联的本质在于元素的值与某个特点的键相关联，而并非通过元素在数组的位置获取。它的特点是增加和删除节点对迭代器的影响很小，除了要操作的节点，对其他节点都没什么影响。对迭代器来数不能修改键值，只能修改实值。map内部自建一颗红黑树（非严格意义的平衡二叉树），该树内部数据有序 map的功能 自动建立Key-value的一一对应关系，map&lt;int, string&gt; mapStudent; 红黑树源码略（不研究了） hashtablehashtable被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。 如何避免array过大？是用某种映射函数，使得元素映射至“大小可以接受的索引”，这个函数被称为散列函数。使用散列函数必然会带来一个问题：可能有不同的元素被映射到相同的位置，这便是所谓的碰撞问题。 碰撞问题一般有两种方案：拉链法、线性探测法 线性探测提出一个名词：负载系数，元素个数除以表格大小。负载系数永远在0~1之间， 当 散列函数 计算某个位置，而该位置不可用该怎么办？ 最简单的方法就是循序接着往下找，只要表格足够大总会找到一个空间。而删除必须采取惰性删除（标记删除序号，实际删除待表格整理时再进行） 两个假设 1.表格足够大，2 每个元素独立 但实际情况往往不乐观，往往需要不断解决碰撞问题 二次探测二次探测主要用来解决 主集团问题， 该方法描述很简单，碰撞时尝试 H+1*1，H+2*2, H+ 3*3来代替H+1, H+2,H+3 等。幸运的是，假设表格大小为质数，永远保持0.5以下的负载系数，每个新元素的插入查找不大于2 另外，二次探测有个简便的计算技巧 12345hi = h0 + i\\*i (MOD M)hi-1 = h0 + (i-1) *(i-1) (MOD M)整理得，hi = hi-1 + 2*i-1 (MOD M) 这样每一次迭代并不需要太大的计算资源。 开链拉链法，在《源码》中被称为开链，及对于冲突的元素维护一个链表","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"C++常用编程技术","slug":"C-常用编程技术","date":"2018-12-23T07:42:36.000Z","updated":"2018-12-23T07:43:36.676Z","comments":true,"path":"2018/12/23/C-常用编程技术/","link":"","permalink":"http://yoursite.com/2018/12/23/C-常用编程技术/","excerpt":"[TOC] C++常用编程技术函数 函数定义 函数重载 C++允许同一函数名定义多个函数，但这些函数必须参数个数不同或类型不同，这就是函数重载 123456789int min (int a, int b) &#123; return a &lt; b ? a:b;&#125;int min (long long a, long long b) &#123; return a &lt; b ? a:b;&#125;int min (int a, int b, int c) &#123; // something&#125;","text":"[TOC] C++常用编程技术函数 函数定义 函数重载 C++允许同一函数名定义多个函数，但这些函数必须参数个数不同或类型不同，这就是函数重载 123456789int min (int a, int b) &#123; return a &lt; b ? a:b;&#125;int min (long long a, long long b) &#123; return a &lt; b ? a:b;&#125;int min (int a, int b, int c) &#123; // something&#125; 函数模板 函数模板建立一个通用函数，其函数类型和形参不具体指定而是用一个虚拟的类型来代表，这个通用函数就是模板。凡是函数体相同的函数都可以用模板代替，而不用定义多个函数，实际只需定义一次。调用函数时，系提供会根据实参的类型取代模板的虚类型。 123456#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;T min(T a, T b) &#123; return a &lt; b ? a:b;&#125; 数组 数组 a[10] 字符数组 strlen 与 sizeofstrlen()是函数，运行时计算。参数必须是字符型指针（char*），而且必须是以\\0结尾当数组名作为参数传入时，其已经退化为指针了。 sizeof()是运算符，而不是一个函数，在编译时就计算好了，用于计算机数据空间的字节数。因此sizeof不能返回动态分配的内存大小，常用于返回类型和静态类型的分配对象，结构或数组所占空间。 数组–编译时分配数组空间大小 1char a[10] = \"hello\"; 由于char占1字节，所以sizeof(a)的值是10* 1 = 10 字节 指针–储存该指针占用空间大小 1char *str = \"I am from China\" 在32位的编译器上，指针一律4字节 类型– 类型所占空间大小 1int b = 10 32位机器上，int占4字节 对象–对象实际的占用空间 1234class class_Samlpe &#123; int a,b; int func();&#125;class_a; 函数–函数返回类型所占空间大小 引用引用作为函数参数：内存中没有产生实参的副本，而是对实参的直接操作。 常引用如果想提高程序的效率，又要使传递给函数的数据不在函数中被改变，就应该使用常引用。 1const 类型标识符 &amp; 引用名 = 目标变量名; 这种方式声明的引用，不能通过对目标的变量值进行修改，保证了引用的安全 关于常引用典型的错误调用 123456string func1();void func2(string &amp;s);// 以下表达式非法func2(func1);func2(\"hello\"); 原因在于，func1是函数返回值，”hello”是临时变量，二者都属于“临时变量”，C++中临时变量都是const类型的.因此上面试图将const转化为非const类型 引用类型应尽量被定义为const类型 结构体、共用体结构体共用体共用体用关键字union定义，它是一种特殊的类，在一个共用体多种不同的数据类型，共享空间 Union 可以用来判断计算机的大小端 枚举预处理C++提供的预处理包括4中： 宏定义、文件包含、条件编译和布局控制 常用宏定义命令#define 命令是一个宏定义命令，将标识符定义为一个字符串，该标识符被称为宏名 12345#define 宏名 字符串#define PI 3.1415#define 宏 （参数列表）宏#define A(x) x Do…while(0) 妙用1234#define Foo(x) do&#123;\\ statement one;\\ statement two;\\&#125;while(0) 条件编译12345#ifdef 标识符 程序段1#else 程序段2#endif extern C面向对象类与对象面向对象的主要思想是把构成问题的各个事务分解成对象，建立对象的目的是藐视一个事务在解决问题中经过的步骤和行为。对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 1234567891011121314class CStudent &#123;public: void display();private: int num; char name[20]; int age;&#125;;void CStudent::display() &#123; cout&lt;&lt;\"num:\"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;\"name\"&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;\"age:\"&lt;&lt;age&lt;&lt;endl;&#125; 类的封装性C++中通过类实现封装性，把数据和数据有关的操作封装在一个类里。但是人们使用时往往不关心实现，为了实现类的封装性（数据隐藏、提供访问接口）类为成员提供了私有、公有和受保护三种基本的权限。 私有成员 private 公有成员 public 受保护成员 protect 构造函数数据成员不能在类中初始化，而构造函数为此而生，主要用来处理数据成员的初始化，且不需要调用，建立对象自动执行。 构造函数必须与类名相同，不能随意命名，以便编译系统识别作为构造函数处理。 123456789101112131415class Time&#123;public: Time(); set_time(); get_time();private: int hour, minute, second;&#125;;Time::Time()&#123; hour = 0 minite = 0 second = 0&#125;// C++还提供一种参数初始化表的方法Time::Time():hour(0), minite(0), second(0)&#123;&#125; 构造函数不仅可以对数据成员赋值，也可以包含其他语句。如果用户没有定义构造函数 ，那么C++会自动为其生成一个构造函数，只是这个构造函数的函数体是空的。 构造函数可以被重载 调用构造函数时不必给出实参的构造函数，称为默认构造函数。无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。即使一个类中有多个构造函数，但建立对象时都只执行一个构造函数 构造函数可以添加默认参数 123456789101112131415161718class Box&#123;public: Box(int h=2,int w=2,int l=2); int volume();private: int height,width,length;&#125;Box::Box(int h,int w,int len)&#123; height = h; width = w; len = length;&#125;int Box::volume()&#123; return height*width*length;&#125;Box box(1); // 显示指定第一个参数Box box(1,2); // 显示指定1,2参数 使用默认参数的好处在于：调用构造函数时就算没有提供参数也不会出错，对每一个对象有相同的初始化状况。 一个类全是默认参数的构造函数后，就不能再重载构造函数了 析构函数析构函数在函数名前加一个 ~ 它在对象的生命周期结束后自动执行 程序执行析构函数的时机有以下四种 如果函数定义了一个对象，这个函数调用结束时对象会被释放，且在对象释放前自动执行析构函数。 static 局部对象在函数调用结束时对象不释放，所以也不执行析构函数，只有在main函数结束调用exit函数结束程序时，才调用static局部对象析构函数 全局对象则是在程序流离开其作用域（main函数结束或调用exit（）函数时）才会执行全局对象的析构函数 用new建立的对象，用delete释放对象时，会调用对象的析构函数 析构函数的作用不是删除对象，而是在撤销对象占用的内存前完成一些清理工作，使得这些内存可以供新对象使用。析构函数的作用也不限于释放资源，它还可以被用来执行用户最后一次使用对象时执行的任何操作。 123456789101112131415161718class Box&#123;public: Box(int h=2,int w=2,int l=2); ~Box()&#123; cout&lt;&lt;\"Destructor called.\"&lt;&lt;endl; &#125; int volume();private: int height,width,length;&#125;Box::Box(int h,int w,int len)&#123; height = h; width = w; len = length;&#125;int Box::volume()&#123; return height*width*length;&#125; 静态数据成员有时需要为某个类分类单一的储存空间，在C语言中可以使用全局变量，但这样很不安全（被修改），而且名字易冲突。如果可以把数据当成全局变量去储存，但又被隐藏在类内部，而且清楚的与这个类相联系，这种处理方法较为理想。这个可以用静态数据成员实现。类的静态数据成员共享静态储存空间，不管创建了多少这个类的对象，所有的对象静态数据共享这个储存空间，这就为对象之间提供了一种通信方法。静态数据属于类，他在类的范围内有效。 由于不管产生了多少对象， 类的静态数据都有单一的储存空间，所以储存空间必须在一个单一的地方。 静态数据成员必须出现在类的外部而且只能定义一次 1234567// xx.hclass base&#123;public: static int var;&#125;// xx.cppint base::var = 10; 在头文件中定义（初始化）静态成员容易引起重复定义的错误，比如这个头文件被多个cpp包含的时候 C++静态数据成员被所有的类对象共享，包括该类的派生类对象。派生类对象与基类对象共享基类的静态数据成员。静态数据成员只占一份空间。如果改变它的值，则各个对象中这个数据成员的值都变了 1234567891011121314151617class Base&#123;public: static int var;&#125;;int Base::vat = 10;class Derived:public Base&#123;&#125;;int main()&#123; Base base1; base1.var++; //11 Base base2; base2.var++; //12 Derived derived1; derived1++; //13 Derived derived2; derived2++; //14 return 0;&#125; 如果只声明类而未定义对象，类一般数据成员不占内存空间，只有在定义对象时才会为对象分配空间。但是静态数据成员不属于某一个类的对象，所以为对象分配的空间不包括静态数据成员所占的空间，静态数据成员在所有对象之外开辟的一段空间。 静态成员函数与数据成员类似，成员函数也可以定义为静态，在函数前加入static关键字 与静态数据成员不同，静态成员函数是不是为了对象间的沟通，而是为了能处理静态数据成员。 当调用一个对象的成员函数时（非静态成员函数），系统会把该对象的起始地址付给this指针，而静态成员函数不属于某一对象，其没有this指针。既然他没有指向某一对象，也就无法对一个对象中的非静态成员进行默认访问。 静态成员函数与非静态成员函数的根本区别是：非静态成员函数有this指针，而静态成员函数没有。 静态成员函数可以直接引用本类中的静态数据成员，因为静态数据成员同样数据类 对象的储存空间结论： 1 非静态成员变量总和 2 加上编译器为了CPU计算做出的数据对其处理和 3 支持虚函数所产生的负担总和。 空类的大小占用1字节 成员函数、构造函数、析构函数 不占用空间 编译器为了支持虚函数，会产生额外的负担，这正是指向虚表的指针大小，64位机器上占8字节。 this指针每个对象中数据成员分别占有储存空间，如果对同一类定义了n个对象，则有n个同样大小的空间存放这些数据成员，不同对象引用数据成员时，提供了this指针 this指针有如下特点 只能在成员函数中使用，在全局函数、静态成员函数中都不能使用 this指针成员金函数前构造，成员函数后清楚 this指针会因为编译器不同而有不同的位置 this是类的指针 因为this指针只有在成员函数中才能有意义，所以获得一个对象后，不能通过对象使用，也无法获取指针的位置 普通的类函数不会创建表来保存指针，只有虚函数会被放到函数表中 类模板1234567891011121314151617181920// 一个典型计算的类模板template&lt;class T&gt;class Operation &#123;public: Operation (T a,T b):x(a),y(b)&#123;&#125; T add()&#123; return x+y; &#125; T subtract()&#123; return x-y; &#125;private: T x,y;&#125;// 类模板的成员函数在类外定义这么写template&lt;class T&gt;T Operation&lt;T&gt;::add()&#123; return x+y;&#125; 析构函数与构造函数的执行顺序一般情况下，调用析构函数的次序与调用构造函数的次序相反：最先被调用的构造函数，其析构函数被最后调用； 最后调用的构造函数，其析构函数最先被调用 在全局范围中定义的对象（所有函数之外的对象）他的构造函数在文件所有函数之前。但是一个程序有多个文件，其不同文件的都定义了全局对象，这构造的顺序使不确定的。他们在main函数结束时析构 如果定义的是局部自动对象，建立对象时调用构造函数，如果函数被多次调用，则每次都调用构造函数 如果函数定义静态（static）局部对象，则只在第一次调用构造函数，在main函数结束后才析构 继承与派生继承方式包括 public、private、protected，默认为private public 公用继承 共用成员、保护成员在派生类中保持访问属性 private 私有继承，基类的公用、保护成员在派生类中称为private成员 protect 受保护继承 基类共有、保护在派生类中成protected成员（保护成员的意思是 不能被外界引用，但是可以被派生类引用） 派生类包括，从基类继承而来的部分和声明派生类增加的部分 基类的成员函数只能访问基类的成员，不能访问派生类 派生类的成员函数可以访问基类、派生类的成员 派生类外可以方位基类成员、共有的成员 可以发现，无论哪一种继承方式，派生类不能访问基类的私有成员，私有成员只能被成员函数访问，毕竟派生类和基类不是一个类 派生类的构造与析构函数派生类的基类数据成员与新增的数据成员共同组成，如果派生类新增成员包括其他子对象，派生类数据成员还间接的包括了这些对象的数据成员，因此派生类必须对这些数据成员初始化。 对基类成员和子对象成员的初始化必须在初始化列表中进行，新增的成员初始化既可以在初始列表，也可以在在构造函数体进行 派生类构造必须对这三类成员初始化1、调用基类构造函数 2、子对象的构造函书 3、派生类的构造函数体 派生类有多个基类时，同一层次的调用顺序取决于定义派生类时顺序（从左至右） 如果基类也是派生类、依次回溯 派生类构造函数与析构函数的调用顺序1、基类构造函数 –》派生表中的顺序 2、成员类构造函数 –》 类中的声明顺序 3、 派生类构造函数 –》 类的多态1.多态 C++中 多态是指不同功能函数可以用同一个函数名，这样一个函数名可以调用不同内容的函数，在面向对象中多态这么表述：向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为；也就是说，每个对象可以用自己的方式去相应共同的消息。 设想： 能否用同一个调用形式，既用派生类又能调用基类同名函数。 C++ 虚函数解决这个问题，虚函数允许派生类重新定义与基类同名的函数，并且可以通过基类指针访问基类和派生类中的同名函数。 12345678910111213141516171819202122232425262728class Box&#123;public: Box(int, int, int); virtual void display();protected: int length, height, width; &#125;Box::Box (int l, int h, int w) &#123; length = l; height = h; width = w;&#125;void Box::display()&#123; cout&lt;&lt; ... &lt;&lt; endl;&#125;class FilledBox:public Box&#123;public: FilledBox (int,int,int,int,string); virtual void display();private: int weight; string fruite;&#125;;void FilledBox::display()&#123; cout &lt;&lt; ... &lt;&lt;nedl;&#125;FilledBox::FilledBox(int l,int h, int w, int we, string f):\\ Box(l, h, w), weight(we), fruite(f)&#123;&#125; 基类中使用virtual关键字声明成员函数为虚函数 派生类中重新定义此函数，要求函数名、函数类型、参数个数、类型全部与基类相同 C++规定当基类声明虚函数时，派生类中的同名函数自动成为虚函数，派生类定义该函数可加可不加virtual，但一般习惯每一层都加，这样程序更清晰 定义一个基类指针，使它指向统一类族中需要调用的对象 通过虚函数需基类指针配合使用，便可以调用同一类族中的同名函数 纯虚函数纯虚函数是在基类中生命的函数，在基类中没有定义，但要求任何派生类都定义实现方法 1virtual void function() = 0; 编译器要求派生类必须重载以实现多态性，同时含有纯虚函数的类称为抽象类 析构函数C++ 中，构造函数不能被声明为虚函数 。然而析构函数可以被声明为虚函数。 如果想要通过父指针来销毁派生类，必须定义虚析构函数 12345678910111213141516class Base&#123;public: Base()&#123;cout&lt;&lt;'Base::Base()'&lt;&lt;endl;&#125; virtual ~Base()&#123;cout&lt;&lt;'Base:~Base()'&lt;&lt;endl;&#125;&#125;class Derived::public Base&#123;public: Derived()&#123;cout&lt;&lt;'D'&lt;&lt;endl;&#125; ~Derived()&#123;cout&lt;&lt;'~D'&lt;&lt;endl;&#125;&#125;int main()&#123; Base* p = new Derived(); delete p; return 0;&#125; 单例模式设计思想： 定义了一个单例类，使用私有的静态指针指向唯一的实例，并通过共有的方法获取这个指针。 单例模式保证了程序运行的任何时刻，该单例类的实例只存在一个 1234567891011121314class Sinst&#123;private: Sinst()&#123;&#125;; static Sinst* pinst;public: static Sinst* getSinstance()&#123; if (pinst == NULL) &#123; pinst = new Sinst(); &#125; return pinst; &#125;&#125;Sinst* Sinst::pinst = NULL;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MySQL数据库","slug":"MySQL数据库","date":"2018-12-23T07:38:24.000Z","updated":"2018-12-23T07:41:18.782Z","comments":true,"path":"2018/12/23/MySQL数据库/","link":"","permalink":"http://yoursite.com/2018/12/23/MySQL数据库/","excerpt":"[TOC] 数据库MySQL事务事务的概念、隔离级别、死锁见「数据库系统原理」","text":"[TOC] 数据库MySQL事务事务的概念、隔离级别、死锁见「数据库系统原理」 事务日志事务日志可以帮助提高事务的效率，使用事务日志，在储存引擎上修改表时数据只需要修改其内存拷贝，再把修改行为记录到硬盘上的持久事务中，而不用每次都将修改的数据本身持久到磁盘 事务日志采用追加方式，因此日志操作是顺序I/O。采用事务日志速度快。事务日志持久后，内存中被修改的数据主键被刷回磁盘，大多数储存引擎都是这么实现的。这被称为预写日志，修改数据两次写磁盘 如果数据的修改已经持久化，而数据本身没被写入磁盘，系统崩溃后储存引擎在重启时自动恢复修改的数据。 MySQL自动提交MySQL默认采用自动提交，不是显示的开始一个事务，每个查询都被当成一个事务提交。 有一些命令会强制提交当前的活动事务，如Alter MySQL可以设置所有的四个隔离级别 1set session transaction isolation level read committed 事务中混用储存引擎MySQL不管理事务，事务由引擎实现，所以在一个中混用引擎是不可靠的 事务回滚对于非事务型表（如MyISAM）无法撤销，数据库会失去一致性 隐式和显示锁定InnoDB采用两阶段锁定协议，事务执行过程中随时可以执行锁定，只有在commit和rollback时释放，并且所有的锁在同一时刻释放，这些属于隐式锁，InnoDB在需要时自动加锁 同样InnoDB支持显示加锁，一般来说显示使用LOCK TABLES语句不但没有必要还会严重影响性能，实际上InnoDB行锁性能更好 MySQL并发控制读写锁详见「数据库系统原理」 锁粒度一种提高资源并发的方式是让锁的对象更有选择性。尽量只锁需要修改的部分数据，而不是所有的资源。任何时候，互相之间不发生冲突，锁的数量越少并发程度越高。 加锁也需要消耗资源，获得锁、检查锁、释放锁都会增大开销。所谓锁策略，就是在所的开销和安全性之间寻求一种平衡。大多数商业数据库没有提供更多的选择，一般是在表上施加行级锁。而MySQL提供可多种选择，每种储存引擎都可以实现自己的锁策略和锁粒度 表锁 表锁是MySQL中最基本的锁策略，并且是开销最小的锁。它锁定整张表，用户对表的写操作都需要获得整个锁 尽管储存引擎管理自己的锁，MySQL本身还是会使用有效的表锁，例如Alter table语句使用表锁 行级锁 行级锁可以最大程度的支持并发处理（最大的锁开销），InnoDB及XtraDB实现了行级锁，行级锁只在引擎层面实现，而服务器层面并不了解锁的情况 MySQL多版本并发控制（MVCC）MySQL实现了自己的多版本并发控制（MVCC），可以认为MVCC是行级锁的一个变种，它在很多情况下避免了加锁操作，因此开销更低。 MVCC的实现是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，事务对同一张表，同一时刻数据可能是不一样的 InnoDB的MVCC是通过在每个记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间，一个保存了行的过期时间。当然储存的是系统版本号。每开始一个事务，系统版本号都会递增，事务开始时刻的系统版本号作为事务的版本号。 SELECT InnoDB会根据以下两个条件检查记录 A. InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么在开始前存在，要么自身插入或修改 B. 行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读到的行在事务开始前未被删除 INSERT InnoDB为新插入的每一行保存当前系统的版本号 DELETE InnoDB为每一行保存当前系统的版本号作为删除标识 UPDATE InnoDB插入一行新的记录，保存当前系统的版本号，同时保存当前系统到原来的行作为删除标识 这样通过版本号的方法使得大多数读操作不需要加锁。 MVCC只在可重复读和已提交读两个隔离级别工作，其他的隔离级别与MVCC不兼容 MySQL引擎InnoDB 储存引擎InnoDB是MySQL默认的事务型引擎，也是最重要，最广泛使用的储存引擎。它被设计用来处理大量的短期事务，短期事务大部分情况下都是正常提交的，很少被回滚。InnoDB的性能和崩溃自动回复的特性使其在非事务型储存的需求中也很流行。 InnoDB数据储存在表空间中，表空间是InnoDB管理的一个黑盒子，由一系列数据文件组成。 InnoDB通过MVCC来支持高并发，并且实现了四个标准的隔离级别，其默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引的间隙进行锁定。 InnoDB表基于聚簇索引建立。InnoDB和MySQL其他引擎有很大不同，聚簇索引对主键的查询有很高的性能。不过他的二级索引必须包含主键列，所以如果主键很大的话，其他的二级索引就会很大。所以索引较多的话主键应尽可能的小 InnoDB内部有很多优化，从磁盘读数据的可预测性读，自动创建hash索引，插入缓冲器操作。 MyISAM引擎在MySQL5.1之前的版本，MyISAM都是默认的储存引擎，MySQL有几个致命的缺点 不支持事务和行级锁 崩溃后无法安全恢复 但其优点在于对于只读数据，速度较快 MyISAM将表储存在两个文件中，数据文件和索引文件，采用非聚簇索引（详见索引部分） 比较 事务： I 是事务型的，支持提交和回滚 并发：M 只支持表级锁， I 还支持行级锁 外键： I 支持外键 备份： I支持在线热备份 崩溃恢复： M崩溃后损坏的几率较高，I 有完善的日志恢复机制 MySQL索引索引（在MySQL中也称键）是储存引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键。 索引优化是对查询性能优化最有效的手段，能够轻易将查询性能提升若干个数量级。 索引基础B-树索引B-树索引是人们经过长期探索发展出目前最适合数据库系统的数据结构，它高效的利用了索引以及机械磁盘的空间。在大多数情况下爱，其不需要全表扫描来获取需要的数据，取而代之的是从根节点进行搜索，依次根据指针向下查找。B树索引有以下特点： 全值匹配 与所有列匹配 匹配最左前缀 索引查找性为“Allen”的人 匹配列前缀 like “J%” 匹配范围值 精确匹配某一列与并范围匹配某一列 只访问索引查询（覆盖索引） B树索引的不足 如果不是从最左列开始，则无法使用查找 不能跳过索引中的列 范围列的右侧无法再使用索引 可以发现，索引列的顺序十分重要 hash索引hash索引基于哈希表实现，只有精确匹配所有列的查询才有效。每一行数据索引都会计算一个hash码 hash查找速度很快，但也有以下限制： hash索引只包含hash值和行指针，而不储存字段的值 hash索引并不是按照索引值储存，无法排序 hash索引不支持部分索引的匹配查找，只支持等值查找 值得注意的是，InnoDB有一个特殊的功能叫自适应哈希索引，当InnoDB某些值使用非常频繁时，他会在内存中基于B树再创建一个hash索引 索引的优点 索引大大减小了服务器需要扫描的数据量 索引可以帮助服务器避免排序和临时表 索引可以将随机IO变为顺序IO 聚簇索引聚簇索引并不是一种单独的索引类型，而是一种数据储存方式。当表有聚簇索引时，表示数据行和相邻的键值紧凑的储存在一起。一个表只能有一个聚簇索引。 InnoDB默认通过主键来聚集数据 如果没有定义主键、InnoDB会选择一个唯一的非空索引，如果没有这样的索引，InnoDB会隐式的定义一个主键作为聚簇索引的主键 聚簇索引的优点 可以把相关数据保存在一起，例如根据用户ID来聚集数据，这样可以最小化磁盘读取数据页 数据访问更快，举措索引将索引和数据保存在统一个B树中，因此聚簇比非聚簇索引的查找更快 覆盖索引世界使用主键值 聚簇索引的缺点 聚簇索引最大限度提高IO密集应用的性能，但是数据如果都在内存中（例如缓存）访问顺序就不重要了 插入速度依赖于插入顺序 更新聚簇索引列的代价很高，强制每个更新移动到位 页分裂问题 聚簇索引可能导致全表扫描变慢（尤其是稀疏表时） 二级索引可能比想象的大，因为二级索引叶子节点包含了主键列 InnoDB和MyISAM的数据分布对比MyISAM 数据分布很简单，数据按照插入数据储存在磁盘上 它很容易创建索引，并且，索引没有什么不同 这是索引1号 Col1 这是索引2号Col2 而InnoDB支持聚簇数据，使用非常不同的方式储存同样的数据。 该图显示整个表，而非只有索引，InnoDB中聚簇索引就是表 聚簇索引的每一个指针都包含了主键值、事务ID、事务及MVCC的回滚指针及所有的剩余列。 还有一个重要的不同， InnoDb的二级索引和聚簇索引有很多不同，其叶子节点储存的不是行指针而是主键值。 覆盖索引索引是一种查找数据的方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不需要读取数据的行。 如果一个索引包含（或者说覆盖）所有要查询字段的值，我们就称之为“覆盖索引。！！覆盖索引从辅助索引中即可得到查询数据，简单的说就是辅助索引就包含了所要查询的值！！ 例如创建某个辅助索引（name、age）查询数据时，select username,age from user where username=’Java’ and age = 22 要查询的列叶子节点都存在，不需要回表索引若干问 索引若干问使用索引的原因？通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性； 大大加快数据的检索速度（这是创建索引最重要的原因）； 帮助服务器避免排序和临时表，将随机IO变为顺序IO； 加速表与表之间的连接，在实现数据参考完整性方面有重要意义； 为什么不对每一列创建索引？当数据增加、删除和修改时，索引也需要动态维护，这样就降低了数据的维护速度 除了数据表占数据空间之外，索引还要需要占据一定的物理空间，如果建立聚簇索引，空间占用更大 创建、维护索引耗费时间、这种耗费随数据量增加而增加 索引提高查询速度的原因？将无序的数据变成相对有序的数据（像查目录一样） 常用索引使用的数据结构？ 哈希索引 对于哈希索引来说，底层函数就是一个hash表，因此在大多数需求为单条记录的查询时，可以选择hash索引，查询性能较快 BTree索引 Mysql使用的是B+树索引，但是对于两种引擎的实现不同 MyISAM和InnoDB实现B+树索引的区别MyISAM: B+树叶节点data域存放的是数据记录的地址，在索引检索的时候，首先按照B+树 算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，被称为”非聚簇索引” InnoDB: 数据文件本身就是索引文件，相比于MyISAM 索引文件和数据文件是分离的，其表结构本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的整条数据记录，这个索引的key正是数据表的主键，因此InnoDB本身就是主索引，这被称为“聚簇索引（聚集索引）”，而其余的索引被作为辅助索引，辅助索引data域储存记录主键的值而不是地址。这样根据辅助索引查找时，先取出主键的值，再走一遍主索引。因此设计表时主键的选择十分重要，主键不宜过长也不宜非单调。 索引的注意事项 在经常需要索引的列上加快搜索速度 在经常使用where子句上索引加快条件判断速度 在经常需要排序的列上创建索引，因为索引已经排序，这样加快排序的查询时间 中、大型表的排序都是有效的，但是特大型表不适合建索引 在经常用到的连接上建索引，这些外键索引加快速度 避免where子句对字段加函数，这样无法命中索引 在InnoDB中使用与业务无关的自增主键作为主键，使用逻辑主键，不使用业务主键 索引列 NOT NULL，否者引擎将放弃索引 删除长期不使用索引、不使用索引的存在会造成比必要的性能损耗 索引原则（高性能Mysql） 单行访问很慢，特别是机械硬盘。如果从数据中读取的一个数据库只获取一行，浪费很多工作，最好读取尽可能多的行。 顺序访问范围数据是很快的。第一，顺序I/O不需要多次的磁盘寻道，比随机I/O快的多。第二、服务器按顺序读取数据，不需要额外的排序操作，group by 也无需再次排序 索引的覆盖查询时很快的，如果一个索引包含了查询所有的列，那么储存引擎就不需要再回表查询行，这避免了大量的单行访问","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"图书指南","slug":"图书指南","date":"2018-12-23T07:37:03.000Z","updated":"2018-12-23T07:38:43.919Z","comments":true,"path":"2018/12/23/图书指南/","link":"","permalink":"http://yoursite.com/2018/12/23/图书指南/","excerpt":"算法 《算法》 《算法导论》 《剑指offer》 《程序员面试金典》 《编程之法：面试和算法心得》 《程序员代码面试指南》","text":"算法 《算法》 《算法导论》 《剑指offer》 《程序员面试金典》 《编程之法：面试和算法心得》 《程序员代码面试指南》 计算机网络 《TCP/IP详解》 《计算机网络：自顶向下方法》 《HTTP权威指南》 操作系统 《深入理解计算机系统》 《计算机程序的构造和解释》 数据库 《数据库系统概念》 《高性能MySQL》 《Redis设计与实践》 C++ 《C++Primer》 《STL源码剖析》 《深度探索C++对象模型》 《Effective C++》 Linux 《鸟哥的Linux私房菜》 《Unix环境高级编程》 《Unix网络编程》 其他 《后台开发：核心技术与应用实践》 《HeadFirst设计模式》 《王道程序员面试宝典》","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"数据库系统原理","slug":"数据库系统原理","date":"2018-12-23T07:16:31.000Z","updated":"2018-12-23T07:35:14.718Z","comments":true,"path":"2018/12/23/数据库系统原理/","link":"","permalink":"http://yoursite.com/2018/12/23/数据库系统原理/","excerpt":"[TOC] 数据库系统原理事务事务指满足ACID特性的一组操作，可以通过commit 提交，也可以通过rollback回滚 事务的ACID特性 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部成功提交，要么全部失败回滚,回归可以使用回滚日志来实现，回滚事务记录着执行的修改操作，回滚时反向执行即可 一致性（Consistency） 数据在事务的执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结构都是相同的 隔离性（Isolation） 一个事务所做的修改在最终提交以前对其他事务不可见 持久性（Durability） 一旦事务提交，则其所做修改会永远保存到数据库中，即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性","text":"[TOC] 数据库系统原理事务事务指满足ACID特性的一组操作，可以通过commit 提交，也可以通过rollback回滚 事务的ACID特性 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部成功提交，要么全部失败回滚,回归可以使用回滚日志来实现，回滚事务记录着执行的修改操作，回滚时反向执行即可 一致性（Consistency） 数据在事务的执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结构都是相同的 隔离性（Isolation） 一个事务所做的修改在最终提交以前对其他事务不可见 持久性（Durability） 一旦事务提交，则其所做修改会永远保存到数据库中，即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性 事务的ACID特性比较简单，但是并不容易理解，他们并不平级 只有满足一致性，事务的执行结果才是正确的的 在无并发的情况下，事务串行执行，隔离性一定能满足。此时只要满足原子性，一致性即可满足 并发的情况下，多个事务并行执行，事务不仅满足原子性，还要满足隔离性 才能满足一致性 事务满足持久性是为了维护数据库崩溃的情况 事务的自动提交 AUTO_COMMITMySQL默认采用自动的提交模式，即，如果不显示使用START TRANSACTION来开始一个事务，每个查询都会被当做一个事务自动提交 事务的模型抽象成功完成的事务称为已提交，而非成功完成的事务被中止了，为了确保数据的原子性，中止事务对数据库状态不可以造成影响，因此这些影响必须被撤销。一旦中止事务的影响被撤销，我们称事务已回滚 ，数据库通过日志来支持回滚操作 一个简单事务抽象模型包括： 活动的：初始状态，事务执行时处于这个状态 部分提交的：最后一条语句执行后 失败的：发现正常的执行不能继续后 中止的：事务回滚并恢复到事务开始执行的前后 提交的：成功完成后 事务的隔离性事务处理系统通常允许多个事务并发的执行，并发有两条无法拒绝的理由 提高吞吐量和资源利用率 减少等待时间 数据库中并发的动机和多道程序设计的动机是相同的，而为提升效率的同时，我们必须控制事务的交互，来保证数据库的一致性，这被称为系统的并发控制 在并发执行时，通过保证所执行的任何调度效果都与没有并发效果一样，我们可以保持数据库的一致性。调度在某种意义上等价于一个串行调度，这种调度被称为可串行化调度 事务的并发可串行化串行化顺序可以通过拓扑排序得到。 对于优先图来说，读写、写读、写写被称为一条边，考察这个有向图中是否有环，无环的优先图被称为可串行化调度 并发一致性问题在并发环境下，事务的隔离性很难保证，因此可能出现并发一致性问题 问题 原因 图例 丢失修改 T1和T2 两个事务都对一个事务进行修改，T1先修改T2随后修改，T2的修改覆盖了T1的修改 读脏数据 T1修改了一个数据，T2最后读取了这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据 不可重复读 T2读取了一个数据，T1对其进行了修改，如果T2再次读取这个数据，此时读取结果和第一次不同 幻影读 T1读取某个范围内的数据，T2 在这个范围内插入新的数据，T1再次读取这个范围内的数据，此时读取的结果和第一次读取的不同 事务的隔离级别 隔离级别 简介 可串行化 即可串行化调度 可重复读 只允许读取已提交数据，事务两次读取的间隙其他事务不得更新 已提交读 只允许读取已提交的数据，允许同一事务读数据的前后不一致 未提交读 允许读取未提交数据 事务的隔离级别与对应的并发问题 隔离级别/并发问题 脏读 不可重复读 幻影读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行化 × × × √ 隔离级别的实现锁通过封锁来实保证事务的可串行化。通过共享、排他锁及两阶段封锁协议来保证串行化下的并发读 时间戳另一类用来实现隔离性的技术为为每一个事务分配一个时间戳，系统维护两个时间戳来保证冲突情况下按照顺序访问数据项 多版本和快照隔离快照隔离中，我们可以想象每个事务开始时尤其自身的数据库版本或快照，它从这个私有的版本中读取数据，因此它和其他事务的更新隔开。事务的更新只在私有数据库中进行，只有提交时才将信息保存，写入数据库。 并发控制读写锁锁一般被分为两种 共享锁：简称为S锁，又称为读锁 排他锁：简称为X锁，又称为写锁 这两种锁有以下规定 一个事务数据对象加了X锁，就可以对数据A进行读取和更新，加锁期间其他事务不能获得A的锁 一个事务数据对象加了S锁，可以对A进行读取操作，加锁期间其他事务可以对其加S锁，但是不能加X锁 意向锁使用意向锁来支持多粒度的封锁 在行级锁、表级锁的情况下，事务想要对表A加X锁，就要检测其他事务是否对表A和表A的任意一行加了锁，那么就需要对A的每一行都检测，这非常耗时 在X/S锁之外引入了IX、IS，IX和IS都是表锁，用来表示一个事务想在某个表上加X或S锁，有以下规定： 一个事务在获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁 一个数据在获得某个数据航的X锁之前，必须获得表的IX锁 通过引入意向锁，输入想要对某个表A加锁，只需检测事务是否对表A加了x/Ix/S/IS锁 - X IX S IS X × × × × IX × √ × √ S × × √ √ IS × √ √ √ 任意IX/IS 之间都是相容的，因为它只表示要加锁，并没有真正的加锁 S锁只与S和IS兼容 两阶段封锁协议保证事务可串行化的一个协议是两阶段封锁协议，该协议分两个阶段 增长阶段：事务可以获得锁，但是不能释放锁 缩减阶段：事务可以释放锁，但是不能获得新锁","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"操作系统之文件","slug":"操作系统之文件","date":"2018-12-07T13:25:21.000Z","updated":"2018-12-07T13:28:35.964Z","comments":true,"path":"2018/12/07/操作系统之文件/","link":"","permalink":"http://yoursite.com/2018/12/07/操作系统之文件/","excerpt":"[TOC] 内存部分虚拟内存虚拟内存的概念内存管理中进程有如下特征： 一次性：作业必须一次性全部装入内存后才能开始运行 驻留性：作业被装入内存后驻留在内存中，任何部分都不会被唤出直至作业结束 局部性原理 高速缓存是计算机科学中唯一重要的思想。事实上告诉缓存技术极大的影响了计算机系统的设计 -- Bill Joy「SUN 公司 CEO」 时间局部性： 如果程序某条指令一旦执行，不久之后可能会再次被执行；如果某个数据被访问过，不久以后它可能再次被访问 空间局部性：一旦程序访问某个储存单元，不久之后其附近的单元也将被访问。","text":"[TOC] 内存部分虚拟内存虚拟内存的概念内存管理中进程有如下特征： 一次性：作业必须一次性全部装入内存后才能开始运行 驻留性：作业被装入内存后驻留在内存中，任何部分都不会被唤出直至作业结束 局部性原理 高速缓存是计算机科学中唯一重要的思想。事实上告诉缓存技术极大的影响了计算机系统的设计 -- Bill Joy「SUN 公司 CEO」 时间局部性： 如果程序某条指令一旦执行，不久之后可能会再次被执行；如果某个数据被访问过，不久以后它可能再次被访问 空间局部性：一旦程序访问某个储存单元，不久之后其附近的单元也将被访问。 基于局部性原理，程序装入内存时，可以先装入一部分内存，其余部分留在外存。在程序运行过程中，当访问信息不存在时，操作系统将需要信息调入内存；另一方面操作系统将暂时不适用的内容放到外存之中。这样系统好像为用户提供了一个大的多的储存器，称为虚拟储存器 之所以称为虚拟储存器，是因为这种储存器并不存在，只是由于系统提供了部分装入请求和置换功能后，给用户感觉是一个比实际物理内存大的多的存储器。 页面置换算法最佳置换算法「OPT」最佳置换算法选择被淘汰页面是以后用不使用的，或者在最长时间未被访问的页面，这样可以保证最低的缺页率。 该算法是理想算法 ，「无法实现」 先进先出算法「FIFO」优先淘汰最早进入内存的页面，亦即在内存中驻留最久的页面。 算法实现较简单，但是可能出现页故障数随物理块数增大不降反增的状况「Belady」异常 最近最久未使用算法「LRU」选择最近最长时间未访问过的页面予以淘汰，他认为最近一段时间未访问的页面在将来一段时间也不会被访问。 时钟置换算法「CLOCK」「NRU」某次装入内存时，其使用位被置位 1 ，当再次被访问到时，其再被置为 1 当需要替换页时，从缓冲区头部开始扫描，遇到 1 置 0 ；遇到 0 就选择该页置换；依次循环 改进 CLOCK 算法 将使用位再细分为 访问与修改两种状态，修改优先级大于访问 文件部分磁盘的结构磁盘由表面涂有磁性物质的金属或塑料构成圆形盘片，通过一个名为磁头的导线圈从磁盘中读取数据。在读写操作期间， 磁头固定，磁片高速旋转。 磁盘调度算法先来先服务 「FCFS」FCFS根据请求磁盘的先后顺序调度，该算法较为简单 最短寻道时间优先「SSTF」优先调度当前磁头所在磁道最近的磁道 平均寻道时间较低，但是较为不公平。如果新的磁道总是比一个等待的磁道近，等待的磁道会一直等待下去出现饥饿现象 电梯算法当前移动方向上选择当前磁头最近请求作为下一次服务方向。即总是面向一个方向运行，直到该方向没有请求位置，改变运行方向。 程序编译与链接编译系统以下是一个 hello.c 程序 123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello, world\\n\"); return 0;&#125; 在 unix 上, 编译器把源文件转换为目标文件 gcc -o hello hello.c 预处理阶段：预处理以 # 开头的预处理命令 编译阶段：翻译成汇编文件 汇编阶段：将汇编文件翻译成可重定向的目标文件 连接阶段：将可重定向目标文件和 printf.o 等单独编译好的文件进行合并，得到可执行的目标文件 静态链接静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件为输出，链接器主要完成以下任务： 符号解析：每个符号对应一个函数，一个全局变量或静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来 重定位：链接器通过吧每个符号定义与一个内存位置关联起来，修改对这些符号的引用，使他们指向这个内存位置 目标文件 可执行目标文件：直接在内存中执行 可重定向目标文件：可以其他重定向文件在链接阶段合并，传建一个可执行目标文件 共享目标文件：特殊的可重定向文件，在运行时被动态加载进内存并链接 动态链接静态库有以下两个问题： 当静态库更新时，整个程序重新链接 对于 printf 这种标准库函数，每个程序都要都代码，极大浪费资源 共享库是为了解决静态库的问题而设计的，在linux中用.so文件来表示，windows 中被称为dll 它们具有以下特点 在给定的文件系统中一个库只有一个文件，所有引用库的可执行目标都共享这个文件，他不会被复制到他的可执行文件中 内存中共享的副本可以被不同正在运行的进程共享","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"数据库之SQL","slug":"数据库之SQL","date":"2018-12-07T13:14:07.000Z","updated":"2018-12-07T13:22:21.186Z","comments":true,"path":"2018/12/07/数据库之SQL/","link":"","permalink":"http://yoursite.com/2018/12/07/数据库之SQL/","excerpt":"[TOC] SQL初级SQL概览SQL最早版本是由IBM开发的，最初被叫做Sequel。其发展至今被称为SQL（结构化查询语言），最新的SQL标准是SQL：2008 SQL语言有以下部分： 数据定义语言（DDL） 数据操纵语言（DML） 完整性 保存在数据库中的数据必须满足完整性约束 视图定义 事务控制 嵌入SQL和动态SQL 授权","text":"[TOC] SQL初级SQL概览SQL最早版本是由IBM开发的，最初被叫做Sequel。其发展至今被称为SQL（结构化查询语言），最新的SQL标准是SQL：2008 SQL语言有以下部分： 数据定义语言（DDL） 数据操纵语言（DML） 完整性 保存在数据库中的数据必须满足完整性约束 视图定义 事务控制 嵌入SQL和动态SQL 授权 SQL数据定义基本类型 char(n) 固定长度字符串，用户指定长度。如果字符长度不到n，在字符串后面补空格使其至n个字符串长度 varchar(n) 变长字符串 int 整数类型 smallint 小整数类型 numeric(p,d) 定点数，精度有用户指定 float(n) 精度至少为n的浮点数 基本模式12345create table department(dept_name varchar(20),building varchar(15),budget numeric(12,2),primary key(dept_name)); 这里简单讨论几个完整性约束 primary key (A1,A2…Am) primary key 声明属性构成关系主码，主码必须非空且唯一。 foreign key(A1,A2…Am) reference : × foreign key 表示声明关系中的任意元组必须在对应的外键属性上取值 not null 非空 SQL禁止破坏完整性约束的任何数据库更新，例如主码上的空值和重复将会被SQL标记错误并阻止更新 插入、删除和修改 的基本模式： 12345678910111213# 删除模式,（保留关系，只删满足条件的数据）delete from student# 删除模式，（表结构整体删除）drop table r# 修改表结构# 表增加一列alter table r add A D# 表删除一列alter table r drop A# 修改某一列属性（不改名）alter table r modify A D &lt;Y&gt;# 修改某一列属性 （改名）alter table r change A1 A2 D &lt;Y&gt; SQL查询基本结构SQL的基本查询结构由三个基本的子句组成：select from where 我们对其进行一个总结 select 子句用于列出查询结果中需要的属性 from 子句是一个查询求值中需要访问的关系列表 where 子句一个作用在from关系中的谓词 其基本的查询有如下形式 123select A1,A2,...,Anfrom r1,r2,...,rmwhere P 为了较好的理解这个关系的顺序是 from –&gt; where –&gt; select 首先通过from子句定义了一个在子句中列出关系的笛卡尔积，一般来说这个结果可能是一个相当大的关系，这样的笛卡尔积一般是没有意义的。而where子句谓词用来限制from子句所建立的集合，只留下对答案有意义的集合，最后我们可以用select限制结果中需要的子集 自然连接组合信息是一种通用的过程，SQL支持一种被称为自然连接的运算。自然连接运算作用于两个关系，并产生一个关系作为结果。不同于两个关系上的笛卡尔积将第一个关系的每个元组与第二个关系的所有元组都进行连接；自然连接只考虑两个关系模式中都出现且属性相同的元素对。 123select A1,A2,...An from r1 join r2, ... join rnwhere P; 附加基本运算更名运算字符串运算字符串可以使用like来实现模式匹配 % 匹配任意子串 _ 匹配任意一个字符 排序运算where子句谓词集合运算SQL在关系上的union、intersect 、except 分别对应了∪、∩ 及 - 聚集函数基本聚集分组聚集有时候我们不仅希望聚集函数作用力在单个元组集上，也希望作用到一组元组集合上，可以采用group by子句 并利用 having子句限定元组的条件 嵌套查询数据库修改删除12delete from rwhere P; 插入 12insert into rvalues (A1,A2,...) 更新12update instructor set salary = salary * 1.05; 小节SQL 语言分为数据定义语言（DDL）和数据操纵语言（DML） DDL： 定义关系模式、删除、修改关系模式 create alter drop DML: 包括查询语言、插入、修改、删除元组的命令 select insert delete update 连接表达式参与连接的任何一个或两个关系中的某些元组可能会以某种方式丢失，外链接以创建包含空值元组的方式保留了在连接中丢失的元组。 一般的，外链接有三种类型： 左外连接： 只保留出现在左外连接运算之前（左边）关系中的元组 右外连接：只保留出现在右外连接之后（后边）关系中的元组 全外连接：保留出现在两个关系中的元组 事务事务 由查询和更新语句的序列组成，SQL标准规定当一条SQL语句被执行，就隐式的开始了一个事务，下列SQL之一会结束一个事务 Commit work: 提交当前事务，将该事务所做功能新在数据库中持久保存。事务被提交后，一个新的事务自动刚开始 Rollback work：回滚当前事务，即撤销事务中所有的SQL语句对数据库的更新。这样数据库就恢复到执行事务第一条语句前的状态 当系统检测到错误时，事务回滚是有用的。而事务提交就像存盘，一旦commit他的影响就不能用rollback来撤销。数据库保证在发生SQL语句错误、断电、系统崩溃这样的故障情况下，如果事务没有完成commit，其影响将被回滚。如果断电和系统崩溃，回滚会在重启后进行。 一个事务在完成所有步骤后的提交行为，或者在不完成所有动作情况下回滚其动作，这种方式数据库提供了了对事务的 原子性 抽象，原子性也就是不可分割性，事务的影响被反映到数据库中，或是任何影响都没有。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"操作系统之进程","slug":"操作系统之进程","date":"2018-12-07T13:11:54.000Z","updated":"2018-12-07T13:22:35.897Z","comments":true,"path":"2018/12/07/操作系统之进程/","link":"","permalink":"http://yoursite.com/2018/12/07/操作系统之进程/","excerpt":"[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。 进程具有动态性（有着创建、活动、暂停、终止等过程，具有生命周期）、并发性（多个进程在一段时间内同时运行）、独立性（进程是一个独立运行、获得资源和接收调度的基本单位）、异步性（进程按照独自的、不可预知的速度前进）、结构性（每个进程都有一个PCB对其描述）","text":"[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。 进程具有动态性（有着创建、活动、暂停、终止等过程，具有生命周期）、并发性（多个进程在一段时间内同时运行）、独立性（进程是一个独立运行、获得资源和接收调度的基本单位）、异步性（进程按照独自的、不可预知的速度前进）、结构性（每个进程都有一个PCB对其描述） 进程的状态 运行状态：进程在处理机上运行 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机以外的一切所需资源，只需得到处理机即可执行 阻塞状态（等待/封锁状态）：进程正在等待某一事件而暂停运行。特点是即使处理机空闲也不能运行 创建状态：进程正在创建尚未转到就绪状态。创建进程通常需要经过几个步骤：申请空白PCB、向PCB写入控制和管理进程的信息，然后为该进程分配运行时所必须的资源，最后将其转入就绪状态 结束状态：进程从系统中消失，这可能是因为正常结束或其他原因中断退出。当进程结束运行时，系统首先置该进程为结束状态，进一步处理资源释放和回收等工作。 进程控制 进程控制是指对系统中的进程实施有效管理。一般把控制进程的程序段称为原语，原语的特点是执行期间不允许中断，它是不可分割的单位。 进程的创建引起进程创建的事件1. 用户登录：分时系统中，每一个用户登录都可以被看做是一个新的进程。系统为该终端建立一个进程并插入就绪队列 2. 作业调度：批处理系统中，当系统按照一定算法调度到某作业时，便将该作业调入内存并为其分配资源，创建进程，插入就绪队列 3. 提供服务：运行中的用户提出某种请求后，系统为其创建一个进程来提供用户需要服务 4. 应用请求；前三种是系统创建进程，而用户基于自己的需求可以创建新进程，以便用户并发的完成特定任务。 进程的创建过程 进程创建原语create 1. 为进程申请一个唯一的进程识别号与一个空白的PCB 2. 为进程分配资源，为新进程的程序和数据、用户栈分配内存空间 3. 初始化PCB，主要包括初始化标志信息，状态信息及处理机控制信息 4. 如果就绪队列能够接纳新进程，插入就绪队列等待被调度运行 进程的终止引起进程终止的事件1. 正常结束 2. 异常结束：出现某种错误或故障导致程序无法进行，如：越界错误、非法指令、运行超时、等待超时、IO故障 3. 外界干预：进程应外界请求而终止 进程的终止过程 进程终止原语destroy 1. 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，并读取进程状态 2. 若进程处于执行状态，立即终止该进程，并置调度标志为真 3. 若进程还有子孙进程，将其所有子孙进程终止，以防其不可控 4. 将终止进程的所有资源释放给系统或父进程 5. 将被终止进程移出所在队列 进程的阻塞与唤醒进程的阻塞 阻塞原语block 正在执行的进程，由于期待某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达，系统自动执行阻塞原语(block)，是自己由运动态转为阻塞态，可见阻塞是一种主动现象 阻塞过程 1. 找到要阻塞的标识号对应的PCB 2. 若进程为运行态，则保护现场，将其运行状态转为阻塞，停止运行 3. 将PCB插入相应的时间等待队列中去 进程的唤醒 唤醒原语wakeup 当被阻塞的进程所期待的出现时，如它启动的I/O操作所期待的数据已到达，则有关进程调用唤醒原语（wakeup）将该进程唤醒 唤醒过程 1. 在事件的等待队列中找到进程的PCB 2. 将其从等待序列中移除，并置为就绪状态 3. PCB插入就绪队列，等待进程调度 进程的挂起与激活进程的挂起挂起原语：suspend() 当出现了进程挂起事件时，比如用户请求挂起自己的进程，或父进程挂起子进程。 进程的激活激活原语：active() 当激活的事件发生时，例如父进程或用户进程请求激活子进程，若进程驻留在外存而内存有足够的空间时，将外存的进程换入内存 进程通信进程间通信主要包括三种：共享储存、消息传递、管道通信 共享储存在通信的进程之间存在一块可以直接访问的共享空间（内存），这块内存由一个进程创建但是多个进程都可以访问。共享内存是最快的IPC方式，它是专门针对其他通信方式的低效而设计的。与其他通信机制配合（如信号量）来实现进程的同步和通信 消息传递消息以格式化的形式为单位，通过一个缓冲队列发送至另一个进程。该缓冲队列可能由操作系统提供。 管道通信管道是进程通信的一种特殊方式，指连接一个读进程和一个写进程实现他们通信的共享文件。为了协调双方通信，管道机制必须提供以下协调能力：互斥、同步、确定对方存在。 linux中管道是一种频繁使用的机制，本质上管道是一种文件，克服通信上的两个问题： 当写进程较快，限制管道大小，linux中该管道大小为4KB，这样缓存大小不会无限制增长。当管道满时，管道对write的调用被阻塞 当读进程较快，管道空后，read操作被阻塞 管道是半双工的，同一时刻只能单向传输。管道可以作为一共享储存的一个优化，利用缓冲区实现了读写的同步。 线程线程的概念与特征引入线程的目的是为了更好的使多道程序并发执行，以提高资源利用率与吞吐量，减小程序并发执行付出的时空开销，提高操作系统的并发性能。 线程是“轻量级进程”，是一个基本的CPU执行单元。由线程ID、程序计数器、寄存器和堆栈组成。线程是进程中的一个实体，是被系统调度和分派的独立单位。线程不拥有系统资源，线程只有就绪、阻塞、运行三种状态 引入线程后，进程只作为除CPU外系统资源的分配单元，线程则作为CPU的分配单元。这样同一进程内线程的切换开销很小。 线程的属性多线程的操作系统中，线程作为独立运行的基本单位，进程的执行实际上是进程的某个线程在执行 线程是一个轻型实体，不拥有系统资源，每个线程有唯一的标识符和线程控制块。 不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统建成不同的线程 同一进程各个线程共享进程拥有的资源 线程是处理机调度的独立单位，多个线程可以并发执行。在单CPU计算机中线程交替的占用CPU，多CPU中线程可以同时的占有不同的CPU 线程的实现线程分为两类：用户级线程 和 内核级线程 用户级线程中，线程的管理工作由应用程序完成，内核意识不到线程的存在。 内核级线程中，线程的管理工作由内核完成，引用程序没有进行线程管理的代码，只有一个内核级线程的编程接口，线程的调度也是在内核线程的基础上完成的。 还有组合式的方式 进程与线程的比较调度引入线程的操作系统中，线程是调度和分派的基本单位。在同一个进程的中，线程的切换不会引起进程的切换。 拥有资源进程是拥有除CPU外其他资源的基本单位，程序运行所需要的必要资源（程序、PCB、堆栈）都由进程所有。一般而言线程不占有系统资源（除了一些必不可少的资源），其访问隶属于进程的资源 并发性进程之间可以并行运行，同一进程的线程间也可以并发运行 创建和开销进程的创建和撤销，系统都要为之创建、回收PCB，分配和回收资源。操作系统付出的代价比较大。而线程的创建和撤销比较简单。 进程调度调度层次作业调度高级调度，主要任务是按一定原则从外存中将处于后备状态的作业挑选1个或几个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度） 中级调度进程的挂起与就绪 进程调度低级调度，某种方法和策略从就绪队列中选取一个进程，为其分配处理机。进程调度是最基本的调度，频率很高，一般几十毫秒一次 调度算法先来先服务（FCFS）算法FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度 FCFS是不可剥夺算法，长作业会使后到的短作业长期等待。 特点：算法简单，效率低，对长作业有利，有利于CPU繁忙性作业 短作业优先（SJF）算法从后背队列中选择一个或若干个估计运行时间最短的作业调入内存运行 特点：对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态。 优先级调度算法优先级调度算法每次从后背队列中选取优先级最高的一个或几个作业 特点：优先级调度可以剥夺式占有，也可以非剥夺式占有 高响应比优先高响应比有限主要用于作业调度，该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比。 响应比的计算为（等待时间+要求服务时间）/ 要求服务时间 时间片轮转调度算法时间片轮转算法适用于分时系统，系统将所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms。 特点：受系统响应时间影响、队列进程数目、进程长短影响较大 多级反馈队列调度算法多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展 1） 设置多个就绪队列，为各个队列赋予优先级，1、2、3等等 2） 赋予各个队列中时间片大小不同，优先级高时间片越小 3） 一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行 4） 仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推。 进程同步临界区虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源。 // entry // critical section // exit section 同步与互斥同步：进程之间具有直接制约关系，进程之间需要按照一定的次序进行 互斥：进程之间的间接制约关系，不能同时访问临界区 信号量信号量是一个整形变量，可以被定义为两个标准的原语wait(S) signal(S) 即P、V操作 P操作 如果信号量大于0，执行 -1操作，如果等于0，执行等待信号量大于0 V操作 对信号量完成加1操作，唤醒睡眠的进程 123456789101112typedef int semaphoresemaphore mutex = 1 void P1()&#123; P(&amp;mutex); //临界区 V(&amp;mutex);&#125;void P2()&#123; P(&amp;mutex); //临界区 V(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品 由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问 为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区 12345678910111213141516171819202122232425262728# define N 100typedef int semahporesemaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer()&#123; while(True)&#123; int item = produceItem(); P(&amp;empty); P(&amp;mutex); Item.push(item); V(&amp;mutex); V(&amp;full); &#125;&#125;void consumer()&#123; while(True)&#123; P(&amp;full); P(&amp;mutex); int item = Item.top(); Item.pop(); consume(item); V(mutex); V(&amp;empty()) &#125;&#125; 管程使用信号量机制生产消费问题客户端代码需要很多控制，管程作用是把控制的代码独立出来。 管程有一个重要作用：一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用 管程的生产者消费者实现 12345678910111213141516171819202122232425262728293031323334353637383940monitor ProducerConsumer condition full, empty; integer cout :=0; function insert(item:integer); begin if count = N then wait(full) insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remote(item:integer); begin if count = 0 then wait(empty); item = remove_item(item); count := conut-1; if count = N-1 then signal(full); return item; end;end monitor;//生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item) endend;procedure consumerbegin while true do begin item = ProducerConsumer.remove() consume(item); endend; 读者-写者问题问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行 用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁 12345678910111213141516171819202122typedef int semaphoresemaphore count = 0;semaphore read_mutex = 1;semaphore write_mutex = 1;void read()&#123; P(&amp;read_mutex); count++; if(count==1) P(&amp;write_mutex); V(&amp;read_mutex); read(); p(&amp;read_mutex); count--; if(count==0) V(&amp;write_mutex); V(&amp;read_mutex);&#125;void write()&#123; P(&amp;write); write(); V(&amp;write);&#125; 哲学家进餐问题问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根 如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待 1234567891011121314151617181920212223242526typedef int semaphoresemaphore chop[5] = &#123;1,1,1,1,1&#125;;semaphore mutex = 1;void process()&#123; while(true)&#123; P(&amp;mutex); /* if(chop[i]&amp;&amp;chop[(i+1)%5]) &#123; P(chop[i]); P(chop[(i+1)%5]); &#125; else&#123; V(&amp;mutex); break; &#125; */ P(chop[i]); P(chop[(i+1)%5]); V(&amp;mutex); eat(); V(chop[i]); V(chop[(i+1)%5]); &#125;&#125; 死锁死锁的定义：多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。 死锁四个必要条件： 互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。 不剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放 请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。 循环等待条件：存在某一进程的循环等待链，链中每个进程已获得资源下个进程的请求。 死锁的处理策略死锁的处理便是破坏四个必要条件，使得死锁无法发生 鸵鸟策略把头埋在沙子里，假装问题没有发生 由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能。 大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略 死锁预防 破坏互斥条件 对于可共享的资源竞争，不会发生死锁 破坏不剥夺状态 当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要是再重新申请 破坏请求 和 保持条件 预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归期所有。 破坏循环等待 资源顺序分配法，例如为资源编号，每个进程申请分配某个资源以后，再之后只能申请该编号以后的资源 死锁避免系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1、P2,,)称为安全序列。如果无法找到安全序列，则系统处于不安全状态。 允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则，进程等待 银行家算法 银行家算法是最著名的死锁避免算法。它的思想是，把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款。 进程申请资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源 死锁检测和接触死锁检测死锁解除 资源剥夺法 挂起死锁进程，抢占其资源分配给其他进程 撤销进程法 强制撤销一些死锁进程 进程回退法 借助历史信息使一个或多个进程回退到系统不再死锁的地步","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"欢迎来到Eyc的博客！","slug":"欢迎来到Eyc的博客!","date":"2018-11-11T12:06:38.000Z","updated":"2018-12-07T02:04:45.894Z","comments":true,"path":"2018/11/11/欢迎来到Eyc的博客!/","link":"","permalink":"http://yoursite.com/2018/11/11/欢迎来到Eyc的博客!/","excerpt":"","text":"欢迎来到我的博客！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"HTTP","slug":"HTTP","date":"2018-11-11T11:54:23.000Z","updated":"2018-12-07T13:08:58.983Z","comments":true,"path":"2018/11/11/HTTP/","link":"","permalink":"http://yoursite.com/2018/11/11/HTTP/","excerpt":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击）","text":"HTTPHTTP方法客户端发送的请求报文第一行包含了方法字段 GET 获取资源，绝大多数请求是GET方法 HEAD 获取报文首部，和get方法一样但是不返回报文实体部分。主要用户URL有效性及资源更新日期时间 POST POST主要用来传输数据 PUT 上传文件（由于本身不带验证机制，存在安全机制一般不用） PATCH 部分修改资源 DELETE 与PUT功能相反，同样不带验证机制 OPTIONS 查询URL支持的方法 CONNECT 要求在与代理服务器通信时建立隧道，使用SSl和TSL TRACE 追踪路径，服务器会把通信路径返回客户端（通常不会用，易受攻击） GET与POST的区别作用GET用于获取资源，POST用于传输实体主体 参数GET和POST都能使用额外的参数，但是GET参数以查询字符串的形式出现在URL中，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin 这个过程用户可见。而POST的参数存储在实体主体中。通过HTTP的POST机制。POST参数可以通过一些抓包工具（Fiddler）查看 因为URL只支持ASCLL码，因此GET参数中文会被编码，空格被编码为%20 安全安全的HTTP方法不会改变服务器状态，可以说他是只读的 GET方法安全的，POST不是，POST方法传输主体内容，这个内容可能是某个表单数据，服务器可能把其存入数据库中，这样状态就发生了改变 幂等性幂等性的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。 所有安全的方法是幂等的，GET、HEAD、PUT、DELETE方法都是幂等的 而POST方法不是幂等的 XMLHTTPRequestXMLHTTP Request是一个API，它为客户端和服务器之间传输数据的功能。他提供了一个URL来获取数据的简单方式，而且不会使整个页面刷新。这使得网页只更新一部分不会打扰到用户，在AJAX中被大量使用 在xmlhttprequest中POST会先发送header再发送data（当然也和浏览器的做法相关） 而get方法会一起发送 其他Get传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递 Get方式只支持ASCII字符，向服务器传输的中文字符可能会乱码。POST支持标准字符集，可以正确的传递中文字符 HTTP 首部 Request Header 解释 某度首页示例 Accept 客户端能够接受的内容类型 text/html Accept-Encoding 浏览器可以支持的web服务器返回内容压缩编码类型 gzip Accept-Language 浏览器可以接受的语言 zh-CN Cache-Control 指定请求和相应遵循的缓存机制 max-age=0 Connection 表示是否需要持久连接 keep-alive Cookie HTTP请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器 键值对 Host 请求服务器的域名和端口号 www.baidu.com Upgrade-Insecure-Requests 浏览器可以处理HTTPS协议 1 User-Agent 发出请求的用户信息 Mozilla/5.0 HTTP 首部 Response Header 解释 某度首页示例 Cache-Control 告诉所有的缓存机制是否可以缓存及缓存哪种类型 private Connection 是否保持持久连接 keep-alive Content-Encoding 返回内容压缩编码类型 gzip Content-type 返回内容的MIME类型 text/html charset=utf-8 Date 原始服务器消息发出时间 Wed 03 Oct2018 12:04:45 GMT Expires 响应过期的时间 Wed 03 Oct2018 12:04:45 GMT Server Web服务器软件名称 BWS1.1 Set-Cookie 设置浏览器缓存 BDSVRTM=114; path=/ Transfer-Encoding 文件传输编码 chunked HTTP状态码HTTP中状态码大致分为五大类： 100-199 信息性状态码 100 continue： 收到了请求的初始部分，请客户端继续 200-299 成功状态码 200 OK：请求被正常处理 204 No Content: 请求被接受，但是响应报文只有首部和状态行，没有实体部分 206 Partial Content: 客户端只请求了一部分的资源，服务器只针对请求的部分资源进行返回 300-399 重定向状态码 301 Moved Permanently: 永久重定向 302 Found: 临时重定向，资源被临时移动了 303 See Other: 表示用户请求的资源代表着另一个URI，应该使用GET去获取资源 304 Not Modified: 当客户端发送的请求附带条件时，服务器找到资源但未符合请求 307 Temporary Redirect: 同302，临时重定向 400-499 客户端错误状态码 400 Bad Request: 告知客户端它发送了一个错误的请求 401 Unauthorized: 请求需进行认证 403 Forbidden: 请求被服务器拒绝了 404 Not Found：服务器无法找到对应资源 405 Method Not Allowed：请求中带有不支持的方法 500-599 服务器错误状态码 500 Internet Server Error: 服务器内部错误 502 Bad GateWay： 代理或网关服务器从下一条链路收到了伪响应 503 Server Unavailable: 服务器正忙 504 GateWay Timeout: 一个代理网关等待另一服务器时超时了 持续性连接和非持续性连接1. 定义非持续连接：每个请求、相应都经一个而单独的TCP连接发送 持续连接：所有的请求相应通过相同的TCP连接发送 2. 区别如果采用非持续连接，打开包含一个HTML文件和10个内联对象网页，HTTP需要建立11次TCP连接才能把文件从服务器传到客户机。而如果采用持续连接，HTTP建立一次TCP就把文件从服务器传到客户机 每次TCP连接必需建立和断开（通过三次握手建立、四次挥手断开），这都需要占用CPU资源，这样占用客户机和服务器的CPU时间大大减少 每次连接，客户端和服务器都必须分配发送和接收缓存，这意味着影响服务器和客户机的资源，着同样要占用CPU时间 对于大量对象组成的文件，TCP低速启动算法会限制服务机向客户机传送对象的速度。使用HTTP/1.1后，大多数对象以最大速率传输 3. HTTP/1.0 + keep-aliveHTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live connection:keep-live 是HTTP1.0 浏览器和服务器的实验性扩展 Cookie 与 Session由于HTTP是无状态协议，为了保持客户端与服务器的一些关系，便有了cookie和session 1.cookiecookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。网络服务器用HTTP头想客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。 内容 过期时间会话cookie：若不设置过期时间，则表示这个cookie的生命周期为浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie 持久cookie：若设置了过期时间，浏览器会把cookie存储到硬盘上（当然用户可以选择拒绝），关闭后再打开这些cookie仍然有效 2.sessionsession机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息 当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。 session_id的储存 保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session 由于cookie可以被认为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符 另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id 3. cookie与session的区别存取方式不同cookie只能保存ASCII字符，Unicode及二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较为艰难。而session中能够存取任何类型的数据，包括不限于string、integer、list、map，而且可以直接存取java的类对象，十分方便 隐私策略不同cookie存储在客户端阅读器中，对客户端可见，客户端可以窥探甚至是修改cookie内容。而session存储在服务器上对用户透明，不存在泄露风险。cookie可以像google及baidu一样将敏感信息加密后保存，在服务器上进行解密。 有效时间不同由于session依赖于session_id的cookie，而session_id过期时间默许为-1，关闭浏览器即消失。而cookie可以设置长期的保存 服务器压力不同由于不同的储存方式，储存在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大 浏览器支持不同cookie是需要客户端浏览器支持的，假如客户端禁用了cookie或者不支持cookie，则会话跟踪会失效。 假如客户端不支持cookie，就需要运用session及url地址重写。需要注意的是一切用到session的程序url都需要进行重写，否则session会话还是会失效 跨域支持不同cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用 session仅在当前域名有效 其他一个web页面的请求过程1.DHCP配置主机信息（找本机IP） 主机生成一个DHCP请求报文，并将这个报文放入目的端口67和源端口68的UDP报文段中 该报文段放在一个广播IP地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中 该数据报被放在MAC帧中，目的地址FF:FF:FF:FF:FF:FF，广播到交换机连接的所有设备 交换机的DHCP服务器收到广播帧后，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括 IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码，再经过层层封装到MAC帧中 该帧的目的地址是主机的mac地址，主机收到该帧后分解得DHCP报文，之后配置IP地址，子网掩码、DNS服务器IP地址，安装默认网关 2.ARP解析网关MAC地址（找网关MAC地址） 主机通过浏览器生成一个TCP套接字，为了发送HTTP请求，需要知道网站对应的IP地址 生成一个DNS查询报文，端口53（DNS服务器） DNS查询报文放入目的地址为DNS服务器IP地址的IP数据报中 IP数据报放入一个以太网帧中，发送至网关路由器 DHCP过程只知道网关的IP地址，为了获取网关的MAC地址，需要用ARP协议 主机生成一个目的地址为网关路由器IP的ARP查询报文，放入一个广播帧中，并发送这个以太网帧，交换机将其发送给所有的连接设备 网关接收到该帧后，分解得到ARP报文，发现IP地址与自己想匹配，发送一个ACK报文回应自己的MAC地址 3.DNS解析域名（找服务器IP） 知道了DNS的MAC地址后就可以继续DNS解析过程 网关接收到DNS查询报文后，抽出IP数据报，并根据该表选择该转发的路由器 路由器根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项 之前的DNS报文到DNS服务器后，照常依次抽出报文，在DNS库中查找解析域名 找到DNS记录后发送DNS回答报文，然后将其放入UDP报文段、IP数据报，通过路由器反转发回网关路由器，经过交换机到主机 4. HTTP请求页面 有了HTTP服务器的IP地址后，主机便可以生成TCP套接字，向web服务器发送HTTP get报文 建立HTTP连接前需要进行TCP连接，进行三次握手，过程略 建立连接后发送HTTP的GET报文，交付给HTTP服务器 HTTP服务器从TCP中读出报文，生成HTTP相应报文，将web页面放入HTTP报文主体中发挥主机 浏览器收到HTTP相应报文后抽取WEB页面内容进行渲染，显示web页面","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"TCP与UDP","slug":"TCP与UDP","date":"2018-11-11T11:49:28.000Z","updated":"2018-12-07T13:09:24.376Z","comments":true,"path":"2018/11/11/TCP与UDP/","link":"","permalink":"http://yoursite.com/2018/11/11/TCP与UDP/","excerpt":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制","text":"TCPTCP 的连接与断开TCP与UDP部分感觉与网络考研书上讲的比较接近，重点内容包括TCP的三次握手、四次挥手、TCP可靠传输、流量控制、拥塞控制 TCP三次握手 第一步：客户机的TCP首先向服务器的TCP发送一个请求连接报文段。这个特殊的报文段不包含应用层数据，其中首部的SYN标志位被置位1.另外客户机会随机选择一个起始序号seq=x 第二步：服务器的TCP收到请求的报文后，如同意建立连接，就向客户机发回确认，并为该TCP分配TCP缓存和变量。在确认报文段中，SYN和ACK被置为1，确认号的字段值为x+1 第三步：客户机收到确认报文段后向服务器给出确认，并且给该连接分配内存和变量，ACK置1，确认号为y+1 为什么TCP进行三次握手？本质上TCP协议的三次握手需要解决这样一个问题：在不可靠的信道上（IP数据报尽最大努力交付）完成可靠的数据传输。而全双工的连接建立需要双方的连接请求和确认，这样最少需要使用三次握手才能建立连接 至于为什么三次是最少，客户端服务器二者最少都需要向对方发送一个同步报文（SYN），但是如果只有这两次握手，服务器就只能接受连接，无法确认连接；设想如果服务器接受一个SYN报文就建立连接，那客户端因为阻塞原因重发了N个SYN同步报文 ，服务器每接受到一个就需要建立一次连接，这是不堪设想的。所以只有当服务器接收到客户端第二次的ack确认报文后才会建立连接 TCP四次挥手断开连接 客户端请求断开FIN1（客户端无更多数据） 服务器ACK确认（收到，但是仍有数据传输） 服务器请求断开FIN2（服务器无更多数据） 客户端ACK确认 四次挥手中的状态 FINWAIT1 : 当客户端在established状态想要断开连接，主动向服务器器发送FIN报文，此时该socket便进入FINWAIT1状态 FINWAIT2: 这时客户端已经收到对方的确认ack,但是服务器可能还有数据未发送完成，还需要接受对方的数据，处于半连接（半关闭）状态 TIME_WAIT: 客户端接受到了对方的确认报文、也接收到了对方的fin报文，现在发出了最后的确认报文，进入一个2MSL的等待状态，如果等待状态没有重发便进入结束状态 CLOSE_WAIT : 服务器确认了客户端的终止请求，还有数据待发送 LAST_CHECK: 服务器方发送FIN后，最后等待对方的ACK报文 CLOSED : 连接中断 为什么需要四次握手TCP是全双工的协议，通信中双方都需要知道对方的存在，而在结束时，双方也同时需要发送断开与确认对方的断开信息。当主机1发送FIN希望断开连接时，主机1已经没有要发送的数据了，但是其还是有可能接受主机2发送的数据，此时单方面的连接断开了，这时处于半连接状态。而只有主机2也向主机1发送断开请求并确认，双方才完全的断开。 TCP的半打开状态如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常。 半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理 同时打开与同时关闭两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2 发送SYN同步信息的同时，B:port2 也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。 而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段 TCP可靠传输TCP的任务是在IP层不可靠的、尽力而为的服务基础上建立的一种可靠的传输服务。TCP使用了校验、序号、确认和重传来达到这个目的，这里主要说一下重传，重传分两种 超时重传TCP 每发送一个报文段，就对这个报文段进行一次计时，只要计时器到期而没有收到确认的的报文，就会重传这一报文。一个报文发出到确认的时间成为RTT(Round-Trip Time)，TCP使用一了一种动态适应算法来调整RTT，而时间阈值与该RTT相关 冗余ACK（快速重传）超时重传存在一个问题就是超时周期往往太长。幸运的是存在另一种方法，在超时前通过冗余ACK来较好的检测丢包情况。 TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一接期待的序号.例如发送方发送了1、2、3、4、5的TCP报文段，其中2号报文段在传输中丢失，这样3、4、5号报文段对于B来说称为了失序报文段。在本例中，3、4、5都会发送一个针对1号报文段的冗余ACK表示自己想要接收2号报文段。TCP规定发送方收到同一个报文段的3个冗余ACK时，就可以认为跟在这个报文段之后的报文已经丢失，这种技术被称为快速重传 TCP流量控制TCP流量控制服务消除接受方缓存区溢出的可能，可以说是一个速度匹配服务。 流量控制基于滑动窗口。发送方维护一个接受窗口，在TCP首部的窗口字段中声明，表示接收方可以接受的窗口大小，防止接受方报文队列溢出。 TCP流量控制与链路层流量控制的区别是，TCP是端到端的流量控制，由发送方与接收方商议。而链路层的流量控制是相邻中间节点的流量控制。而且TCP滑动窗口可变，后者不可变 TCP拥塞控制慢开始和拥塞避免 慢开始算法 TCP连接建立时，先令cwnd窗口=1,即一个最大的报文段长度。每次收到一个确认报文段，将cwnd+1。使用慢开始算法，会使得每一个传输轮次后cwnd加倍，这样它会一种指数增长到一个限定值 拥塞避免算法 拥塞避免算法的做法是每经过一个往返时延RTT就增加一个MSS的大小，这样cwnd按线性规律增长 网络拥塞的处理 使用慢开始算法，cwnd从1开始指数增大 当cwnd达到ssthresh时，启用拥塞避免算法，cwnd线性增大 当网络发生拥塞时，将cwnd置1从头慢开始算法；将ssthresh设置为拥塞值的一半 快重传和快恢复 快重传 当发送方收到3个冗余ACK的报文时，直接重传对方尚未收到的报文段而不必等待 快恢复 当发送端连续接收到3个冗余ACK后，执行乘法减小算法。将慢开始的额门限ssthresh设置成拥塞cwnd的一半，将cwnd值设置为拥塞cwnd的一半，并执行拥塞避免算法 UDPUDP简介UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测 UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和 UDP无需建立连接 UDP不维护连接状态 UDP分组首部开销小 UDP没有拥塞控制，适合容许一些数据丢失但是不允许有较大时延的应用 TCP和UDP的区别TCP和UDP协议特性的区别，主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲 TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接 TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会 TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达 TCP必须进行数据验校，UDP的校验可选 TCP有流量控制（滑动窗口）和拥塞控制，UDP没有 TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制 TCP包头较大（20字节）UDP较小（8字节） 基于TCP协议：HTTP/HTTPS、Telnet、FTP、SMTP 基于UDP的协议 DHCP、DNS、SNMP、TFTP、BOOTP","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Python测试","slug":"Python测试","date":"2018-11-10T09:49:22.000Z","updated":"2018-11-10T09:53:30.766Z","comments":true,"path":"2018/11/10/Python测试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python测试/","excerpt":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"测试测试指通过运行程序以确定它是否按预期工作。我们通常需要将代码和规范结合起来，进行各种路径探索，并在基础上探究一种启发式方法。基于代码探索的路径启发式方法称为白盒测试，基于规范路径的启发式方法称为黑盒测试 测试一般分为两个阶段。第一个阶段称为单元测试。这个阶段测试者构建并执行测试，来确定代码每个独立单元是否正常工作。第二个阶段称为集成测试，用来确定整个程序是否能按预期进行。实际工作中需要不断重复这两个阶段 调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() Python中提供了单元测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950```pythonimport unittestclass TestIntSet(unittest.TestCase): def setUp(self): print(&apos;before Testing...&apos;) def test__init__(self): s = IntSet() self.assertTrue(isinstance(s.getMembers(), list)) def test_insert(self): s = IntSet() s.insert(1) self.assertEqual(s.getMembers(), [1]) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test_member(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) self.assertFalse(s.member(2)) def test_remove(self): s = IntSet() s.insert(1) self.assertTrue(s.member(1)) s.remove(1) self.assertFalse(s.member(1)) def test_getMembers(self): s = IntSet() s.insert(1) s.insert(2) self.assertEqual(s.getMembers(), [1,2]) def test__str__(self): s = IntSet() s.insert(5) s.insert(1) s.insert(2) self.assertEqual(s.__str__(), &apos;&#123;1,2,5&#125;&apos;) def tear_Down(self): print(&apos;after Testing...&apos;)if __name__ == &apos;__main__&apos;: unittest.main(argv=[&apos;ignored&apos;, &apos;-v&apos;], exit=False)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python面向对象","slug":"Python面向对象","date":"2018-11-10T08:48:28.000Z","updated":"2018-11-10T09:49:09.130Z","comments":true,"path":"2018/11/10/Python面向对象/","link":"","permalink":"http://yoursite.com/2018/11/10/Python面向对象/","excerpt":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。","text":"类与面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象思想的优点 可重用性 编写可重用模块，比如类 可扩展性 要求应用软件能够很方便、很容易的进行扩充和修改 可管理性 采用封装了数据和操作的类作为构建系统的部件，使项目组织更加方便合理 抽象数据类型与类抽象数据类型概念十分简单，抽象数据类型是由一个由对象及对象上操作组成的集合，对象和操作被捆绑成一个整体，可以从程序的一部分传递到另一部分。这个过程中不仅可以使用对象的数据属性，还可以使用对象上的操作。 类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现的分离编程技术。类的接口包含用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数以及定义类的各种私有函数。封装实现了类接口和实现的分离，封装后的类隐藏了实现细节，类用户只能访问接口而无法访问实现部分————-《c++ Primer》 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） Exp11234567891011121314151617181920212223242526272829class IntSet: \"\"\"实现一个整数集合\"\"\" def __init__(self): \"\"\"创建一个空的整数集合\"\"\" self.__vals = [] def insert(self, e): if e not in self.__vals: self.__vals.append(e) def member(self, e): return e in self.__vals def remove(self, e): try: self.__vals.remove(e) except: raise ValueError(str(e) + 'not found') def getMembers(self): return self.__vals[:] def __str__(self): self.__vals.sort() result = '' for e in self.__vals: result = result + str(e) + ',' return '&#123;'+ result[:-1] + '&#125;' Exp212345678910111213141516171819202122232425262728293031323334import datetimeclass Person: def __init__(self, name): self.name = name try: lastBlank = name.rindex(' ') self.lastName = name[lastBlank+1:] except: self.lastName = name self.birthday = None def getName(self): return self.name def getLastName(self): return self.lastName def setBirthday(self, birthdate): self.birthday = birthdate def getAge(self): if self.birthday == None: raise ValueError('not set birthday') return datetime.date.today().year-self.birthday.year def __lt__(self, other): if self.lastName == other.lastName: return self.name &lt; other.name return self.lastName &lt; other.lastName def __str__(self): return self.name Exp312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Student(Person): nextIdNum = 0 def __init__(self, name): Person.__init__(self, name) self.idNum = Student.nextIdNum Student.nextIdNum += 1 def getIdNum(self): return self.idNum def __lt__(self,other): return self.idNum &lt; other.idNumclass Grades: def __init__(self): self.students = [] self.grades = &#123;&#125; self.isSorted = True def addStudent(self, student): if student in self.students: raise ValueError('Duplicate student') self.students.append(student) self.grades[student.getIdNum()] = [] self.isSorted = False def addGrade(self, student, grade): try: self.grades[student.getIdNum()].append(grade) except: raise ValueError('Student not in mapping') def getGrades(self,student): try: return self.grades[student.getIdNum()][:] except: raise ValueError('Student not in mapping') def getStudents(self): if not self.isSorted: self.students.sort() self.isSorted = True return self.students[:] def gradeReport(self): report = '' for s in self.getStudents(): tot = 0.0 numGrades = 0 for g in self.getGrades(s): tot += g numGrades +=1 try: average = tot/numGrades report = report + '\\n' + str(s) + '\\'s mean grade is '+ str(average) except ZeroDivisionError: report = report + '\\n' + str(s) + 'has no grade ' return report","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python异常与断言","slug":"Python异常与断言","date":"2018-11-10T08:13:57.000Z","updated":"2018-11-10T08:29:48.665Z","comments":true,"path":"2018/11/10/Python异常与断言/","link":"","permalink":"http://yoursite.com/2018/11/10/Python异常与断言/","excerpt":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。","text":"异常与断言异常“异常”通常被定义为“不符合规范的东西”但是在Python中，异常十分常见，简直到处都是。实际上，Python库中所有的模块都使用了异常 我们经常将异常当做致命错误处理，异常发生时程序会终止，我们回到代码试图搞清楚为什么出错，程序因为一个异常被抛出而终止时，我们称程序抛出了一个未处理异常 很多时候，异常是程序员应该预料到的事情，比如程序试图打开一个不存在的文件。 下面是一个典型异常的例子 12345SuccessNum = input('Enter SuccessNum: ')totalNum = input('Enter totalNum: ')ac = int(SuccessNum)/int(totalNum)print('The AC ratio is',ac)print('Now here') 该段程序在大多数情况下是运行良好的，但是如果用户输入中出现了0，（或者干脆直接跳过）程序就会崩溃，这显然不是我们乐意看到的我们可以以下方式改写这段程序 12345678910try: SuccessNum = input('Enter SuccessNum: ') totalNum = input('Enter totalNum: ') ac = int(SuccessNum)/int(totalNum) print('The AC ratio is',ac)except ZeroDivisionError: print('Failure ! totalNum is 0')except ValueError: print('Error ! No input')print('Now here') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 异常的讨论异常看上去不太友好（毕竟如果不处理程序会崩溃），但总好于其他方式。使用异常时，程序员需要编写一些代码来处理特定异常。如果忘记处理某个异常那么这异常抛出时，程序便立刻停止。当然这也是好事，线性错误总好于隐士错误，我们来讨论BUG的问题。 显性-&gt;隐性 显性错误有明显表现，如程序崩溃或运行时间长；隐性错误没有正常表现，程序正常结束，不会出任何问题–错了给出一个错误答案。 持续-&gt;间歇 持续性错误在每次相同的运行输入时都会发生，间歇性错误仅在某些时候出现，即使是相同的输入和环境 显性错误和持续性错误是最好的，开发者不会对这种程序抱任何幻想，没有人愚蠢到使用这种程序。优秀的程序员编写程序时，会尽量使程序时显性和持续性的，这种编程方式称为防御性编程 以隐性方式出错的程序特别危险，因为他们表面没有任何问题。人们使用它并对他产生依赖。逐渐的我们的人类社会将对软件产生依赖，这些软件来执行超过人类能力的计算，我们甚至不能判断这些软件的计算是否正确。因此我们根本意识不到这个情况。这样的程序可能已经造成了严重危害。 断言Python 语言为程序员提供了一种确保程序运行状态符合预期的简单方法。 123def cal(num): assert num&gt;=0 return num**0.5","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python调试","slug":"Python调试","date":"2018-11-10T08:02:05.000Z","updated":"2018-11-10T08:29:13.077Z","comments":true,"path":"2018/11/10/Python调试/","link":"","permalink":"http://yoursite.com/2018/11/10/Python调试/","excerpt":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print()","text":"本教程内容主要来源于《Python编程导论》 6-8章 供2018年小学期 Python数据科学 课程使用 PowerBy 刘相 调试调试是一种需要学习的技能，好消息是学会调试并不难 人们至少花费了40年建立被称为‘调试器’的工具，所有流行的Python IDE中都带有调试器工具，这些调试工具帮助人们找到程序中的错误,但事实上帮助并不大。更重要的是接近问题，经验丰富的程序员可能根本不用调试工具，也许他们认为最重要的调试工具是 print() 调试过程可以看做是一个搜索过程，每次试验尽力缩减搜索空间。一个有效方法是，设计一个实验。该实验大致分为以下几步: 调查测试结果，弄清楚什么样的数据通过测试，什么样的数据未通过测试 建立一个符合现有数据的假设，假设可以很具体（403行x\\&lt;y改成x=y即可）也可以很宽泛（50-100行的循环出了问题） 设计一个推翻上述假设的实验，你应该能够明确解释出实验每种可能的结果 将你的实验记录下来 Tips for 调试 排除常见错误（这个需要经验） coding everyday 不要问自己为什么没有像你想的那样做，而是考虑程序为什么像现在这样做 错误可能不在你认为会出错的地方 试着向他人解释你的问题 不要盲目相信书上的东西（不要相信文档）大家应该首先学会读文档：） 暂停调试，先写文档 出去散散步，回头接着做 调试案例123456789101112131415161718192021222324252627282930# 调试案例# 下面程序有若干处bugdef isPal(x): \"\"\" 假设x是列表 如果列表是回文，则返回True，否则返回False \"\"\" temp = x temp.reverse() if temp == x: return True else: return Falsedef silly(n): \"\"\" 假设n是正整数 接收用户的n个输入 如果所有的输入组成一个回文列表，则返回‘Yes’ 否则返回‘No’ \"\"\" for i in range(n): result = [] elem = input('Enter element: ') result.append(elem) if(isPal(result)): return True else: return False Python的可变数据类型与不可变数据类型python中的不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化. 可变数据类型(mutable) Dictionary（字典） List（列表） 不可变数据类型(unmutable) Number（数字） String（字符串） Tuple（元组） Bool(布尔值) 1234567891011121314151617181920212223242526272829303132# 不可变数据类型a = 15b = 15print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")b = 20print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"**********友爱的分割线************\")# 可变数据类型a = [1,2,3]b = ac = [1,2,3]print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))print(\"**********友爱的分割线************\")b[0] = 4c[0] = 5print(\"a的值是\"+ str(a))print(\"b的值是\"+ str(b))print(\"c的值是\"+ str(c))print(\"a的地址是\"+ str(id(a)))print(\"b的地址是\"+ str(id(b)))print(\"c的地址是\"+ str(id(c)))","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"面经问题总结","slug":"面经问题总结","date":"2018-11-09T14:07:10.000Z","updated":"2018-12-07T13:10:22.433Z","comments":true,"path":"2018/11/09/面经问题总结/","link":"","permalink":"http://yoursite.com/2018/11/09/面经问题总结/","excerpt":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法","text":"计算机网络1 http是长连接还是短连接，head里面有什么参数 ；put 和 post 有什么区别 ；http页面缓存机制 ；302code 含义 2 socket 编程 tcp三次握手 四次挥手 三次握手和四次挥手画图 为什么3次握手 2次挥手后客户端在做什么 3 访问一个网站的全过程 4 一个用户登录的全部逻辑 5 UDP、TCP、HTTP拥塞控制算法、慢启动算法 6 GET/POST 区别与联系 7 防火墙和DNS劫持 8 http 介绍 http请求头、响应头都有哪些字段 9 netstat查看端口相关命令 10 TCP为什么是可靠的，如何进行拥塞控制 11 长连接与短连接 12 介绍一下常见的网络协议 13 http状态码有哪些 14 一个网站进入速度较慢，可以从哪些方面优化 15 web常见的安全问题有哪些、如何预防 16 http协议请求首部介绍一下 http正向代理和反向代理什么意思 17 GET\\POST 区别，form表单默认的请求方法是get、post？能用get完成的请求都能用post完成吗 18 输入一个网址后回车发生的全过程 19 TCP和UDP 区别，哪一个快一些？UDP丢包怎么处理，TCP拥塞控制机制，慢启动的缺点 20 TCP四次挥手的过程，为什么要主动关闭方等到2MSL的时间 21 http 头部字段keep-alive了解过吗？什么时候服务器知道可以断开连接呢？ 22 http 状态码有哪些？ 502、504 状态码是是么？ 23 TCP和UDP 区别、TCP流量控制和拥塞控制、慢启动 24 访问taobao.com的全过程，如何获取每一阶段的耗时 25 ARP协议 ping命令 操作系统1 虚拟内存的作用是什么？分页有什么好处？分段呢 2 同步和异步的区别 3 进程和线程的区别，谁调度的进程 4 死锁的条件，如何检测死锁 5 死锁的必要条件，银行家算法 6 内核态线程和用户态线程的区别 7 非阻塞IO 8 程调度算法有哪些 9 通俗的语言，面对一个非程序员，解释进程与线程的区别 10 多线程中如何保证线程安全，如何创建守护进程 11 死锁是什么，为什么会产生死锁，怎么解决死锁问题，预防死锁、避免死锁 12 进程的同步进制有哪些？ 进程的通信机制有哪些？ 13 进程的状态转换图及转换事件 数据库1 数据库建立索引的原则有哪些 2 B+树与数据库索引 3 4 聚簇索引和非聚簇索引，一个连环索引对 a 升序排列，对 b 降序排雷，这个时候可以使用索引吗？ 5 数据库加行锁怎么加？ DML语句？ 6 group by, having, order by limit 执行顺序 7 left join 和 inner join 的区别 8 mysql 的非运算如何去掉 not in 和 ！= 这样的过滤条件 9 聚簇索引和非聚簇索引，能不能对 like 出的东西加索引，能不能函数加索引 10 数据库事务的隔离级别，如何对数据库加锁，内连接和外连接 11 mysql 的索引 12 数据库如果有一张表特别大怎么办？（索引优化、加缓存、读写分离、业务拆分） 13 哪些字段可以建索引 14 mysql 储存引擎 15 数据库死锁的概念 16 数据库引擎有哪些，有什么区别，索引分别是怎么实现的？ 17 介绍下数据库的索引 18 乐观锁和悲观锁 19 数据库索引，不同引擎的内部实现，B+树的具体性质 20 数据库索引，底层实现、mysql 两种引擎的区别，数据库查询特别慢怎么优化 21 主要使用的数据类型、数据库引擎了解吗，有什么区别 22 数据库事务、事务的隔离级别 SQL1 (1)写sql，Table T Sid：学号 Cid：课程编号 score：成绩，q1：查询平均成绩大于60分的同学的学号和平均成绩 q2：查询所有课程成绩小于60的同学的学号 2 给一张表，找出成绩在10-15名学生 分布式数据库1 redis 是线程安全的吗？ 为什么是单线程 2 介绍 redis 3 redis 和 mysql 的不同，应用场景 4 用户什么格式的数据格式和用 redis 储存 5 redis mybatis 二级缓存","categories":[],"tags":[{"name":"面试基础","slug":"面试基础","permalink":"http://yoursite.com/tags/面试基础/"}]},{"title":"博客的重新开始","slug":"博客的重新开始","date":"2018-11-09T13:39:42.000Z","updated":"2018-12-23T07:29:11.995Z","comments":true,"path":"2018/11/09/博客的重新开始/","link":"","permalink":"http://yoursite.com/2018/11/09/博客的重新开始/","excerpt":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。","text":"今天把写简历的时候参考了一下Dyc的简历，看到大家还是都有自己的博客的。想想自己也总结过东西，但是由于懒一直没有写博客的习惯。考虑了一下下定决心重新养成写博客的习惯，未来的几个月可能会总结很多东西，正好适合我去写一些东西。 目前离最早的实习面试还有四个月左右，我也已经投出第一篇论文，这一段时间要专注的去复习计算机基础知识了。趁着这一段时间去丰富自己的理论知识。感觉目前工程经历和科研经历都不少了，一路走过来奖项也拿了不少了，所欠缺的主要是对于理论知识的理解，另外对于一些较为需求的方向例如爬虫、redis做一个demo项目。加油！","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}