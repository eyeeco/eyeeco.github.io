<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>操作系统之进程 | MapleStory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="操作系统">
  
  
  
  
  <meta name="description" content="[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。  进程具有动态性（有着创建、活动">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统之进程">
<meta property="og:url" content="http://yoursite.com/2018/12/07/操作系统之进程/index.html">
<meta property="og:site_name" content="MapleStory">
<meta property="og:description" content="[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。  进程具有动态性（有着创建、活动">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/pics/ProcessState.png">
<meta property="og:image" content="http://yoursite.com/2018/12/07/操作系统之进程/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png">
<meta property="og:updated_time" content="2018-12-07T13:12:24.492Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统之进程">
<meta name="twitter:description" content="[TOC] Introduction本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。 进程进程的概念与特征 进程是程序的一次执行 进程是一个程序及数据在处理机上顺序执行时所发生的活动 进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。  进程具有动态性（有着创建、活动">
<meta name="twitter:image" content="https://github.com/CyC2018/CS-Notes/raw/master/pics/ProcessState.png">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="MapleStory" rel="home"> MapleStory </a>
            
          </h1>
          
          
            <div class="site-description">CS:Dalian University of technology</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-操作系统之进程" style="width: 66%; float:left;" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      操作系统之进程
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/07/操作系统之进程/" class="article-date">
	  <time datetime="2018-12-07T13:11:54.000Z" itemprop="datePublished">十二月 7, 2018</time>
	</a>

       
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本节总结了操作系统的相关概念，操作系统的知识点基本上是围绕着进程展开。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念与特征"><a href="#进程的概念与特征" class="headerlink" title="进程的概念与特征"></a>进程的概念与特征</h3><ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及数据在处理机上顺序执行时所发生的活动</li>
<li>进程是系统进行资源分配和调度的一个独立单位。进程的独立运行由进程控制块（PCB）控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。</li>
</ul>
<p>进程具有动态性（有着创建、活动、暂停、终止等过程，具有生命周期）、并发性（多个进程在一段时间内同时运行）、独立性（进程是一个独立运行、获得资源和接收调度的基本单位）、异步性（进程按照独自的、不可预知的速度前进）、结构性（每个进程都有一个PCB对其描述）</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul>
<li><p>运行状态：进程在处理机上运行</p>
</li>
<li><p>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机以外的一切所需资源，只需得到处理机即可执行</p>
</li>
<li><p>阻塞状态（等待/封锁状态）：进程正在等待某一事件而暂停运行。特点是即使处理机空闲也不能运行</p>
</li>
<li><p>创建状态：进程正在创建尚未转到就绪状态。创建进程通常需要经过几个步骤：申请空白PCB、向PCB写入控制和管理进程的信息，然后为该进程分配运行时所必须的资源，最后将其转入就绪状态</p>
</li>
<li><p>结束状态：进程从系统中消失，这可能是因为正常结束或其他原因中断退出。当进程结束运行时，系统首先置该进程为结束状态，进一步处理资源释放和回收等工作。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/ProcessState.png" alt="img"></p>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>  进程控制是指对系统中的进程实施有效管理。一般把控制进程的程序段称为原语，原语的特点是执行期间不允许中断，它是不可分割的单位。</p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><h5 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h5><pre><code>1. 用户登录：分时系统中，每一个用户登录都可以被看做是一个新的进程。系统为该终端建立一个进程并插入就绪队列
2. 作业调度：批处理系统中，当系统按照一定算法调度到某作业时，便将该作业调入内存并为其分配资源，创建进程，插入就绪队列
3. 提供服务：运行中的用户提出某种请求后，系统为其创建一个进程来提供用户需要服务
4. 应用请求；前三种是系统创建进程，而用户基于自己的需求可以创建新进程，以便用户并发的完成特定任务。
</code></pre><h5 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h5><p>  进程创建原语<code>create</code></p>
<pre><code>1. 为进程申请一个唯一的进程识别号与一个空白的PCB
2. 为进程分配资源，为新进程的程序和数据、用户栈分配内存空间
3. 初始化PCB，主要包括初始化标志信息，状态信息及处理机控制信息
4. 如果就绪队列能够接纳新进程，插入就绪队列等待被调度运行
</code></pre><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><h5 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h5><pre><code>1. 正常结束
2. 异常结束：出现某种错误或故障导致程序无法进行，如：越界错误、非法指令、运行超时、等待超时、IO故障
3. 外界干预：进程应外界请求而终止
</code></pre><h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><p>  进程终止原语<code>destroy</code></p>
<pre><code>1. 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，并读取进程状态
2. 若进程处于执行状态，立即终止该进程，并置调度标志为真
3. 若进程还有子孙进程，将其所有子孙进程终止，以防其不可控
4. 将终止进程的所有资源释放给系统或父进程
5. 将被终止进程移出所在队列
</code></pre><h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><h5 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h5><p>  阻塞原语<code>block</code></p>
<p>  正在执行的进程，由于期待某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达，系统自动执行阻塞原语(<code>block</code>)，是自己由运动态转为阻塞态，可见阻塞是一种主动现象</p>
<p>  阻塞过程</p>
<pre><code>1. 找到要阻塞的标识号对应的PCB
2. 若进程为运行态，则保护现场，将其运行状态转为阻塞，停止运行
3. 将PCB插入相应的时间等待队列中去
</code></pre><h5 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h5><p>  唤醒原语<code>wakeup</code></p>
<p>  当被阻塞的进程所期待的出现时，如它启动的I/O操作所期待的数据已到达，则有关进程调用唤醒原语（wakeup）将该进程唤醒</p>
<p>  唤醒过程</p>
<pre><code>1. 在事件的等待队列中找到进程的PCB
2. 将其从等待序列中移除，并置为就绪状态
3. PCB插入就绪队列，等待进程调度
</code></pre><h4 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h4><h5 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h5><p>挂起原语：suspend()</p>
<p>当出现了进程挂起事件时，比如用户请求挂起自己的进程，或父进程挂起子进程。</p>
<h5 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h5><p>激活原语：active()</p>
<p>当激活的事件发生时，例如父进程或用户进程请求激活子进程，若进程驻留在外存而内存有足够的空间时，将外存的进程换入内存</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程间通信主要包括三种：共享储存、消息传递、管道通信</p>
<h4 id="共享储存"><a href="#共享储存" class="headerlink" title="共享储存"></a>共享储存</h4><p>在通信的进程之间存在一块可以直接访问的共享空间（内存），这块内存由一个进程创建但是多个进程都可以访问。共享内存是最快的IPC方式，它是专门针对其他通信方式的低效而设计的。与其他通信机制配合（如信号量）来实现进程的同步和通信</p>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>消息以格式化的形式为单位，通过一个缓冲队列发送至另一个进程。该缓冲队列可能由操作系统提供。</p>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p>管道是进程通信的一种特殊方式，指连接一个读进程和一个写进程实现他们通信的共享文件。为了协调双方通信，管道机制必须提供以下协调能力：互斥、同步、确定对方存在。</p>
<p><code>linux</code>中管道是一种频繁使用的机制，本质上管道是一种文件，克服通信上的两个问题：</p>
<ol>
<li>当写进程较快，限制管道大小，<code>linux</code>中该管道大小为4KB，这样缓存大小不会无限制增长。当管道满时，管道对<code>write</code>的调用被阻塞</li>
<li>当读进程较快，管道空后，<code>read</code>操作被阻塞</li>
</ol>
<p>管道是半双工的，同一时刻只能单向传输。管道可以作为一共享储存的一个优化，利用缓冲区实现了读写的同步。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的概念与特征"><a href="#线程的概念与特征" class="headerlink" title="线程的概念与特征"></a>线程的概念与特征</h4><p>引入线程的目的是为了更好的使多道程序并发执行，以提高资源利用率与吞吐量，减小程序并发执行付出的时空开销，提高操作系统的并发性能。</p>
<p>线程是“轻量级进程”，是一个基本的CPU执行单元。由线程ID、程序计数器、寄存器和堆栈组成。线程是进程中的一个实体，是被系统调度和分派的独立单位。线程不拥有系统资源，线程只有就绪、阻塞、运行三种状态</p>
<p>引入线程后，进程只作为除CPU外系统资源的分配单元，线程则作为CPU的分配单元。这样同一进程内线程的切换开销很小。</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><p>多线程的操作系统中，线程作为独立运行的基本单位，进程的执行实际上是进程的某个线程在执行</p>
<ul>
<li>线程是一个轻型实体，不拥有系统资源，每个线程有唯一的标识符和线程控制块。</li>
<li>不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统建成不同的线程</li>
<li>同一进程各个线程共享进程拥有的资源</li>
<li>线程是处理机调度的独立单位，多个线程可以并发执行。在单CPU计算机中线程交替的占用CPU，多CPU中线程可以同时的占有不同的CPU</li>
</ul>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>线程分为两类：<strong>用户级线程</strong> 和 <strong>内核级线程</strong></p>
<p>用户级线程中，线程的管理工作由应用程序完成，内核意识不到线程的存在。</p>
<p>内核级线程中，线程的管理工作由内核完成，引用程序没有进行线程管理的代码，只有一个内核级线程的编程接口，线程的调度也是在内核线程的基础上完成的。</p>
<p>还有组合式的方式</p>
<h3 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h3><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>引入线程的操作系统中，线程是调度和分派的基本单位。在同一个进程的中，线程的切换不会引起进程的切换。</p>
<h4 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h4><p>进程是拥有除CPU外其他资源的基本单位，程序运行所需要的必要资源（程序、PCB、堆栈）都由进程所有。一般而言线程不占有系统资源（除了一些必不可少的资源），其访问隶属于进程的资源</p>
<h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><p>进程之间可以并行运行，同一进程的线程间也可以并发运行</p>
<h4 id="创建和开销"><a href="#创建和开销" class="headerlink" title="创建和开销"></a>创建和开销</h4><p>进程的创建和撤销，系统都要为之创建、回收PCB，分配和回收资源。操作系统付出的代价比较大。而线程的创建和撤销比较简单。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h4><h5 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h5><p>高级调度，主要任务是按一定原则从外存中将处于后备状态的作业挑选1个或几个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度）</p>
<h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><p>进程的挂起与就绪</p>
<h5 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h5><p>低级调度，某种方法和策略从就绪队列中选取一个进程，为其分配处理机。进程调度是最基本的调度，频率很高，一般几十毫秒一次</p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先来先服务（FCFS）算法"><a href="#先来先服务（FCFS）算法" class="headerlink" title="先来先服务（FCFS）算法"></a>先来先服务（FCFS）算法</h5><p>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</p>
<p>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待。</p>
<p>特点：算法简单，效率低，对长作业有利，有利于CPU繁忙性作业</p>
<h5 id="短作业优先（SJF）算法"><a href="#短作业优先（SJF）算法" class="headerlink" title="短作业优先（SJF）算法"></a>短作业优先（SJF）算法</h5><p>从后背队列中选择一个或若干个估计运行时间最短的作业调入内存运行</p>
<p>特点：对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态。</p>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p>优先级调度算法每次从后背队列中选取优先级最高的一个或几个作业</p>
<p>特点：优先级调度可以剥夺式占有，也可以非剥夺式占有</p>
<h5 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h5><p>高响应比有限主要用于作业调度，该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比。</p>
<p>响应比的计算为（等待时间+要求服务时间）/ 要求服务时间</p>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>时间片轮转算法适用于分时系统，系统将所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms。</p>
<p>特点：受系统响应时间影响、队列进程数目、进程长短影响较大</p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</p>
<p>1） 设置多个就绪队列，为各个队列赋予优先级，1、2、3等等</p>
<p>2） 赋予各个队列中时间片大小不同，优先级高时间片越小</p>
<p>3） 一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行</p>
<p>4） 仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推。</p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源。</p>
<p>// entry</p>
<p>// critical section</p>
<p>// exit section</p>
<h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><p>同步：进程之间具有直接制约关系，进程之间需要按照一定的次序进行</p>
<p>互斥：进程之间的间接制约关系，不能同时访问临界区</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一个整形变量，可以被定义为两个标准的原语<code>wait(S)</code> <code>signal(S)</code> 即P、V操作</p>
<ul>
<li>P操作 如果信号量大于0，执行 -1操作，如果等于0，执行等待信号量大于0</li>
<li>V操作 对信号量完成加1操作，唤醒睡眠的进程 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore mutex = <span class="number">1</span> </span><br><span class="line"><span class="keyword">void</span> P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者-消费者问题"></a>使用信号量实现生产者-消费者问题</h4><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品</p>
<p>由于缓冲区输入临界资源，需要一个互斥量<code>mutex</code>来完成缓冲区的互斥访问</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semahpore</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>使用信号量机制生产消费问题客户端代码需要很多控制，管程作用是把控制的代码独立出来。</p>
<p>管程有一个重要作用：一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</p>
<p>管程的生产者消费者实现</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">	condition full, empty;</span><br><span class="line">	integer cout :=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">(item:integer)</span>;</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full)</span><br><span class="line">		insert_item(item);</span><br><span class="line">		count := count + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">remote</span><span class="params">(item:integer)</span>;</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">		item = remove_item(item);</span><br><span class="line">		count := conut-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count = N-<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">		return item;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span> </span></span><br><span class="line"><span class="function">	<span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">	<span class="title">begin</span></span></span><br><span class="line"><span class="function">		<span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">		ProducerConsumer.insert(item)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">	<span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">	<span class="title">begin</span></span></span><br><span class="line"><span class="function">		<span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		<span class="title">consume</span><span class="params">(item)</span>;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</p>
<p>用一个count表示读进程数量，分别用<code>read_mutex</code> 和<code>write_mutex</code> 作为读锁和写锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore count = <span class="number">0</span>;</span><br><span class="line">semaphore read_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore write_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">1</span>) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;write);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根</p>
<p>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore chop[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(chop[i]&amp;&amp;chop[(i+1)%5])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">      		P(chop[i]);</span></span><br><span class="line"><span class="comment">        	P(chop[(i+1)%5]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            V(&amp;mutex);</span></span><br><span class="line"><span class="comment">         	break;   </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的定义：多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</p>
<h4 id="死锁四个必要条件："><a href="#死锁四个必要条件：" class="headerlink" title="死锁四个必要条件："></a>死锁四个必要条件：</h4><ul>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。</li>
<li>不剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放</li>
<li>请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。</li>
<li>循环等待条件：存在某一进程的循环等待链，链中每个进程已获得资源下个进程的请求。</li>
</ul>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><p>死锁的处理便是破坏四个必要条件，使得死锁无法发生</p>
<h5 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h5><p>把头埋在沙子里，假装问题没有发生</p>
<p>由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能。</p>
<p>大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略</p>
<h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><ol>
<li><p>破坏互斥条件</p>
<p>对于可共享的资源竞争，不会发生死锁</p>
</li>
<li><p>破坏不剥夺状态</p>
<p>当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要是再重新申请</p>
</li>
<li><p>破坏请求 和 保持条件</p>
<p>预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归期所有。</p>
</li>
<li><p>破坏循环等待</p>
<p>资源顺序分配法，例如为资源编号，每个进程申请分配某个资源以后，再之后只能申请该编号以后的资源</p>
</li>
</ol>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1、P2,,)称为安全序列。如果无法找到安全序列，则系统处于不安全状态。</p>
<p>允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则，进程等待</p>
<p>银行家算法</p>
<p><img src="/2018/12/07/操作系统之进程/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>银行家算法是最著名的死锁避免算法。它的思想是，把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款。</p>
<p>进程申请资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源</p>
<h4 id="死锁检测和接触"><a href="#死锁检测和接触" class="headerlink" title="死锁检测和接触"></a>死锁检测和接触</h4><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><h5 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h5><ul>
<li><p>资源剥夺法</p>
<p>挂起死锁进程，抢占其资源分配给其他进程</p>
</li>
<li><p>撤销进程法</p>
<p>强制撤销一些死锁进程</p>
</li>
<li><p>进程回退法</p>
<p>借助历史信息使一个或多个进程回退到系统不再死锁的地步</p>
</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/07/数据库之SQL/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据库之SQL
        
      </div>
    </a>
  
  
    <a href="/2018/11/11/欢迎来到Eyc的博客!/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">欢迎来到Eyc的博客！</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的概念与特征"><span class="nav-number">2.1.</span> <span class="nav-text">进程的概念与特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的状态"><span class="nav-number">2.2.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制"><span class="nav-number">2.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的创建"><span class="nav-number">2.3.1.</span> <span class="nav-text">进程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起进程创建的事件"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">引起进程创建的事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的创建过程"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">进程的创建过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的终止"><span class="nav-number">2.3.2.</span> <span class="nav-text">进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起进程终止的事件"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">引起进程终止的事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的终止过程"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">进程的终止过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的阻塞与唤醒"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程的阻塞与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的阻塞"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">进程的阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的唤醒"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">进程的唤醒</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的挂起与激活"><span class="nav-number">2.3.4.</span> <span class="nav-text">进程的挂起与激活</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的挂起"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">进程的挂起</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的激活"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">进程的激活</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信"><span class="nav-number">2.4.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享储存"><span class="nav-number">2.4.1.</span> <span class="nav-text">共享储存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息传递"><span class="nav-number">2.4.2.</span> <span class="nav-text">消息传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道通信"><span class="nav-number">2.4.3.</span> <span class="nav-text">管道通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">2.5.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的概念与特征"><span class="nav-number">2.5.1.</span> <span class="nav-text">线程的概念与特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的属性"><span class="nav-number">2.5.2.</span> <span class="nav-text">线程的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的实现"><span class="nav-number">2.5.3.</span> <span class="nav-text">线程的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与线程的比较"><span class="nav-number">2.6.</span> <span class="nav-text">进程与线程的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度"><span class="nav-number">2.6.1.</span> <span class="nav-text">调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥有资源"><span class="nav-number">2.6.2.</span> <span class="nav-text">拥有资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发性"><span class="nav-number">2.6.3.</span> <span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建和开销"><span class="nav-number">2.6.4.</span> <span class="nav-text">创建和开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度"><span class="nav-number">2.7.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度层次"><span class="nav-number">2.7.1.</span> <span class="nav-text">调度层次</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#作业调度"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">作业调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中级调度"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">中级调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程调度-1"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">进程调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度算法"><span class="nav-number">2.7.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#先来先服务（FCFS）算法"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">先来先服务（FCFS）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#短作业优先（SJF）算法"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">短作业优先（SJF）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先级调度算法"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高响应比优先"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">高响应比优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间片轮转调度算法"><span class="nav-number">2.7.2.5.</span> <span class="nav-text">时间片轮转调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">2.7.2.6.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程同步"><span class="nav-number">2.8.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#临界区"><span class="nav-number">2.8.1.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步与互斥"><span class="nav-number">2.8.2.</span> <span class="nav-text">同步与互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">2.8.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用信号量实现生产者-消费者问题"><span class="nav-number">2.8.4.</span> <span class="nav-text">使用信号量实现生产者-消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程"><span class="nav-number">2.8.5.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">2.8.6.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哲学家进餐问题"><span class="nav-number">2.8.7.</span> <span class="nav-text">哲学家进餐问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.9.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁四个必要条件："><span class="nav-number">2.9.1.</span> <span class="nav-text">死锁四个必要条件：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的处理策略"><span class="nav-number">2.9.2.</span> <span class="nav-text">死锁的处理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#鸵鸟策略"><span class="nav-number">2.9.2.1.</span> <span class="nav-text">鸵鸟策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁预防"><span class="nav-number">2.9.2.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁避免"><span class="nav-number">2.9.2.3.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁检测和接触"><span class="nav-number">2.9.3.</span> <span class="nav-text">死锁检测和接触</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁检测"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁解除"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 MapleStory All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
