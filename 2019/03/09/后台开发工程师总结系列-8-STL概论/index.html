<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>[后台开发工程师总结系列] 8.STL概论 | MapleStory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="后台开发">
  
  
  
  
  <meta name="description" content="STL概论 长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。 子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 … 都是为了 复用性的提升 复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。">
<meta name="keywords" content="后台开发">
<meta property="og:type" content="article">
<meta property="og:title" content="[后台开发工程师总结系列] 8.STL概论">
<meta property="og:url" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/index.html">
<meta property="og:site_name" content="MapleStory">
<meta property="og:description" content="STL概论 长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。 子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 … 都是为了 复用性的提升 复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/835234-20160603160429305-1162165982.png">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/1550541990545.png">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/C:/Users/Eyc/Videos/青龙小组课件/1550544541427.png">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/1550559055930.png">
<meta property="og:updated_time" content="2019-03-09T09:16:35.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[后台开发工程师总结系列] 8.STL概论">
<meta name="twitter:description" content="STL概论 长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。 子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 … 都是为了 复用性的提升 复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。">
<meta name="twitter:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-8-STL概论/835234-20160603160429305-1162165982.png">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="MapleStory" rel="home"> MapleStory </a>
            
          </h1>
          
          
            <div class="site-description">CS:Dalian University of technology</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-后台开发工程师总结系列-8-STL概论" style="width: 66%; float:left;" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      [后台开发工程师总结系列] 8.STL概论
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/09/后台开发工程师总结系列-8-STL概论/" class="article-date">
	  <time datetime="2019-03-09T09:08:01.000Z" itemprop="datePublished">三月 9, 2019</time>
	</a>

       
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>STL概论</p>
<p>长久以来软件届一直希望建立一种可复用的东西，以及一种得以造出“可重复运用东西”的方法。</p>
<p>子程序、程序、函数、类别、函数库、类别库、组件、结构模块化设计、模式、面向对象 …</p>
<p>都是为了 <strong>复用性的提升</strong></p>
<p>复用性必须建立在某种标准之上，但是在许多环境下开发最基本的算法和数据结构还迟迟不能有标准。大量程序员从事重复劳动，完成前人完成而自己不拥有的代码。</p>
<a id="more"></a>
<p><strong>例子</strong></p>
<p>现在需要编写一个排序函数，这涉及到一个问题，从流中读入数据事先并不知道数据的长度 ，然而C/C++ 数组只能申请定长数组，超过数组上限就会出现越界。为了弥补该缺陷，就必须采用下列方案的一种：</p>
<ol>
<li>采用大容量的静态数据分配</li>
<li>限定输入的数据个数</li>
<li>采用动态的内存分配</li>
</ol>
<p>显然，前两种方法都有缺陷。只能使用指针及动态内存来妥善解决上述问题，使程序具有较好的灵活性。这需要New()、delete() 或者 malloc() realloc() free() 等函数，这样程序就会相当的不简洁。 </p>
<p>为了建立数据结构算法的标准，降低耦关系，提升独立性、弹性，交互操作性，诞生了STL</p>
<p><img src="/2019/03/09/后台开发工程师总结系列-8-STL概论/835234-20160603160429305-1162165982.png" alt="img"></p>
<h2 id="六大组件简单介绍"><a href="#六大组件简单介绍" class="headerlink" title="六大组件简单介绍"></a>六大组件简单介绍</h2><ol>
<li>空间配置器：内存池实现小块内存分配,对应到设计模式–单例模式（工具类，提供服务，一个程序只需要一个空间配置器即可），享元模式（小块内存统一由内存池进行管理）</li>
<li>迭代器：迭代器模式，模板方法</li>
<li>容器：STL的核心之一，其他组件围绕容器进行工作：迭代器提供访问方式，空间配置器提供容器内存分配，算法对容器中数据进行处理，仿函数伪算法提供具体的策略，类型萃取　　实现对自定义类型内部类型提取。保证算法覆盖性。其中涉及到的设计模式：组合模式（树形结构），门面模式（外部接口提供），适配器模式（stack，queue通过deque适配得到），建造者模式（不同类型树的建立过程）。</li>
<li>类型萃取：基于范型编程的内部类型解析，通过typename获取。可以获取迭代器内部类型value_type,Poter,Reference等。(算法)</li>
<li>仿函数：一种类似于函数指针的可回调机制，用于算法中的决策处理。涉及：策略模式，模板方法。</li>
<li>适配器：STL中的stack，queue通过双端队列deque适配实现，map，set通过RB-Tree适配实现。涉及适配器模式。</li>
</ol>
<h2 id="空间配置器-allocator"><a href="#空间配置器-allocator" class="headerlink" title="空间配置器 allocator"></a>空间配置器 allocator</h2><p>软件开发中，不免于程序需求可能使用很多小块内存，在程序中动态的申请和释放。这个过程不一定能控制好，所以可能出现以下问题：</p>
<ol>
<li>内存碎片问题</li>
<li>因为一直申请小块内存，malloc系统产生调用性能问题</li>
</ol>
<p>内部碎片：因为内存对齐、访问效率（CPU取址次数）而产生，比如申请3字节而得到4字节或8字节</p>
<p>外部碎片：系统中该内存中总量足够，但是不连续而造成的浪费。</p>
<p><img src="/2019/03/09/后台开发工程师总结系列-8-STL概论/1550541990545.png" alt="1550541990545"></p>
<p>下面是STL空间配置器的细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)&#123;</span><br><span class="line">    <span class="keyword">return</span> malloc_alloc::allocate(n); <span class="comment">// 一级空间配置器</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 二级空间配置器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致实现：</p>
<p>一级空间配置器直接封装malloc，free 进行处理，增加了C++中的set_handler机制，增加内存分配时客户端可选处理机制。</p>
<h4 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ___TRACE(<span class="string">"__MallocAllocTemplate to get  n = %u\n"</span>,n);</span><br><span class="line">    <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">    &#123;</span><br><span class="line">        result = OomMalloc(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *__MallocAllocTemplate::OomMalloc(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    ___TRACE(<span class="string">"一级空间配置器,不足进入Oo中n = %u\n"</span>,n);</span><br><span class="line">    <span class="keyword">void</span>(*my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (;;) <span class="comment">// 不断尝试释放、配置、再释放、再配置</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler)</span><br><span class="line">        &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*__malloc_alloc_oom_handler)(); <span class="comment">//调用处理历程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一级配置器以malloc()、free()、realloc() 等C函数执行实际的内存配置和释放，类似于C++ 的new-handler机制，但是他不能直接使用（未使用::operator new来配置内存）。</p>
<p>所谓new-handler 机制是，要求系统在内存配置无法满足时，调用你指定的函数，一旦new无法完成任务，在丢出异常之前，调用客户端的历程，这就被称为new-handler。</p>
<p>请注意，第一级配置器都是在malloc和realloc调用不成功后，改为调用oom_malloc，后两者内有循环，不断调用 “内存不足例程”，但是如果这个例程未被设定，便老实的 __THROW_BAD_ALLOC;</p>
<h4 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h4><p>二级空间配置器避免了太多额外的小区造成的内存碎片。二级配置器的做法是，如果区块足够大（超过128字节）则以内存池管理，此法又被称为层次管理：每次配置一块大内存，并且维护自由链表。下次如果还有相同的内存需求，就从free-list中拨出，如果客户端释放，就回收到free-list中，配置器配置也回收，为了方便起见，二级配置器主动把内存的需求量上调至8的倍数。</p>
<p><img src="/2019/03/09/后台开发工程师总结系列-8-STL概论/C:/Users\Eyc\Videos\青龙小组课件\1550544541427.png" alt="1550544541427"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span>  <span class="keyword">size_t</span> _FreeListIndex(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span> * ret = <span class="number">0</span>;</span><br><span class="line">        ___TRACE(<span class="string">"二级空间配置器申请n = %u\n"</span>,n);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;_MAX_BYTES)</span><br><span class="line">            ret = MallocAlloc::Allocate(n);</span><br><span class="line"></span><br><span class="line">        _Obj* <span class="keyword">volatile</span> * __my_free_list = _freeList + _FreeListIndex(n);</span><br><span class="line"></span><br><span class="line">        _Obj* __result = *__my_free_list;</span><br><span class="line">        <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">            ret = _Refill(RoundUp(n));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *__my_free_list = __result -&gt; _freeListLink;</span><br><span class="line">            ret = __result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>chunk_alloc() 函数以 end_free - start_free 来判断内存池。 如果容量充足，就一次性调20个区块给free-list, 但是如果剩余区块不够20 但是大于1， 就拨出剩余能拨出的区块。最后如果剩余不到1个区块了 ，那就重新从堆中配置内存。新的配置量是一个两倍的需求加一个逐渐增大的附加量。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应这个概念的实物。</p>
<p>《设计模式》中对于迭代器的定义如下：提供一种方法，使之能够依次巡防某个聚合物容器所含的各个元素，而又无需包括该聚合物内部的表述方式。</p>
<p>不论是泛型思维或STL的实际应用，迭代器都扮演着重要角色。STL的中心思想在于，将数据容器和算法分开，彼此独立设计，最后再将他们撮合在一起，而迭代器就扮演了这个黏胶角色。</p>
<p>迭代器是一种行为类似指针的对象，而指针行为中最常见的内容是提领（dereference）和成员访问（member access）因此迭代器最重要的工作就是对opreator* 和 opreator-&gt; 进行重载工作。关于这一点C++有智能指针。</p>
<h2 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h2><table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#array" target="_blank" rel="noopener">array</a></td>
<td>数组</td>
<td>随机读改 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#vector" target="_blank" rel="noopener">vector</a></td>
<td>数组</td>
<td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#list" target="_blank" rel="noopener">list</a></td>
<td>双向链表</td>
<td>插入、删除 O(1) 随机读改 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速增删</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#deque" target="_blank" rel="noopener">deque</a></td>
<td>双端队列</td>
<td>头尾插入、头尾删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#stack" target="_blank" rel="noopener">stack</a></td>
<td>deque / list</td>
<td>顶部插入、顶部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#queue" target="_blank" rel="noopener">queue</a></td>
<td>deque / list</td>
<td>尾部插入、头部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue" target="_blank" rel="noopener">priority_queue</a></td>
<td>vector + max-heap</td>
<td>插入、删除 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td>vector容器+heap处理规则</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#set" target="_blank" rel="noopener">set</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multiset" target="_blank" rel="noopener">multiset</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#map" target="_blank" rel="noopener">map</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multimap" target="_blank" rel="noopener">multimap</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>hash_set</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>hash_multiset</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>hash_map</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>hash_multimap</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
</tr>
</tbody>
</table>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是线性容器，它的元素按照线性排列，和动态数组类似。和数组类似的是，它的元素存在一块连续的内存空间中，这意味着不仅可以通过迭代器访问，还可以使用指针偏移访问元素。和数组不一样的是，vector能够自动增长或缩短储存空间。</p>
<p>vector的优点如下所示：</p>
<ol>
<li>可以使用下标访问个别元素</li>
<li>迭代器可以按照不同的顺序遍历容器</li>
<li>可以在容器的默认增加、删除元素</li>
</ol>
<p>关于<code>STl</code>容器，只要不超过最大值，其可以自动增长到足以容纳用户放进去的数据大小。（这个容量值，可以同过调用<code>maxsize()</code>来获得）</p>
<p>对于vector和string，如果需要更多的空间，类似<code>realloc</code>思想增长，vector支持随机访问，因此提高了效率，内部通过动态数组实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector 查找</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter = find(vec.begin(),vec.end(),<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector 删除</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> <span class="comment">// 删除后指向删除元素的下一个位置</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator frist, iterator last)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">vector&lt;int&gt;::iterator iter = vec.begin();</span><br><span class="line"><span class="keyword">while</span>(iter!=vec.end())&#123;</span><br><span class="line">    <span class="keyword">if</span>(*iter==target)&#123;</span><br><span class="line">        iter = erase(iter);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector 增加</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator loc, <span class="keyword">const</span> TYPE &amp;val)</span></span>; <span class="comment">// 指定位置loc 插入值为val的元素，返回指向这个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(itrator loc, size_type num, <span class="keyword">const</span> TYPE &amp;val)</span></span>; <span class="comment">// 同上，插入num 个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(itrator loc, itrator start, itrator end)</span></span>; <span class="comment">// 插入迭代器区间的元素</span></span><br></pre></td></tr></table></figure>
<h4 id="vector内存管理"><a href="#vector内存管理" class="headerlink" title="vector内存管理"></a>vector内存管理</h4><ol>
<li>使用reverse() 提前设定容量大小</li>
</ol>
<p><code>STL</code>最令人称赞的特性之一就是只要不超过最大值，其可以自动增长。如果需要更多空间就会类似<code>realloc</code>的思想来增长大小。vector容器支持随机访问，因此效率较高。 如果有大量的元素需要push_back，应提前使用reverse函数提前设定，避免多次的扩容操作，介绍一下只有vector与string提供的几个函数</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>size()</td>
<td>获得容器中的元素个数，但不能获得容器为他分配的容器大小</td>
</tr>
<tr>
<td>capacity()</td>
<td>获得容器已经分配的内存容纳多少元素。</td>
</tr>
<tr>
<td>resize()</td>
<td>用来强制把容器改为容纳n个元素。如果n小于当前大小，尾部元素会被销毁；如果n大于当前大小，默认构造元素添加到元素尾；如果大于当前容量，触发重新分配</td>
</tr>
<tr>
<td>reverse()</td>
<td>强制把容量改为不小于n，n不小于当前大小</td>
</tr>
</tbody>
</table>
<ol>
<li>交换技巧来修整内存</li>
</ol>
<p>有一种方法将它的最大容量修正到其当前容量，这种方法被称为“收缩到合适”，只需要一条语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ivec).swap(ivec);</span><br></pre></td></tr></table></figure>
<ol>
<li>swap强行释放内存</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">VlearVector</span>(<span class="title">vector</span>&lt;T&gt;&amp; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; vTemp;</span><br><span class="line">    vTemp.swap(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vector类简单实现"><a href="#vector类简单实现" class="headerlink" title="vector类简单实现"></a>vector类简单实现</h4><p>第二版参考《<code>stl</code>源码》</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator posotion, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(start)</span><br><span class="line">    		data_allocator::deallocate(start,end_of_storage-start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; vlaue)</span></span>&#123;</span><br><span class="line">    	start = allocate_and_fill(n, value);</span><br><span class="line">    	finish = start + n;</span><br><span class="line">    	end_of_storage = finish;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> size_type(end()-begin());&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> size_type(end_of_storage-begin());&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> engin()==end()&#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n)&#123;<span class="keyword">return</span> *(begin()+n);&#125;</span><br><span class="line">	<span class="built_in">vector</span>():start(<span class="number">0</span>),finish(<span class="number">0</span>),end_of_storage(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">vector</span>(size_type n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">long</span> n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123;fill_initlialize(n,T());&#125;</span><br><span class="line">    ~<span class="built_in">vector</span>()&#123;</span><br><span class="line">    	destroy(start,finish);</span><br><span class="line">    	deallocate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> *begin();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(end()<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(finish!=end_of_storage)&#123;</span><br><span class="line">    		construct(finish, x);</span><br><span class="line">    		++finish;</span><br><span class="line">    	&#125;<span class="keyword">else</span></span><br><span class="line">    		insert_aux(end(),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	--finish;</span><br><span class="line">    	destory(finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(position+<span class="number">1</span> != end())</span><br><span class="line">    		copy(position+<span class="number">1</span>,finish,position);</span><br><span class="line">    	--finish;</span><br><span class="line">    	destory(finish);</span><br><span class="line">    	<span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(new_size&lt;size())</span><br><span class="line">    		erase(begin()+new_size(),end());</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		insert(end(),newsize()-size(),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span></span>&#123;resize(new_size,T());&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;erase(begin(),end());&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">		iterator result = data_allocatpr::</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;class T, class Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T, Alloc&gt;::insert_aux(iterator position, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">	<span class="keyword">if</span>(finish != end_of_storage)&#123;</span><br><span class="line">		construct(finish,*（finish<span class="number">-1</span>));</span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy = x;</span><br><span class="line">		copy_backword(position, finish<span class="number">-2</span>,finish<span class="number">-1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">    	<span class="keyword">const</span> size_type len = old_size != <span class="number">0</span>?<span class="number">2</span>*oldsize:<span class="number">1</span>;</span><br><span class="line">    	iterator new_start = data_allocator::allocate(len);</span><br><span class="line">    	iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	new_finish = uninitialized_copy(start,posotion,new_start);</span><br><span class="line">        	construct(new_finish, x);</span><br><span class="line">        	++new_finish;</span><br><span class="line">        	new_finish = uninitialized_copy(positon,finish,new_finish);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        	destroy(new_start,new_finish);</span><br><span class="line">            data_allocator::deallocate(new_start,len);</span><br><span class="line">            thow;</span><br><span class="line">        &#125;</span><br><span class="line">        destroy(begin(),end());</span><br><span class="line">        deallocate();</span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start+len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map、set"><a href="#map、set" class="headerlink" title="map、set"></a>map、set</h3><ol>
<li>map的本质</li>
</ol>
<p>map本质是一类关联式容器，属于模板类关联的本质在于元素的值与某个特点的键相关联，而并非通过元素在数组的位置获取。它的特点是增加和删除节点对迭代器的影响很小，除了要操作的节点，对其他节点都没什么影响。对迭代器来数不能修改键值，只能修改实值。map内部自建一颗红黑树（非严格意义的平衡二叉树），该树内部数据有序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">    <span class="built_in">map</span>&lt;T_key, T_value&gt; mymap;</span><br><span class="line"></span><br><span class="line">插入元素：</span><br><span class="line">    mymap.insert(pair&lt;T_key, T_value&gt;(key, value));  <span class="comment">//同key不插入</span></span><br><span class="line">    mymap.insert(<span class="built_in">map</span>&lt;T_key, T_value&gt;::value_type(key, value)); <span class="comment">//同key不插入</span></span><br><span class="line">    mymap[key] = value; <span class="comment">//同key覆盖</span></span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    mymap.erase(key); <span class="comment">//按值删</span></span><br><span class="line">    mymap.erase(iterator); <span class="comment">//按迭代器删</span></span><br><span class="line"></span><br><span class="line">修改元素：</span><br><span class="line">    mymap[key] = new_value;</span><br><span class="line"></span><br><span class="line">遍历容器：</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mymap.begin(); it != mymap.end(); ++it)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p>
<p>红黑树的特性</p>
<ol>
<li>它是一颗二叉排序树（继承二叉排序树的特点）：<ul>
<li>若左子树不空，则左子树的上所有节点的值均小于等于它根节点的值</li>
<li>若右子树不空， 则右子树上所有节点的值均大于等于它根节点的值</li>
<li>左右子树分别也是二叉排序树。</li>
</ul>
</li>
<li>红黑树的要求<ul>
<li>树中所有节点非红即黑</li>
<li>根节点必为黑节点</li>
<li>红节点的子节点必须为黑</li>
<li>从根到任何发路径上的的黑节点数相同</li>
</ul>
</li>
<li>查找时间一定可以控制在O(log N)之内</li>
<li>红黑树定义如下</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED = <span class="number">0</span>,</span><br><span class="line">    BLACK = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span>*<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Color color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p>
<p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p>
<p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p>
<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a><code>hashtable</code></h3><p><code>hashtable</code>被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。</p>
<p>如何避免array过大？是用某种映射函数，使得元素映射至“大小可以接受的索引”，这个函数被称为散列函数。使用散列函数必然会带来一个问题：可能有不同的元素被映射到相同的位置，这便是所谓的碰撞问题。</p>
<p>碰撞问题一般有两种方案：拉链法、线性探测法</p>
<h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>提出一个名词：负载系数，元素个数除以表格大小。负载系数永远在0~1之间，</p>
<p>当 散列函数 计算某个位置，而该位置不可用该怎么办？ 最简单的方法就是循序接着往下找，只要表格足够大总会找到一个空间。而删除必须采取惰性删除（标记删除序号，实际删除待表格整理时再进行）</p>
<p>两个假设 1.表格足够大，2 每个元素独立 但实际情况往往不乐观，往往需要不断解决碰撞问题</p>
<h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> prime[<span class="number">28</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">57</span>,        <span class="number">97</span>,         <span class="number">193</span>,        <span class="number">389</span>,        <span class="number">769</span>,</span><br><span class="line">    <span class="number">1543</span>,      <span class="number">3079</span>,       <span class="number">6151</span>,       <span class="number">12289</span>,      <span class="number">24593</span>,</span><br><span class="line">    <span class="number">49157</span>,     <span class="number">98317</span>,      <span class="number">196613</span>,     <span class="number">393241</span>,     <span class="number">786433</span>,</span><br><span class="line">    <span class="number">1572869</span>,   <span class="number">3145739</span>,    <span class="number">6291469</span>,    <span class="number">12582917</span>,   <span class="number">25165843</span>,</span><br><span class="line">    <span class="number">50331653</span>,  <span class="number">100663319</span>,  <span class="number">201326611</span>,  <span class="number">402653189</span>,  <span class="number">805306457</span>,</span><br><span class="line">    <span class="number">1610612741</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMapUtil</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_NextPrimeNumber</span><span class="params">(<span class="keyword">int</span> current)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Find the next prime number by searching in the prime number list</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; <span class="number">28</span> ; i++ )</span><br><span class="line">            <span class="keyword">if</span>(current &lt; prime[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> prime[i];     <span class="comment">//return the next larger prime.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二次探测主要用来解决 主集团问题， 该方法描述很简单，碰撞时尝试 H+1*1，H+2*2, H+ 3*3来代替H+1, H+2,H+3 等。幸运的是，假设表格大小为质数，永远保持0.5以下的负载系数，每个新元素的插入查找不大于2</p>
<p>另外，二次探测有个简便的计算技巧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hi = h0 +  i\*i (MOD M)</span><br><span class="line"></span><br><span class="line">hi-1 = h0 + (i-1) *(i-1) (MOD M)</span><br><span class="line"></span><br><span class="line">整理得，hi = hi-1 + 2*i-1 (MOD M)</span><br></pre></td></tr></table></figure>
<p>这样每一次迭代并不需要太大的计算资源。</p>
<h4 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h4><p>拉链法，在《STL源码》中被称为开链，及对于冲突的元素维护一个链表</p>
<p><img src="/2019/03/09/后台开发工程师总结系列-8-STL概论/1550559055930.png" alt="1550559055930">从上图我们可以发现哈希表是由<strong>数组+链表</strong>组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p>
<p>首先HashMap里面实现一个静态内部类Entry，其重要的属性有 <em>key , value, next</em>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p>
<h4 id="hash算法的存取"><a href="#hash算法的存取" class="headerlink" title="hash算法的存取"></a>hash算法的存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode(); </span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line"><span class="keyword">return</span> Entry[index];</span><br></pre></td></tr></table></figure>
<h2 id="面试常考题"><a href="#面试常考题" class="headerlink" title="面试常考题"></a>面试常考题</h2><p><strong>1. vector 的结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator posotion, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; vlaue)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> size_type(end()-begin());&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> size_type(end_of_storage-begin());&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> engin()==end()&#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n)&#123;<span class="keyword">return</span> *(begin()+n);&#125;</span><br><span class="line">	<span class="built_in">vector</span>():start(<span class="number">0</span>),finish(<span class="number">0</span>),end_of_storage(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">vector</span>(size_type n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">long</span> n,<span class="keyword">const</span> T&amp; value)&#123;fill_initialize(n,value);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123;fill_initlialize(n,T());&#125;</span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> *begin();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(end()<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. vector 和 list 的区别和应用场景</strong></p>
<p>vector 是地址空间连续，支持随机存取的数组。优点是存取方便，缺点是非末尾的增、删复杂度较高。</p>
<p>list 是不支持随机的存取的链表，优点是增、删复杂度O(1)，缺点是查找复杂度O（n）</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<p><strong>3. vector怎么增加内存</strong></p>
<p>通过源码对比回答， 当vector因为增加元素而超出容量，即（finish==capacity时）,进行以下操作</p>
<ol>
<li>保存原指针（start, finish, capacity）</li>
<li>计算新数组的容量大小（为原大小的两倍），并申请这样大小的空间，记录新的数组指针（new_start, new finish , new_capacity）</li>
<li>在新的数组中复制原数组, 然后完成当下的增加元素操作。</li>
<li>释放原数组空间</li>
<li>用新数组指针替换原指针。</li>
</ol>
<p><strong>4. 遍历vector的几种写法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. [] 数组遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.size(); i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin(); it!=vec.end(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. C++11 的新特性冒号遍历（不支持修改）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:vec)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 对STL内存分配的理解，为什要有空间配置器</strong></p>
<p>软件开发中，不免于程序需求可能使用很多小块内存，在程序中动态的申请和释放。这个过程不一定能控制好，所以可能出现以下问题：内存碎片问题、因为一直申请小块内存，malloc系统产生调用性能问题。 为了解决以上问题，而且为了方便管理malloc申请空间不足的情况，STL模拟了new_handler 提供用户错误处理接口。 </p>
<p><strong>6. <code>hashtable</code> java实现 </strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package prepare;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* @author : Menghui Chen </span></span><br><span class="line"><span class="comment">* @version ：2018年3月20日 下午7:14:04 </span></span><br><span class="line"><span class="comment">* @Description:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;T, V&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;T, V&gt; &#123;</span></span><br><span class="line">        Node&lt;T, V&gt; next;</span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tab;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        tab = <span class="keyword">new</span> Node[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(T key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(key);</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (tab[index] == null) &#123;</span><br><span class="line">            tab[index] = node;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node head = tab[index];</span><br><span class="line">            Node pre = searchList(head, key);</span><br><span class="line">            <span class="keyword">if</span> (pre.next == null) &#123;</span><br><span class="line">                pre.next = node;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                V old =  (V) pre.next.value;<span class="comment">//here</span></span><br><span class="line">                pre.next.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchList</span><span class="params">(Node node, T k)</span> </span>&#123;</span><br><span class="line">        Node pre = null;</span><br><span class="line">        <span class="keyword">while</span> (node != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash((T)node.key) == hash(k) &amp;&amp; (node.key == k || node.key.equals(k))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(key);</span><br><span class="line">        <span class="keyword">if</span> (tab[index] == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node head = tab[index];</span><br><span class="line">            head = searchList(head, key);</span><br><span class="line">            <span class="keyword">if</span> (head == null &amp;&amp; head.next == null) &#123;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)head.next.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &gt;&gt; <span class="number">16</span>) ^ key.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash(key) % tab.length; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7. map 与 unordered_map 的区别和应用场景</strong></p>
<p>map本质是一类关联式容器，属于模板类关联的本质在于元素的值与某个特点的键相关联，而并非通过元素在数组的位置获取。它是一种通过内建红黑树实现了O(logN) 时间复杂度内实现 增删改查的数据结构，且其内部元素有序。</p>
<p><code>unordered_map</code>被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。利用哈希映射表实现了元素的增、删、查、改操作</p>
<p>二者的主要区别在于map有序, 而unordered_map无序， 他们的应用场景也主要取决于是否要求元素有序。</p>
<ol>
<li><strong>STL中有几种map</strong></li>
</ol>
<p>unordered_map  哈希表  不可重复 无序</p>
<p>map 红黑树 不可重复 有序</p>
<p>multi-map 红黑树 有序</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/09/后台开发工程师总结系列-9-Python，Nginx-and-Django/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [后台开发工程师总结系列] 9.Python，Nginx and Django
        
      </div>
    </a>
  
  
    <a href="/2019/03/09/后台开发工程师总结系列-7-Redis简介/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[后台开发工程师总结系列] 7.Redis简介</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#六大组件简单介绍"><span class="nav-number">1.</span> <span class="nav-text">六大组件简单介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间配置器-allocator"><span class="nav-number">2.</span> <span class="nav-text">空间配置器 allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一级空间配置器"><span class="nav-number">2.0.1.</span> <span class="nav-text">一级空间配置器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二级空间配置器"><span class="nav-number">2.0.2.</span> <span class="nav-text">二级空间配置器</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">3.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL-容器"><span class="nav-number">4.</span> <span class="nav-text">STL 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">4.1.</span> <span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector内存管理"><span class="nav-number">4.1.1.</span> <span class="nav-text">vector内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector类简单实现"><span class="nav-number">4.1.2.</span> <span class="nav-text">vector类简单实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map、set"><span class="nav-number">4.2.</span> <span class="nav-text">map、set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable"><span class="nav-number">4.3.</span> <span class="nav-text">hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性探测"><span class="nav-number">4.3.1.</span> <span class="nav-text">线性探测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二次探测"><span class="nav-number">4.3.2.</span> <span class="nav-text">二次探测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开链"><span class="nav-number">4.3.3.</span> <span class="nav-text">开链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash算法的存取"><span class="nav-number">4.3.4.</span> <span class="nav-text">hash算法的存取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试常考题"><span class="nav-number">5.</span> <span class="nav-text">面试常考题</span></a></li>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 MapleStory All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
