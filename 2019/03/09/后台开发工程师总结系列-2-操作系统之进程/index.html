<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>[后台开发工程师总结系列] 2.操作系统之进程 | MapleStory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="后台开发">
  
  
  
  
  <meta name="description" content="进程进程的概念和特征进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。  进程是程序">
<meta name="keywords" content="后台开发">
<meta property="og:type" content="article">
<meta property="og:title" content="[后台开发工程师总结系列] 2.操作系统之进程">
<meta property="og:url" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/index.html">
<meta property="og:site_name" content="MapleStory">
<meta property="og:description" content="进程进程的概念和特征进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。  进程是程序">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/1550453785672.png">
<meta property="og:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png">
<meta property="og:updated_time" content="2019-03-09T08:40:01.340Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[后台开发工程师总结系列] 2.操作系统之进程">
<meta name="twitter:description" content="进程进程的概念和特征进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。  进程是程序">
<meta name="twitter:image" content="http://yoursite.com/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/1550453785672.png">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="MapleStory" rel="home"> MapleStory </a>
            
          </h1>
          
          
            <div class="site-description">CS:Dalian University of technology</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-后台开发工程师总结系列-2-操作系统之进程" style="width: 66%; float:left;" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      [后台开发工程师总结系列] 2.操作系统之进程
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/" class="article-date">
	  <time datetime="2019-03-09T08:35:08.000Z" itemprop="datePublished">三月 9, 2019</time>
	</a>

       
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><p>进程结构一般由三部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享一个代码段。而数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数参数、函数内部定义的局部变量。对斩断还包含了进程控制块（PCB）。PCB处于进程核心堆栈底部，不需要额外分配空间。PCB是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。</p>
<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及数据在处理机上执行时所发生的活动</li>
<li>进程是系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。程序段、相关数据、PCB三部分构成了进程映像。进程映像是静态的进程。</li>
<li>进程具有动态性（创建、活动、暂停、终止过程、生命周期），并发性（多个进程在一段时间同时运行），独立性（进程是一个独立运行获得和调度资源的独立单位）、异步性（进程按照独自不可预知的速度前进）、结构性（每个进程都有一个PCB描述）</li>
</ul>
<blockquote>
<p><code>linux</code> 系统的进程启动过程</p>
<p>整个linux是一个树形结构。树是系统自动构造的，即内核下的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1 号进程负责执行内核的部分初始化工作及系统配置，并创建若干个用于高数储存和虚拟管理的内核线程。</p>
<p>随后1号进程调用execve()运行可执行程序init , 并演变成用户态1号进程，它按照系统配置文件/etc/initab 的要求，完成系统的启动工作。并创建编号 1、2 和若干终端注册进程 getty。 当getty检测到来自终端的信号时， getty将通过 execve执行注册程序 login， 此时就可以通过用户名、密码登录。如果登录成功，login() 程序执行shell， shell进程接替 getty 进程的pid 取代getty进程。后续进程再通过shell产生</p>
<p>0号进程–》1号内核进程–》1号内核线程–》1号用户进程–》getty进程–》shell进程</p>
</blockquote>
<a id="more"></a>
<h3 id="进程状态及轮转"><a href="#进程状态及轮转" class="headerlink" title="进程状态及轮转"></a>进程状态及轮转</h3><p><img src="/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/1550453785672.png" alt="1550453785672"></p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>创建状态：进程正在创建尚未就绪，创建经过几个步骤：申请空白PCB、向PCB写入控制和管理信息，然后为进程分配所需资源，最后转入就绪状态</p>
<h5 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h5><p>系统创建（用户登录：分时系统中每个用户登录可以被看成一个新的进程。系统为该终端建立一个进程并插入就绪队列， 作业调度：批处理作业中，当系统按照一定算法调度作业时，将该作业调入内存为其分配资源，提供服务） 应用请求 （用户可以基于自己的需求创建新的进程）</p>
<h5 id="进程创建的过程"><a href="#进程创建的过程" class="headerlink" title="进程创建的过程"></a>进程创建的过程</h5><ol>
<li>为进程申请一个唯一的进程识别号与空白PCB</li>
<li>为进程分配资源，为新进程的程序、数据、用户栈分配内存空间</li>
<li>初始化PCB，主要包括标志信息、状态信息、处理机信息</li>
<li>如果就绪队列能够接受新进程，就将进程插入就绪队列中</li>
</ol>
<h5 id="Linux下的-进程创建"><a href="#Linux下的-进程创建" class="headerlink" title="Linux下的 进程创建"></a>Linux下的 进程创建</h5><p>父进程和子进程：除了0号进程，linux系统中其他任何一个进程都是其他进程创建的。而相对的 ，fork 函数的调用方是父进程， 而创建的新进程是子进程。</p>
<p>fork 函数不需要参数，返回值是一个进程标识符</p>
<p>1 对于父进程，fork函数返回创建子进程ID</p>
<p>2 子进程 fork 函数返回0</p>
<p>3 创建出错的话 fork 函数返回 -1</p>
<p>fork函数创建一个新的进程，并从内核中为其分配一个可用的进程标识符PID，之后为其分配进程空间，并将父进程空间的内容中复制到子进程空间， 包括数据段和堆栈段，和父进程共享代码段。这时候系统中多了一个进程父进程和子进程都接受系统的调度，fork函数返回两次（分别在父进程和子进程中返回）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"fail to fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Subprocess, PID: %u"</span>, getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parentprocess, PID: %u"</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程和父进程共享数据段和堆栈段中的内容。例子略</p>
<p>事实上，子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是，子进程并未复制代码段，而是公用代码段。</p>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>结束状态：进程从系统中消失，这可能是因为正常结束或其他原因中断退出。进程结束时，系统首先标志进程结束，然后进一步释放和回收资源。</p>
<h5 id="进程终止的事件"><a href="#进程终止的事件" class="headerlink" title="进程终止的事件"></a>进程终止的事件</h5><ol>
<li>正常结束</li>
<li>异常结束：出现某种错误导致无法运行，：越界、非法指令、运行超时等等</li>
<li>外界干预：进程应外界请求而终止</li>
</ol>
<h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><ol>
<li>根据被终止的标识符，从PCB结合中检索出PCB并读取进程状态</li>
<li>若进程处于执行状态，立即终止并置标志为真</li>
<li>若进程还有子孙进程，则终止子孙进程防止其不可控</li>
<li>将终止进程的所有资源释放给系统或父进程</li>
<li>将被终止进程移出队列</li>
</ol>
<ul>
<li>运行状态： 进程在处理机上运行</li>
<li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机以外的一切所需资源，只需得到处理机即可执行</li>
<li>阻塞状态（等待，封锁状态）：进程等待某一时间而暂停运行，即使处理机空闲也不嗯呢该运行</li>
</ul>
<h3 id="特殊的进程"><a href="#特殊的进程" class="headerlink" title="特殊的进程"></a>特殊的进程</h3><h5 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h5><p>在linux中 正常情况下子进程是通过父进程创建的， 子进程和父进程的运行是一个异步的过程。父进程无法预料子进程在何时结束，于是就产生了孤儿进程和僵尸进程。</p>
<p>孤儿进程，是指一个父进程退出后，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1） 到进程所收养，并由init进程完成状态收集工作。</p>
<p>僵尸进程，是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被称为僵尸进程。</p>
<p>简单理解为，孤儿是父进程已退出而子进程未退出；而僵尸进程是父进程未退出而子进程先退出。</p>
<p>为了避免僵尸进程，需要父进程通过wait函数来回收子进程 </p>
<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>linux系统中在系统引导时会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择开启的模式，这些模式叫做运行级别。守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。</p>
<p>守护进程是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。说话进程常常在系统引导装入时启动，linux系统有很多的守护进程，大多数服务都是通过守护进程实现的。如作业规划进程、打印进程。</p>
<p>在 linux 中每一个与用户交流的界面称为终端，每一个终端开始的进程都会依附于该终端，这个终端就被称为 进程的控制终端，当控制终端被关闭时，相应的进程都会被自动关闭。但是守护进程可以突破这种限制，它从被执行时开始运转，整个系统关闭时才推出。如果想让某个进程不因为用户或终端等变化受到影响，那么就需把一个进程变成一个守护进程。</p>
<p>创建一个守护进程的步骤如下所示：</p>
<p>1 创建子进程，父进程退出。</p>
<p>这是编写守护进程的第一步。由于守护进程脱离终端控制，因此在第一步完成后就会在终端里造成程序已经运行完毕的假象。之后所有的工作都在子进程完成，而与用户终端脱钩。</p>
<p>2 子进程中创建会话</p>
<p>这个步骤是创建守护进程最重要的一步，虽然他的实现十分简单，但是他的意义重大。这里使用的系统函数setid， 这里有两个概念：进程组和会话期</p>
<p>1) 进程组： 一个或多个进程的集合。进程组由进程组ID来唯一标识，除了进程号以外，进程组ID也是一个进程的必备属性，每个进程组都有一个组长进程，组长进程号等于进程组ID，而且进程组ID不会因为组成进程的退出而受到影响。</p>
<p>2) 会话周期： 会话期是一个或多个进程组的集合。通常一个会话开始于用户登录，终止于用户退出，再次期间运行的所有进程都输入这个会话期。</p>
<p>setid 函数用于创建一个新的会话，并担任该会话组的组长，调用 setid 有三个作用： 1 让进程摆脱原会话的控制 2 让进程摆脱原进程组的控制 3 让进程摆脱原控制终端的控制。</p>
<p>那么 创建守护进程为什么需要setid函数？ 这是由于创建守护进程的第一步掉用了fork函数来创建子进程，再将父进程退出。由于调用fork函数时子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但是会话期、进程组、控制终端等还没有改变，所以还不是真正意义上的独立。</p>
<p>3) 改变当前目录为根目录</p>
<p>这一步骤也是必要的步骤，使用 fork 创建的子进程集成了父进程的工作目录，由于进程的运行过程中当前的目录是不能卸载的，这对于以后的使用造成诸多麻烦。通常的做法是将 “/” 变为守护进程的当前工作目录，这样就可以避免上述问题。</p>
<p>4) 重设文件权限掩码</p>
<p>文件权限掩码是指屏蔽掉文件权限中的对应位。</p>
<p>5) 关闭文件描述符</p>
<p>同文件权限码一样， 用fork函数创建的子进程会从父进程哪里继承一些已经打开的文件，这些文件节能永远不会被守护进程读写，但是他们一样消耗系统资源。所以需要关闭来自继承的文件描述符。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE 65535</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pc;</span><br><span class="line">    <span class="keyword">int</span> i, fd, len;</span><br><span class="line">    <span class="keyword">char</span>* buf = <span class="string">"this is a Dameon\n"</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    pc = fork();</span><br><span class="line">    <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error fock\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXFILE; i++)&#123;</span><br><span class="line">        close(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        if(fd = open('/temp/demeon.log',O_CREAT|O_WRONLY|O_APPEND,0600))&lt;0)&#123;</span><br><span class="line">            perror(<span class="string">"open"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd, buf, len+<span class="number">1</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程间通信就是不同进程间传播或交换信息。 首先进程间可以通过传送、打开文件来实现，不同的进程通过一个或多个文件来传递信息。一般来说进程间通信不包括这种低级的通信方式。Linux操作系统几乎支持所有的UNIX系统进程通信方法：管道、消息队列、共享内存、信号量、套接字。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>父子进程通过管道通信，管道是一种两个进程间单向通信的机制。因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。</p>
<ol>
<li>数据只能由一个进程流向另一个进程（一个读管道和一个写管道）；如果要进行双工通信，则需要建立两个管道。</li>
<li>管道只能用于父子通信或兄弟进程通信（有亲缘关系的进程）。</li>
</ol>
<p>除了上述局限性，管道还有一个不足，比如管道没有名字（匿名管道）；管道的缓冲区大小受限（linux 下一般是4KB）；管道传输的是无格式的字节流。这就需要管道的输入方和输出方事先约定好数据格式。使用管道通信时，两端的进程向管道读写数据是通过创建管道时，系统设置的文件描述符进行的。本质上说管道也是一种文件，但是它又和一般的文件不同，可以克服文件通信的一些问题。</p>
<p>通过管道通信的两个进程，一个向管道写数据，一个从中读数据。写入的数据每次都添加到管道缓冲区的末尾，读数据都是从缓冲区的头部读出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> returned_count;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    pid = fock();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error in fork\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"in child process ..."</span>);</span><br><span class="line">        close(fd(INPUT));</span><br><span class="line">        write(fd(OUTPUT), <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"int parent process ..."</span>);</span><br><span class="line">        close(fd(OUTPUT));</span><br><span class="line">        returned_count = read(fd(INPUT), buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d bytes of data received from child process: %s\n"</span>, returned_count, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    reutrn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子进程中写数据，在父进程中读数据，两个进程实现了通信：父子进程分别有自己的读写通道，为实现父子进程的通信，只需把无关的文件描述符关闭即可。</p>
<h4 id="具名管道"><a href="#具名管道" class="headerlink" title="具名管道"></a>具名管道</h4><p>还有一种管道叫做具名管道（FIFO）它不同之处是它提供一个路径名与之关联，以FIFO的形式存在于文件系统中。这样即使与FIFO创建不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信（能够访问路径和FIFO创建进程之间），因此通过FIFO不相关进程也能交换数据。</p>
<p>有名管道有以下特点</p>
<ol>
<li>他可以使互不相关的两个进程实现通信</li>
<li>该管道可以通过路径名来指明，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样读写，使用很方面</li>
<li>FIFO严格遵循先进先出的规则，对于管道与FIFO总是从开始处返回数据，而把数据添加到末尾。</li>
</ol>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列用运行在同一机器上的进程通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。</p>
<p>消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接收的方式来传递数据的。而且他们都有一个最大长度的限制。</p>
<p>与命名管道相比，消息队列的优势在于：1、消息队列可以独立于发送和接收进程存在，从而消除了同步命名管道时的困哪 2、同时发送消息避免了管道的同步和阻塞，不需要进程提供同步方法 3、接收端可以有选择 的接收数据。</p>
<p>事实上它是一种正在被淘汰的通信方式，完全可以用流管道和套接口的方式取代。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的共享内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的地址空间中，所有进程都可以访问共享 内存中的地址。</p>
<p>不过，共享内存未提供同步机制，需要进程自行进行同步操作。</p>
<p>共享内存的优缺点：</p>
<p>1：优点 使用共享内存通信非常方便，而且函数接口简单，数据共享还使进程间的数据不用传送，而是直接访问内存，加快了效率，并且没有亲缘关系的要求。</p>
<p>2：缺点 共享内存没有提供同步进制，这使得共享内存的通信往往要借助其他手段来完成。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>共享 内存是进程间通信的最快的方式，但是共享 内存的同步问题自身无法解决（即进程该何时去共享内存取得数据，而何时不能取），但用信号量即可轻易解决这个问题 。 </p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h4><h5 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h5><p>高级调度，主要任务是按一定原则从外存中将处于后备状态的作业挑选1个或几个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度）</p>
<h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><p>进程的挂起与就绪</p>
<h5 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h5><p>低级调度，某种方法和策略从就绪队列中选取一个进程，为其分配处理机。进程调度是最基本的调度，频率很高，一般几十毫秒一次</p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先来先服务（FCFS）算法"><a href="#先来先服务（FCFS）算法" class="headerlink" title="先来先服务（FCFS）算法"></a>先来先服务（FCFS）算法</h5><p>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</p>
<p>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待。</p>
<p>特点：算法简单，效率低，对长作业有利，有利于CPU繁忙性作业</p>
<h5 id="短作业优先（SJF）算法"><a href="#短作业优先（SJF）算法" class="headerlink" title="短作业优先（SJF）算法"></a>短作业优先（SJF）算法</h5><p>从后背队列中选择一个或若干个估计运行时间最短的作业调入内存运行</p>
<p>特点：对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态。</p>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p>优先级调度算法每次从后背队列中选取优先级最高的一个或几个作业</p>
<p>特点：优先级调度可以剥夺式占有，也可以非剥夺式占有</p>
<h5 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h5><p>高响应比有限主要用于作业调度，该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比。</p>
<p>响应比的计算为（等待时间+要求服务时间）/ 要求服务时间</p>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>时间片轮转算法适用于分时系统，系统将所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms。</p>
<p>特点：受系统响应时间影响、队列进程数目、进程长短影响较大</p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</p>
<p>1） 设置多个就绪队列，为各个队列赋予优先级，1、2、3等等</p>
<p>2） 赋予各个队列中时间片大小不同，优先级高时间片越小</p>
<p>3） 一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行</p>
<p>4） 仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源。</p>
<p>// entry</p>
<p>// critical section</p>
<p>// exit section</p>
<h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><p>同步：进程之间具有直接制约关系，进程之间需要按照一定的次序进行</p>
<p>互斥：进程之间的间接制约关系，不能同时访问临界区</p>
<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一个整形变量，可以被定义为两个标准的原语<code>wait(S)</code> <code>signal(S)</code> 即P、V操作</p>
<ul>
<li>P操作 如果信号量大于0，执行 -1操作，如果等于0，执行等待信号量大于0</li>
<li>V操作 对信号量完成加1操作，唤醒睡眠的进程 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore mutex = <span class="number">1</span> </span><br><span class="line"><span class="keyword">void</span> P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者-消费者问题"></a>使用信号量实现生产者-消费者问题</h4><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品</p>
<p>由于缓冲区输入临界资源，需要一个互斥量<code>mutex</code>来完成缓冲区的互斥访问</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semahpore</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>使用信号量机制生产消费问题客户端代码需要很多控制，管程作用是把控制的代码独立出来。</p>
<p>管程有一个重要作用：一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</p>
<p>管程的生产者消费者实现</p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</p>
<p>用一个count表示读进程数量，分别用<code>read_mutex</code> 和<code>write_mutex</code> 作为读锁和写锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore count = <span class="number">0</span>;</span><br><span class="line">semaphore read_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore write_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">1</span>) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;write_mutex);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根</p>
<p>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore</span><br><span class="line">semaphore chop[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的定义：多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</p>
<h4 id="死锁四个必要条件："><a href="#死锁四个必要条件：" class="headerlink" title="死锁四个必要条件："></a>死锁四个必要条件：</h4><ul>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。</li>
<li>不剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放</li>
<li>请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。</li>
<li>循环等待条件：存在某一进程的循环等待链，链中每个进程已获得资源下个进程的请求。</li>
</ul>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><p>死锁的处理便是破坏四个必要条件，使得死锁无法发生</p>
<h5 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h5><p>把头埋在沙子里，假装问题没有发生</p>
<p>由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能。</p>
<p>大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略</p>
<h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><ol>
<li><p>破坏互斥条件</p>
<p>对于可共享的资源竞争，不会发生死锁</p>
</li>
<li><p>破坏不剥夺状态</p>
<p>当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要是再重新申请</p>
</li>
<li><p>破坏请求 和 保持条件</p>
<p>预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归期所有。</p>
</li>
<li><p>破坏循环等待</p>
<p>资源顺序分配法，例如为资源编号，每个进程申请分配某个资源以后，再之后只能申请该编号以后的资源</p>
</li>
</ol>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1、P2,,)称为安全序列。如果无法找到安全序列，则系统处于不安全状态。</p>
<p>允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则，进程等待</p>
<p>银行家算法</p>
<p><img src="/2019/03/09/后台开发工程师总结系列-2-操作系统之进程/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>银行家算法是最著名的死锁避免算法。它的思想是，把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款。</p>
<p>进程申请资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源</p>
<h4 id="死锁检测和接触"><a href="#死锁检测和接触" class="headerlink" title="死锁检测和接触"></a>死锁检测和接触</h4><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>死锁定理：</p>
<p>可以通过将资源分配图简化的方法来检测系统状态  S  是否为死锁状态。简化方法如下：（1）、在资源分配图中，找到既不阻塞又不是孤点的进程 Pi （即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的结点。在这里要注意一个问题，判断某种资源是否有空闲，应该用它的资源数量减去它在资源分配图中的出度。（2）、进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可以变为非阻塞进程。根据（1）中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。</p>
<p>S为死锁的条件是：当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。</p>
<h5 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h5><ul>
<li><p>资源剥夺法</p>
<p>挂起死锁进程，抢占其资源分配给其他进程</p>
</li>
<li><p>撤销进程法</p>
<p>强制撤销一些死锁进程</p>
</li>
<li><p>进程回退法</p>
<p>借助历史信息使一个或多个进程回退到系统不再死锁的地步</p>
</li>
</ul>
<h2 id="问题简析"><a href="#问题简析" class="headerlink" title="问题简析"></a>问题简析</h2><p><strong>1 同步和异步的区别</strong></p>
<p><strong>同步</strong>和<strong>异步</strong>通常用来形容一次方法调用。</p>
<ul>
<li><strong>同步方法</strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li>
<li><strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</li>
</ul>
<p><strong>2 进程和线程的区别，谁调度的进程</strong></p>
<ul>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li>
<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>
<li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li>
<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>
</ul>
<p><strong>3 死锁的条件，如何检测死锁</strong></p>
<p>见上文死锁条件</p>
<p>死锁定理：</p>
<p>可以通过将资源分配图简化的方法来检测系统状态  S  是否为死锁状态。简化方法如下：（1）、在资源分配图中，找到既不阻塞又不是孤点的进程 Pi （即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的结点。在这里要注意一个问题，判断某种资源是否有空闲，应该用它的资源数量减去它在资源分配图中的出度。（2）、进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可以变为非阻塞进程。根据（1）中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。</p>
<p>S为死锁的条件是：当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。<br><strong>4 死锁的必要条件，银行家算法</strong></p>
<p>见上文死锁条件 </p>
<p>见上文银行家算法</p>
<p><strong>5 调度算法有哪些</strong></p>
<p>见上文调度算法</p>
<p><strong>6 通俗的语言，面对一个非程序员，解释进程与线程的区别</strong></p>
<p>个人理解：把进程和线程比作一家公司和公司的员工，类比如下：</p>
<ol>
<li>进程是分配资源的最小单位（资金、材料、工具属于公司），而线程是最小的调度单位（公司领导指派某个人去工作）</li>
<li>进程有独立的地址空间，独立的代码段、堆栈段和数据段，申请昂贵（公司有独立的地址、办公室、公章、注册单位）而且进程间切换代价大，一个进程内的线程切换十分方便（同一个公司的员工互相调动很方便）</li>
<li>线程间通信方便，由于线程共享堆栈、数据段（公司内部沟通方便）而进程间沟通需要通过IPC方式，还需要处理同步、互斥，这也是多线程编程的难点。</li>
<li>而多进程更加的健壮，进程间并不互相依赖。（公司A和公司B都可以独立完成一个项目）</li>
</ol>
<p><strong>7 死锁是什么，为什么会产生死锁，怎么解决死锁问题，预防死锁、避免死锁</strong></p>
<p>死锁的定义：多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</p>
<p>死锁有四个必要条件：互斥、不剥夺、请求和保持、循环等待</p>
<p>破坏这些条件，包括：资源剥夺、撤销进程、进程回退</p>
<p>可以采用银行家算法预防和避免死锁</p>
<p><strong>8 进程的同步进制有哪些？ 进程的通信机制有哪些？</strong></p>
<p>临界区、互斥量、信号量、事件</p>
<p>临界区： 通过多线程的串行化来保证某一时刻只有一个线程能访问资源或代码，适合控制数据访问，只能控制同一进程中的线程</p>
<p>互斥量： 为协调共享资源设计，互斥对象只有一个，只有拥有互斥对象的线程可以访问资源</p>
<p>信号量：允许多个线程访问同一资源，但是限制线程数目。适用于跨进程同步，功能强大。</p>
<p>事件：通知线程有事情发生， 启动后续任务。</p>
<p>进程通信：</p>
<p>管道：父子进程通过管道通信，管道是一种两个进程间单向通信的机制。因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。</p>
<p>具名管道（FIFO）：还有一种管道叫做具名管道（FIFO）它不同之处是它提供一个路径名与之关联，以FIFO的形式存在于文件系统中。这样即使与FIFO创建不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信（能够访问路径和FIFO创建进程之间），因此通过FIFO不相关进程也能交换数据。</p>
<p>消息队列：消息队列用运行在同一机器上的进程通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接收的方式来传递数据的。而且他们都有一个最大长度的限制</p>
<p>共享内存：共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的共享内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的地址空间中，所有进程都可以访问共享 内存中的地址。</p>
<p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>9 进程的状态转换图及转换事件</strong></p>
<p>见上文</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/09/后台开发工程师总结系列-3-操作系统之线程/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [后台开发工程师总结系列] 3.操作系统之线程
        
      </div>
    </a>
  
  
    <a href="/2019/03/09/后台开发工程师总结系列-1-C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[后台开发工程师总结系列] 1.C++</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的概念和特征"><span class="nav-number">1.1.</span> <span class="nav-text">进程的概念和特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程状态及轮转"><span class="nav-number">1.2.</span> <span class="nav-text">进程状态及轮转</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起进程创建的事件"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">引起进程创建的事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程创建的过程"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">进程创建的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux下的-进程创建"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">Linux下的 进程创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程终止"><span class="nav-number">1.2.2.</span> <span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程终止的事件"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">进程终止的事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的终止过程"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">进程的终止过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的进程"><span class="nav-number">1.3.</span> <span class="nav-text">特殊的进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#僵尸进程和孤儿进程"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">僵尸进程和孤儿进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#守护进程"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">守护进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信"><span class="nav-number">1.4.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管道"><span class="nav-number">1.4.1.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具名管道"><span class="nav-number">1.4.2.</span> <span class="nav-text">具名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列"><span class="nav-number">1.4.3.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存"><span class="nav-number">1.4.4.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">1.4.5.</span> <span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度"><span class="nav-number">1.5.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度层次"><span class="nav-number">1.5.1.</span> <span class="nav-text">调度层次</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#作业调度"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">作业调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中级调度"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">中级调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程调度-1"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">进程调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度算法"><span class="nav-number">1.5.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#先来先服务（FCFS）算法"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">先来先服务（FCFS）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#短作业优先（SJF）算法"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">短作业优先（SJF）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先级调度算法"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高响应比优先"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">高响应比优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间片轮转调度算法"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">时间片轮转调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界区"><span class="nav-number">1.5.3.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步与互斥"><span class="nav-number">1.5.4.</span> <span class="nav-text">同步与互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量-1"><span class="nav-number">1.5.5.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用信号量实现生产者-消费者问题"><span class="nav-number">1.5.6.</span> <span class="nav-text">使用信号量实现生产者-消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程"><span class="nav-number">1.5.7.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">1.5.8.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哲学家进餐问题"><span class="nav-number">1.5.9.</span> <span class="nav-text">哲学家进餐问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">1.6.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁四个必要条件："><span class="nav-number">1.6.1.</span> <span class="nav-text">死锁四个必要条件：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的处理策略"><span class="nav-number">1.6.2.</span> <span class="nav-text">死锁的处理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#鸵鸟策略"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">鸵鸟策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁预防"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁避免"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁检测和接触"><span class="nav-number">1.6.3.</span> <span class="nav-text">死锁检测和接触</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁检测"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁解除"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#问题简析"><span class="nav-number">2.</span> <span class="nav-text">问题简析</span></a></li>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 MapleStory All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
